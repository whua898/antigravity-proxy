/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall sub_180001000(double _XMM0_8, double _XMM1_8);
int sub_180001180();
int sub_1800011C0();
int __fastcall sub_180001200(double _XMM0_8);
int __fastcall sub_180001280(double _XMM0_8);
int sub_180001300();
int sub_180001310();
wchar_t *__fastcall sub_180001350(__int64 a1, unsigned __int16 a2, unsigned __int64 a3);
_QWORD *__fastcall sub_1800014E0(_QWORD *a1, __int64 a2);
const char *__fastcall sub_180001520(__int64 a1);
char *__fastcall sub_180001540(char *Block, char a2);
__int64 __fastcall sub_180001590(_QWORD *a1);
_QWORD *__fastcall sub_1800015B0(_QWORD *a1);
// void __fastcall __noreturn Concurrency::cancel_current_task(); idb
_QWORD *__fastcall sub_180001600(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_180001640(_QWORD *a1, __int64 a2);
void __noreturn sub_180001680();
void __fastcall sub_1800016A0(HMODULE a1, __int64 a2, double _XMM2_8);
char __fastcall sub_1800020D0(const wchar_t *a1);
char __fastcall sub_1800024E0(const char *a1);
__int64 __fastcall sub_180002770(_QWORD); // weak
__int64 __fastcall sub_180002780(_QWORD); // weak
__int64 __fastcall sub_1800027F0(_QWORD); // weak
_QWORD *__fastcall sub_180002860(_QWORD *_RCX, unsigned __int64 *a2);
void __fastcall sub_180002980(char **a1, char **a2);
void *__fastcall sub_180002A10(_QWORD *a1, const void *a2, unsigned __int64 a3);
void *__fastcall sub_180002B40(_QWORD *a1, const void *a2, size_t a3);
void __fastcall sub_180002C40(__int64 a1);
unsigned __int64 __fastcall sub_180002CB0(__int64 a1, __int64 a2, unsigned __int64 *a3);
__int64 __fastcall sub_180002F50(_QWORD); // weak
void **__fastcall sub_180002F60(void **Src, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_180003110(_QWORD); // weak
__int64 __fastcall sub_180003120(_QWORD); // weak
void __noreturn sub_180003190();
size_t __fastcall sub_1800031B0(unsigned __int64 *a1, unsigned __int64 a2);
void __noreturn sub_180003240();
__int64 __fastcall sub_180003260(_QWORD); // weak
void __noreturn sub_180003290();
__int64 __fastcall sub_1800032B0(HANDLE hProcess, unsigned int a2);
__int64 __fastcall sub_180003580(const wchar_t *a1, const wchar_t *a2, __int64 a3, __int64 a4, int a5, char a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);
__int64 __fastcall sub_180003650(const char *a1, const char *a2, __int64 a3, __int64 a4, int a5, char a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);
int __fastcall sub_180003720(double a1);
errno_t sub_180003930();
__int64 __fastcall sub_180003990(HMODULE hModule, int a2, double a3);
__int64 __fastcall sub_180003C30(_QWORD); // weak
void __fastcall sub_180003C40(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_180003C90(_QWORD *a1, __int64 a2, __int64 a3);
void *sub_180003F10();
__int64 sub_180003F20();
__int64 __fastcall sub_180003F30(_QWORD); // weak
_QWORD *__fastcall sub_180003F50(_QWORD *_RCX, char *a2);
__int64 __fastcall sub_180004420(_QWORD *_RCX, __int64 *a2);
__int64 __fastcall sub_180004690(_QWORD); // weak
bool __fastcall sub_1800046E0(__int64 a1, __int64 a2);
bool __fastcall sub_180004A00(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_180004B60(__int64 a1, _QWORD *_RDX);
_QWORD *__fastcall sub_180004D00(_QWORD *a1, char *a2, const CHAR *a3);
unsigned __int64 *__fastcall sub_1800053A0(unsigned __int64 *a1, const void **a2, unsigned __int64 *a3);
void __fastcall sub_180005920(__int64 a1);
void __fastcall sub_1800059F0(char *a1, double _XMM1_8);
__int64 __fastcall sub_1800060C0(_QWORD); // weak
int sub_1800061C0(char *Buffer, char *Format, ...);
_QWORD *__fastcall sub_180006220(__int64 a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall sub_1800062E0(_QWORD); // weak
__int64 __fastcall sub_180006340(_QWORD); // weak
__int64 *__fastcall sub_1800063A0(__int64 a1, __int64 *a2, const void **a3);
void __fastcall sub_1800064D0(void **a1);
unsigned __int64 *__fastcall sub_180006540(unsigned __int64 *a1, unsigned __int64 **a2);
void __fastcall sub_180006600(__int64 a1, _BYTE *a2, const void *a3, size_t a4);
__int64 __fastcall sub_180006830(__int64 a1, __int64 a2, unsigned __int64 *a3);
void __fastcall sub_1800069E0(__int64 a1, unsigned __int64 *a2, unsigned __int64 a3);
__int64 __fastcall sub_180006C00(__int64 a1);
void __fastcall sub_180006C20(__int64 a1);
_QWORD *__fastcall sub_180006C30(_QWORD *a1, char a2);
__int64 __fastcall StartAddress(void *a1);
__int64 __fastcall sub_180006CA0(char *a1, double a2);
_BYTE *__fastcall sub_180006CE0(_QWORD *a1, _BYTE *a2, _BYTE *a3);
void __fastcall sub_180006E60(__int64 a1, __int64 a2, char *a3);
unsigned __int64 __fastcall sub_180006EC0(__int64 a1, __int64 a2, __int64 a3);
void **__fastcall sub_180007180(void **Src, __int64 a2, __int64 a3, char a4);
__int64 __fastcall sub_1800072F0(_QWORD); // weak
_QWORD *__fastcall sub_180007320(_QWORD *a1, _QWORD *a2);
void __fastcall sub_1800077E0(char **a1);
void **__fastcall sub_180007850(void **a1, const void *a2, size_t a3);
void __fastcall sub_1800079B0(__int64 a1);
void __fastcall sub_180007A30(__int64 a1);
__int64 __fastcall sub_180007AB0(char **a1);
void __fastcall sub_180007B20(void **a1);
void __fastcall sub_180007B50(void **a1);
__int64 __fastcall sub_180007B80(double _XMM0_8, __int64 a2, size_t *a3);
__int64 __fastcall sub_180007E60(double _XMM0_8, __int64 a2, unsigned __int8 *a3);
_QWORD *__fastcall sub_180008130(__int64 a1, _QWORD *a2, size_t *a3, __int64 a4);
void __fastcall sub_180008210(__int64 a1, _QWORD **a2);
void __fastcall sub_1800082B0(__int64 a1, _QWORD **a2);
__int64 __fastcall sub_180008350(_QWORD); // weak
__int64 __fastcall sub_1800083E0(_QWORD); // weak
__int64 __fastcall sub_180008470(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
int __fastcall sub_1800085D0(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_180008830(__int64 a1, unsigned __int64 a2);
bool __fastcall sub_1800089E0(const void *a1, char *a2);
__int64 __fastcall sub_180008A80(char *a1);
LPVOID __fastcall sub_180008C80(char *a1, unsigned __int64 a2);
LPVOID __fastcall sub_180008DA0(unsigned __int64 a1, __int64 a2);
LPVOID __fastcall sub_180008EB0(char *a1, unsigned __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_180008F70(unsigned __int64 a1);
DWORD sub_180009150();
__int64 __fastcall sub_180009230(double _XMM0_8);
__int64 __fastcall sub_1800097F0(HANDLE hThread); // idb
__int64 __fastcall sub_180009890(_BYTE **a1, _BYTE *a2);
__int64 __fastcall sub_180009DB0(const void **a1, _BYTE *a2);
char *__fastcall sub_18000A030(__int64 a1, int *a2, char *a3, _BYTE *a4);
__int64 __fastcall sub_18000A240(__int64 a1, __int64 a2, _BYTE *a3, _BYTE *a4);
__int64 __fastcall sub_18000A280(__int64 a1, __int64 a2, _BYTE *a3, _BYTE *a4);
__int64 __fastcall sub_18000A2C0(__int64 a1, __int64 a2, _BYTE *a3, _BYTE *a4);
_BYTE *__fastcall sub_18000A300(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4);
__int64 __fastcall sub_18000A370(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_18000A380(__int64 a1, __int64 a2, _BYTE *a3, _BYTE *a4);
__int64 __fastcall sub_18000A3C0(_DWORD *a1);
__int64 __fastcall sub_18000A3F0(_DWORD *a1, __int64 a2, _BYTE *a3, _BYTE *a4);
__int64 __fastcall sub_18000A430(__int64 a1, __int64 a2, _BYTE *a3, _BYTE *a4);
__int64 __fastcall sub_18000A470(__int64 a1, __int64 a2, _BYTE *a3, _BYTE *a4);
__int64 __fastcall sub_18000A4B0(__int64 a1, __int64 a2, _BYTE *a3, _BYTE *a4);
char *__fastcall sub_18000A4F0(__int64 a1, __int64 a2, char *a3, _BYTE *a4);
char *__fastcall sub_18000A510(__int64 a1, __int64 a2, char *a3, _BYTE *a4);
char *__fastcall sub_18000A530(__int64 a1, __int64 a2, char *a3, __int64 a4);
char *__fastcall sub_18000A5B0(_DWORD *a1, unsigned __int8 a2, char *a3, _BYTE *a4, char a5, unsigned __int8 a6);
char *__fastcall sub_18000A660(_DWORD *a1, __int64 a2, _BYTE *a3, _BYTE *a4);
char *__fastcall sub_18000A6C0(_DWORD *a1, __int64 a2, _BYTE *a3, _BYTE *a4);
char *__fastcall sub_18000A700(_DWORD *a1, __int64 a2, __int64 a3, int *a4);
char *__fastcall sub_18000A7F0(__int64 a1, __int64 a2, char *a3, _BYTE *a4);
int __fastcall sub_18000A840(double a1);
char *__fastcall sub_18000A910(__int64 a1, _BYTE *a2, __int64 a3);
void __noreturn sub_18000AAD0();
__int64 __fastcall sub_18000AAF0(unsigned __int64 a1, unsigned int a2, _DWORD *a3);
char __fastcall sub_18000ABC0(__int64 a1, __int64 a2);
char __fastcall sub_18000B090(SOCKET fd, __int64 a2);
__int64 __fastcall sub_18000B1E0(SOCKET fd, __int64 a2, unsigned int a3, __int64 a4, int a5, __int64 a6, __int64 a7);
__int64 __fastcall sub_18000B390(SOCKET fd, __int64 a2, unsigned int a3, unsigned int a4);
__int64 __fastcall sub_18000B490(SOCKET fd, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
__int64 __fastcall sub_18000B5C0(wchar_t *String, __int64 a2, __int64 a3, _QWORD *a4);
__int64 __fastcall sub_18000BC10(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_18000BE40(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
__int64 __fastcall sub_18000C0C0(unsigned __int64 a1, __int64 a2, unsigned int a3, __int64 a4, int a5, __int64 a6, __int64 a7);
__int64 __fastcall sub_18000C260(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 *a5, unsigned int a6);
__int64 __fastcall sub_18000C330(unsigned __int64 a1);
int __fastcall sub_18000C460(double a1);
int sub_18000CC70(wchar_t *Buffer, wchar_t *Format, ...);
char *__fastcall sub_18000CCD0(double _XMM0_8, unsigned __int64 *a2);
void __fastcall sub_18000CDD0(__int64 a1, __int64 a2, __int64 a3);
void **__fastcall sub_18000CE20(void **Src, __int64 a2, __int64 a3, __int16 a4);
_QWORD *__fastcall sub_18000CFA0(_QWORD *a1, _QWORD *a2);
int sub_18000D460(wchar_t *Buffer, size_t BufferCount, wchar_t *Format, ...);
BOOL __stdcall GetFileVersionInfoA(LPCSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
__int64 __fastcall GetFileVersionInfoByHandle(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4);
BOOL __stdcall GetFileVersionInfoExA(DWORD dwFlags, LPCSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
BOOL __stdcall GetFileVersionInfoExW(DWORD dwFlags, LPCWSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
DWORD __stdcall GetFileVersionInfoSizeA(LPCSTR lptstrFilename, LPDWORD lpdwHandle);
DWORD __stdcall GetFileVersionInfoSizeExA(DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle);
DWORD __stdcall GetFileVersionInfoSizeExW(DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle);
DWORD __stdcall GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle);
BOOL __stdcall GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
DWORD __stdcall VerFindFileA(DWORD uFlags, LPCSTR szFileName, LPCSTR szWinDir, LPCSTR szAppDir, LPSTR szCurDir, PUINT puCurDirLen, LPSTR szDestDir, PUINT puDestDirLen);
DWORD __stdcall VerFindFileW(DWORD uFlags, LPCWSTR szFileName, LPCWSTR szWinDir, LPCWSTR szAppDir, LPWSTR szCurDir, PUINT puCurDirLen, LPWSTR szDestDir, PUINT puDestDirLen);
DWORD __stdcall VerInstallFileA(DWORD uFlags, LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir, LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, PUINT puTmpFileLen);
DWORD __stdcall VerInstallFileW(DWORD uFlags, LPCWSTR szSrcFileName, LPCWSTR szDestFileName, LPCWSTR szSrcDir, LPCWSTR szDestDir, LPCWSTR szCurDir, LPWSTR szTmpFile, PUINT puTmpFileLen);
DWORD __stdcall VerLanguageNameA(DWORD wLang, LPSTR szLang, DWORD cchLang);
DWORD __stdcall VerLanguageNameW(DWORD wLang, LPWSTR szLang, DWORD cchLang);
BOOL __stdcall VerQueryValueA(LPCVOID pBlock, LPCSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);
BOOL __stdcall VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);
char __fastcall sub_18000DD90(const __m128i *a1, __int64 a2);
unsigned __int64 __fastcall sub_18000DDF0(__m128i *Src, unsigned __int64 a2, __m128i *a3, unsigned __int64 a4);
const __m128i *__fastcall sub_18000DFE0(const __m128i *a1, const __m128i *a2, unsigned __int8 a3);
unsigned __int64 __fastcall sub_18000E0E0(const __m128i *Src, __int64 a2, const __m128i *a3, __int64 a4);
unsigned __int64 __fastcall sub_18000E320(void *Src, unsigned __int64 a2, unsigned __int16 *a3, unsigned __int64 a4);
int __fastcall sub_18000E450(unsigned __int16 *a1, unsigned __int64 a2);
const __m128i *__fastcall sub_18000E5B0(const __m128i *a1, const __m128i *a2, const __m128i *a3, size_t a4);
__int64 __fastcall sub_18000E7A0(void *Src); // idb
const __m128i *__fastcall sub_18000E7B0(const __m128i *, const __m128i *, const __m128i *, size_t);
void __noreturn sub_18000E7C0();
void *__fastcall sub_18000E800(size_t Size);
__int64 __fastcall sub_18000E83C(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_18000E8A8(__int64 a1, __int64 a2, __int64 a3, __int64 (__fastcall *a4)(__int64));
char sub_18000E904();
char sub_18000E940();
bool sub_18000E974();
char sub_18000E98C();
char sub_18000E9B4();
int __fastcall sub_18000E9CC(__int64 a1, int a2, __int64 a3, void (__fastcall *a4)(__int64, _QWORD, __int64), unsigned int ExceptionNum, struct _EXCEPTION_POINTERS *ExceptionPtr);
void sub_18000EA2C();
char sub_18000EA5C();
char __fastcall sub_18000EA70(int a1);
char __fastcall sub_18000EAAC(unsigned int a1);
bool __fastcall sub_18000EB38(__int64 a1);
char __fastcall sub_18000EBD0(char a1);
char __fastcall sub_18000EBF4(__int64 a1, char a2);
void (__cdecl *__fastcall sub_18000EC20(void (__cdecl *Function)()))();
// int __cdecl atexit(void (__cdecl *)());
void __cdecl j_j_free(void *Block);
_QWORD *__fastcall sub_18000EC80(_QWORD *a1, char a2);
__int64 __fastcall sub_18000ECC0(__int64 a1, int a2, __int64 a3);
__int64 sub_18000ED10();
__int64 __fastcall sub_18000EE28(char a1);
__int64 __fastcall sub_18000EEAC(HMODULE hModule, int a2, __int64 a3);
__int64 __fastcall sub_18000F040(__int64 a1, __int64 a2);
__int64 sub_18000F0A4();
_QWORD *__fastcall sub_18000F340(_QWORD *a1);
// void __fastcall __noreturn Concurrency::cancel_current_task(); idb
__int64 sub_18000F394();
// bool __fastcall __uncaught_exception(); idb
// void __fastcall __noreturn RtlFailFast(_QWORD); weak
__int64 sub_18000F3B8();
void sub_18000F468();
__int64 sub_18000F478();
void *sub_18000F484();
_QWORD *sub_18000F48C();
void *sub_18000F4A8();
void sub_18000F4B0();
void sub_18000F4EC();
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// void *__cdecl memset(void *, int Val, size_t Size);
// __int64 __fastcall _std_type_info_destroy_list(_QWORD); weak
// void *__cdecl malloc(size_t Size);
// int __cdecl callnewh(size_t Size);
// int __cdecl seh_filter_dll(unsigned int ExceptionNum, struct _EXCEPTION_POINTERS *ExceptionPtr);
// errno_t __cdecl configure_narrow_argv(_crt_argv_mode mode);
// int __cdecl initialize_narrow_environment();
// int __cdecl initialize_onexit_table(_onexit_table_t *Table);
// int __cdecl register_onexit_function(_onexit_table_t *Table, _onexit_t Function);
// int __cdecl execute_onexit_table(_onexit_table_t *Table);
// int __cdecl crt_atexit(_PVFV Function);
// void __cdecl cexit();
// void __cdecl initterm(_PVFV *First, _PVFV *Last);
// int __cdecl initterm_e(_PIFV *First, _PIFV *Last);
char sub_18000F5D0();
// size_t __cdecl strlen(const char *Str);
// size_t __cdecl wcslen(const wchar_t *String);
__int64 __fastcall guard_dispatch_icall_nop(); // weak
__int64 __fastcall sub_18000F7C6(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F7D2(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F7FC(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F808(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F820(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F82C(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F838(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F850(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F85C(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F870(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F8C0(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F8CC(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F906(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F946(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F990(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F99C(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F9A8(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F9F0(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000F9FC(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FA08(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FA24(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FA50(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FA6C(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FA78(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FA84(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FAA0(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FACC(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FAE8(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FAF4(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FB24(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FB30(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FB70(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FB7C(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FB88(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FB94(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FBA0(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FBFC(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FC30(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FC3C(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FC9C(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FCBC(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FCF0(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FD00(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FD40(__int64 a1, __int64 a2);
__int64 __fastcall sub_18000FD58(__int64 a1, __int64 a2);
void __fastcall sub_18000FF70();
void __fastcall sub_180010050();
void __fastcall sub_1800100C0();
void __fastcall sub_1800100D0();
void __fastcall sub_1800100E0();
void __fastcall sub_1800100F0(double _XMM0_8);
void __fastcall sub_180010160();
// void std::_Xout_of_range(const char *); weak
// void __noreturn std::_Xlength_error(const char *); weak
// void std::_Throw_Cpp_error(_DWORD); weak
// __int64 __fastcall _std_exception_destroy(_QWORD); weak
// __int64 __fastcall _std_exception_copy(_QWORD); weak
// void __noreturn terminate(void); weak

//-------------------------------------------------------------------------
// Data declarations

// extern DWORD (__stdcall *GetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// extern BOOL (__stdcall *WriteProcessMemory)(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern BOOL (__stdcall *SetEnvironmentVariableW)(LPCWSTR lpName, LPCWSTR lpValue);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern UINT (__stdcall *GetSystemDirectoryW)(LPWSTR lpBuffer, UINT uSize);
// extern DWORD (__stdcall *ResumeThread)(HANDLE hThread);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern LPVOID (__stdcall *VirtualAllocEx)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern HANDLE (__stdcall *CreateRemoteThread)(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern BOOL (__stdcall *VirtualFreeEx)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern ULONGLONG (__stdcall *GetTickCount64)();
// extern DWORD (__stdcall *GetTickCount)();
// extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern void (__stdcall *SetLastError)(DWORD dwErrCode);
// extern BOOL (__stdcall *VirtualFree)(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern DWORD (__stdcall *SuspendThread)(HANDLE hThread);
// extern DWORD (__stdcall *GetLastError)();
// extern HANDLE (__stdcall *GetCurrentThread)();
// extern HMODULE (__stdcall *LoadLibraryW)(LPCWSTR lpLibFileName);
// extern BOOL (__stdcall *GetThreadContext)(HANDLE hThread, LPCONTEXT lpContext);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern BOOL (__stdcall *FlushInstructionCache)(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize);
// extern BOOL (__stdcall *SetThreadContext)(HANDLE hThread, const CONTEXT *lpContext);
// extern SIZE_T (__stdcall *VirtualQuery)(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// extern BOOL (__stdcall *InitOnceBeginInitialize)(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern BOOL (__stdcall *InitOnceComplete)(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext);
// extern int (__cdecl *Thrd_join)(_Thrd_t *__struct_ptr, int *);
// extern void (__cdecl *Cnd_do_broadcast_at_thread_exit)();
// extern int (__cdecl *Mtx_lock)(_Mtx_t);
// extern int (__cdecl *Mtx_unlock)(_Mtx_t);
// extern _Thrd_id_t (__cdecl *Thrd_id)();
// extern SECURITY_STATUS (__stdcall *InitializeSecurityContextA)(PCredHandle phCredential, PCtxtHandle phContext, SEC_CHAR *pszTargetName, unsigned int fContextReq, unsigned int Reserved1, unsigned int TargetDataRep, PSecBufferDesc pInput, unsigned int Reserved2, PCtxtHandle phNewContext, PSecBufferDesc pOutput, unsigned int *pfContextAttr, PTimeStamp ptsExpiry);
// extern SECURITY_STATUS (__stdcall *DecryptMessage)(PCtxtHandle phContext, PSecBufferDesc pMessage, unsigned int MessageSeqNo, unsigned int *pfQOP);
// extern SECURITY_STATUS (__stdcall *FreeCredentialsHandle)(PCredHandle phCredential);
// extern SECURITY_STATUS (__stdcall *FreeContextBuffer)(PVOID pvContextBuffer);
// extern SECURITY_STATUS (__stdcall *EncryptMessage)(PCtxtHandle phContext, unsigned int fQOP, PSecBufferDesc pMessage, unsigned int MessageSeqNo);
// extern SECURITY_STATUS (__stdcall *AcquireCredentialsHandleA)(LPSTR pszPrincipal, LPSTR pszPackage, unsigned int fCredentialUse, void *pvLogonId, void *pAuthData, SEC_GET_KEY_FN pGetKeyFn, void *pvGetKeyArgument, PCredHandle phCredential, PTimeStamp ptsExpiry);
// extern SECURITY_STATUS (__stdcall *DeleteSecurityContext)(PCtxtHandle phContext);
// extern SECURITY_STATUS (__stdcall *QueryContextAttributesW)(PCtxtHandle phContext, unsigned int ulAttribute, void *pBuffer);
// extern void (__stdcall *WSASetLastError)(int iError);
// extern int (__stdcall *getpeername)(SOCKET s, struct sockaddr *name, int *namelen);
// extern u_short (__stdcall *ntohs)(u_short netshort);
// extern int (__stdcall *_WSAFDIsSet)(SOCKET fd, fd_set *);
// extern int (__stdcall *WSAGetLastError)();
// extern int (__stdcall *closesocket)(SOCKET s);
// extern INT (__stdcall *inet_pton)(INT Family, PCSTR pszAddrString, PVOID pAddrBuf);
// extern int (__stdcall *send)(SOCKET s, const char *buf, int len, int flags);
// extern int (__stdcall *select)(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout);
// extern PCSTR (__stdcall *inet_ntop)(INT Family, const void *pAddr, PSTR pStringBuf, size_t StringBufSize);
// extern SOCKET (__stdcall *socket)(int af, int type, int protocol);
// extern int (__stdcall *connect)(SOCKET s, const struct sockaddr *name, int namelen);
// extern int (__stdcall *recv)(SOCKET s, char *buf, int len, int flags);
// extern u_short (__stdcall *htons)(u_short hostshort);
// extern int (__stdcall *setsockopt)(SOCKET s, int level, int optname, const char *optval, int optlen);
// extern u_long (__stdcall *ntohl)(u_long netlong);
// extern int (__cdecl *atoi)(const char *String);
// extern errno_t (__cdecl *wsplitpath_s)(const wchar_t *FullPath, wchar_t *Drive, size_t DriveCount, wchar_t *Dir, size_t DirCount, wchar_t *Filename, size_t FilenameCount, wchar_t *Ext, size_t ExtCount);
// extern void *(__cdecl *malloc)(size_t Size);
// extern void (__cdecl *free)(void *Block);
// extern void (__cdecl __noreturn *abort)();
// extern uintptr_t (__cdecl *beginthreadex)(void *Security, unsigned int StackSize, _beginthreadex_proc_type StartAddress, void *ArgList, unsigned int InitFlag, unsigned int *ThrdAddr);
// extern int (__cdecl *fclose)(FILE *Stream);
// extern errno_t (__cdecl *wfopen_s)(FILE **Stream, const wchar_t *FileName, const wchar_t *Mode);
// extern char *(__cdecl *fgets)(char *Buffer, int MaxCount, FILE *Stream);
// extern int (__cdecl *_stdio_common_vswprintf_s)(unsigned __int64 Options, wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, _locale_t Locale, va_list ArgList);
// extern int (__cdecl *_stdio_common_vsprintf_s)(unsigned __int64 Options, char *Buffer, size_t BufferCount, const char *Format, _locale_t Locale, va_list ArgList);
// extern errno_t (__cdecl *wcsncpy_s)(wchar_t *Destination, rsize_t SizeInWords, const wchar_t *Source, rsize_t MaxCount);
// extern int (__cdecl *tolower)(int C);
// extern int (__cdecl *wcsicmp)(const wchar_t *String1, const wchar_t *String2);
__int64 (__fastcall *_guard_dispatch_icall_fptr)() = &guard_dispatch_icall_nop; // weak
const _PVFV qword_1800113F8 = NULL; // idb
const _PVFV qword_180011438 = NULL; // idb
const _PIFV First = NULL; // idb
const _PIFV Last = NULL; // idb
_UNKNOWN unk_180013B30; // weak
__int128 xmmword_180013B50 = 0xFF00FF00FF00FF00FF00FF00FF00FF00LL; // weak
__int128 xmmword_180013B60 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFLL; // weak
void *type_info::`vftable' = &sub_18000EC80; // weak
void *std::exception::`vftable' = &sub_180001540; // weak
void *std::bad_alloc::`vftable' = &sub_180001540; // weak
void *std::bad_array_new_length::`vftable' = &sub_180001540; // weak
wchar_t asc_180013C98[3] = L"\\/"; // weak
__int64 (__fastcall *___7___Ref_count_obj2_URaceResult__1__resolveDnsFastest__YA_AV__vector_V__basic_string_DU__char_traits_D_std__V__allocator_D_2__std__V__allocator_V__basic_string_DU__char_traits_D_std__V__allocator_D_2__std___2__std__AEBV__basic_string_DU__char_traits_D_std__V__allocator_D_2__4_0_Z__std__6B_[4])() = { &sub_180006C20, &sub_180006C00, &sub_180006C30, &sub_180003F20 }; // weak
_UNKNOWN unk_180013E88; // weak
void (*qword_180014970[2])(void) = { NULL, NULL }; // weak
void (*qword_180014980)(void) = NULL; // weak
int dword_180017008 = 1; // weak
int dword_18001700C = 2; // weak
__int64 qword_180017010 = 524288LL; // weak
__int64 qword_180017018 = 33554432LL; // weak
__int64 qword_180017020 = -1LL; // weak
uintptr_t _security_cookie = 47936899621426uLL;
__int64 qword_180017080 = -47936899621427LL; // weak
_UNKNOWN unk_1800170A0; // weak
int dword_1800170EC = 0; // weak
_UNKNOWN unk_1800170F0; // weak
int dword_18001713C = 0; // weak
_UNKNOWN unk_180017140; // weak
int dword_18001718C = 0; // weak
int dword_180017190 = -268435455; // weak
_UNKNOWN unk_1800171A0; // weak
int dword_1800171EC = 0; // weak
int dword_180017400; // weak
__int64 qword_180017408; // weak
char byte_180017410; // weak
char byte_180017411; // weak
_onexit_table_t Table; // idb
_onexit_table_t stru_180017430; // idb
int dword_180017448; // weak
int dword_18001744C; // weak
int dword_180017450; // weak
union _SLIST_HEADER stru_180017460; // weak
_UNKNOWN unk_180017470; // weak
int dword_180017478; // weak
union _RTL_RUN_ONCE stru_180017480; // idb
union _RTL_RUN_ONCE InitOnce; // idb
_UNKNOWN unk_180017490; // weak
int dword_1800174A0; // weak
int dword_1800174A4; // weak
int dword_1800174A8; // weak
int dword_1800174AC; // weak
PCSTR ymmword_1800174B0; // idb
__int16 word_1800174D0; // weak
__int64 qword_1800174D8; // weak
__int128 xmmword_1800174E0; // weak
char byte_1800174F0; // weak
void *ymmword_1800174F8; // idb
void *qword_180017518; // idb
__int64 qword_180017520; // weak
__int64 qword_180017528; // weak
__int64 qword_180017530; // weak
void *Src; // idb
__int64 qword_180017548; // weak
void *qword_180017550; // idb
__int64 qword_180017558; // weak
HMODULE hModule; // idb
__int64 qword_180017568; // weak
__int64 qword_180017570; // weak
int dword_180017578; // weak
int dword_180017580; // weak
__int64 qword_180017588; // weak
__int64 qword_180017590; // weak
__int64 qword_180017598; // weak
__int64 qword_1800175B0; // weak
__int64 qword_1800175B8; // weak
int dword_1800175C0; // weak
__int64 qword_1800175C8; // weak
__int64 qword_1800175D0; // weak
__int64 qword_1800175D8; // weak
__int64 qword_1800175F0; // weak
__int64 qword_1800175F8; // weak
__int64 qword_180017600; // weak
__int64 qword_180017608; // weak
LPCVOID lpBaseAddress; // idb
void *qword_180017618; // idb
void *Block; // idb
__int64 qword_180017628; // weak
__int64 qword_180017630; // weak
__int64 (__fastcall *qword_180017638)(_QWORD, _QWORD, _QWORD); // weak
__int64 qword_180017640; // weak
__int64 qword_180017648; // weak
__int64 qword_180017650; // weak
__int64 qword_180017658; // weak
__int64 qword_180017660; // weak
__int64 (__fastcall *qword_180017668)(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 qword_180017670; // weak
HMODULE hLibModule; // idb
BOOL (__stdcall *GetFileVersionInfoExW_0)(DWORD dwFlags, LPCWSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
__int64 qword_180017688; // weak
__int64 qword_180017690; // weak
DWORD (__stdcall *VerFindFileA_0)(DWORD uFlags, LPCSTR szFileName, LPCSTR szWinDir, LPCSTR szAppDir, LPSTR szCurDir, PUINT puCurDirLen, LPSTR szDestDir, PUINT puDestDirLen);
DWORD (__stdcall *VerInstallFileW_0)(DWORD uFlags, LPCWSTR szSrcFileName, LPCWSTR szDestFileName, LPCWSTR szSrcDir, LPCWSTR szDestDir, LPCWSTR szCurDir, LPWSTR szTmpFile, PUINT puTmpFileLen);
__int64 qword_1800176A8; // weak
DWORD (__stdcall *VerFindFileW_0)(DWORD uFlags, LPCWSTR szFileName, LPCWSTR szWinDir, LPCWSTR szAppDir, LPWSTR szCurDir, PUINT puCurDirLen, LPWSTR szDestDir, PUINT puDestDirLen);
__int64 qword_1800176B8; // weak
DWORD (__stdcall *VerInstallFileA_0)(DWORD uFlags, LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir, LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, PUINT puTmpFileLen);
__int64 qword_1800176C8; // weak
__int64 qword_1800176D0; // weak
__int64 qword_1800176D8; // weak
__int64 qword_1800176E0; // weak
__int64 qword_1800176E8; // weak
__int64 qword_1800176F0; // weak
BOOL (__stdcall *GetFileVersionInfoExA_0)(DWORD dwFlags, LPCSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
__int64 qword_180017700; // weak
_UNKNOWN unk_180017708; // weak
_UNKNOWN unk_180019020; // weak
int dword_18001906C = 0; // weak
_UNKNOWN unk_18001A010; // weak
_UNKNOWN unk_18001A020; // weak
_UNKNOWN unk_18001A030; // weak
_UNKNOWN unk_18001A040; // weak
_UNKNOWN unk_18001A050; // weak
_UNKNOWN unk_18001A060; // weak
_UNKNOWN unk_18001A070; // weak
_UNKNOWN unk_18001A080; // weak
_BYTE byte_18001A090[256] =
{
  0,
  0,
  0,
  0,
  17,
  36,
  0,
  0,
  0,
  0,
  0,
  0,
  17,
  36,
  0,
  0,
  0,
  0,
  0,
  0,
  17,
  36,
  0,
  0,
  0,
  0,
  0,
  0,
  17,
  36,
  0,
  0,
  0,
  0,
  0,
  0,
  17,
  36,
  0,
  0,
  0,
  0,
  0,
  0,
  17,
  36,
  0,
  0,
  0,
  0,
  0,
  0,
  17,
  36,
  0,
  0,
  0,
  0,
  0,
  0,
  17,
  36,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  1,
  1,
  1,
  4,
  4,
  4,
  4,
  5,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  4,
  4,
  4,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_UNKNOWN unk_18001A190; // weak
_UNKNOWN unk_18001B190; // weak
_UNKNOWN unk_18001C190; // weak
_UNKNOWN unk_18001C1A0; // weak
_UNKNOWN unk_18001C1B0; // weak
_UNKNOWN unk_18001C1C0; // weak
_UNKNOWN unk_18001C1D0; // weak


//----- (0000000180001000) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
// Hidden C++ exception states: #wind=6
int __fastcall sub_180001000(double _XMM0_8, double _XMM1_8)
{
  char **v5; // rdi
  unsigned __int64 *v6; // rbx
  _OWORD v11[2]; // [rsp+38h] [rbp-30h] BYREF
  char v12; // [rsp+58h] [rbp-10h] BYREF

  sub_180002B40(&pszAddrString, "127.0.0.1", 9u);
  word_1800174D0 = 9000;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups [rsp+68h+var_30], xmm0
    vpxor   xmm1, xmm1, xmm1
    vmovdqu [rsp+68h+var_20], xmm1
  }
  sub_180002B40(v11, "language_server", 0xFu);
  qword_1800174D8 = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu cs:xmmword_1800174E0, xmm0
  }
  sub_1800031B0((unsigned __int64 *)&qword_1800174D8, 1u);
  v5 = (char **)qword_1800174D8;
  v6 = (unsigned __int64 *)v11;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups [rsp+68h+var_48], xmm0
  }
  do
  {
    sub_180002860(v5, v6);
    v5 += 4;
    v6 += 4;
  }
  while ( v6 != (unsigned __int64 *)&v12 );
  sub_180002980(v5, v5);
  *(_QWORD *)&xmmword_1800174E0 = v5;
  sub_18000E83C((__int64)v11, 32, 1);
  byte_1800174F0 = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups cs:xmmword_1800174F8, xmm0
  }
  qword_180017508 = 0;
  qword_180017510 = 0;
  sub_180002B40(&xmmword_1800174F8, "1.1.1.1", 7u);
  return atexit(sub_18000FF70);
}
// 180001000: inconsistent variable size for 'xmm0_8.8'
// 180001000: inconsistent variable size for 'xmm1_8.8'
// 1800174D0: using guessed type __int16 word_1800174D0;
// 1800174D8: using guessed type __int64 qword_1800174D8;
// 1800174E0: using guessed type __int128 xmmword_1800174E0;
// 1800174F0: using guessed type char byte_1800174F0;
// 180017508: using guessed type __int64 qword_180017508;
// 180017510: using guessed type __int64 qword_180017510;

//----- (0000000180001180) ----------------------------------------------------
int sub_180001180()
{
  _QWORD *v0; // rax

  v0 = sub_18000E800(0x20u);
  *v0 = v0;
  v0[1] = v0;
  v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
  qword_180017518 = v0;
  return atexit(sub_180010050);
}

//----- (00000001800011C0) ----------------------------------------------------
int sub_1800011C0()
{
  _QWORD *v0; // rax

  v0 = sub_18000E800(0x60u);
  *v0 = v0;
  v0[1] = v0;
  v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
  qword_180017528 = (__int64)v0;
  return atexit(sub_1800100C0);
}
// 180017528: using guessed type __int64 qword_180017528;

//----- (0000000180001200) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
// Hidden C++ exception states: #wind=2
int __fastcall sub_180001200(double _XMM0_8)
{
  _QWORD *v1; // rax

  v1 = sub_18000E800(0x38u);
  *v1 = v1;
  v1[1] = v1;
  qword_180017588 = (__int64)v1;
  qword_180017598 = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu cs:xmmword_1800175A0, xmm0
  }
  qword_1800175B0 = 7;
  qword_1800175B8 = 8;
  __asm
  {
    vmovss  xmm0, cs:dword_180014108
    vmovss  cs:dword_180017580, xmm0
  }
  sub_180008470((__int64)&qword_180017598, 0x10u, (unsigned __int64)v1);
  return atexit(sub_1800100D0);
}
// 180001200: inconsistent variable size for 'xmm0_8.8'
// 180017580: using guessed type int dword_180017580;
// 180017588: using guessed type __int64 qword_180017588;
// 180017598: using guessed type __int64 qword_180017598;
// 1800175B0: using guessed type __int64 qword_1800175B0;
// 1800175B8: using guessed type __int64 qword_1800175B8;

//----- (0000000180001280) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
// Hidden C++ exception states: #wind=2
int __fastcall sub_180001280(double _XMM0_8)
{
  _QWORD *v1; // rax

  v1 = sub_18000E800(0x38u);
  *v1 = v1;
  v1[1] = v1;
  qword_1800175C8 = (__int64)v1;
  qword_1800175D8 = 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu cs:xmmword_1800175E0, xmm0
  }
  qword_1800175F0 = 7;
  qword_1800175F8 = 8;
  __asm
  {
    vmovss  xmm0, cs:dword_180014108
    vmovss  cs:dword_1800175C0, xmm0
  }
  sub_180008470((__int64)&qword_1800175D8, 0x10u, (unsigned __int64)v1);
  return atexit(sub_1800100E0);
}
// 180001280: inconsistent variable size for 'xmm0_8.8'
// 1800175C0: using guessed type int dword_1800175C0;
// 1800175C8: using guessed type __int64 qword_1800175C8;
// 1800175D8: using guessed type __int64 qword_1800175D8;
// 1800175F0: using guessed type __int64 qword_1800175F0;
// 1800175F8: using guessed type __int64 qword_1800175F8;

//----- (0000000180001300) ----------------------------------------------------
int sub_180001300()
{
  return atexit((void (__cdecl *)())sub_1800100F0);
}

//----- (0000000180001310) ----------------------------------------------------
int sub_180001310()
{
  _QWORD *v0; // rax

  v0 = sub_18000E800(0x40u);
  *v0 = v0;
  v0[1] = v0;
  v0[2] = v0;
  *((_WORD *)v0 + 12) = 257;
  qword_180017550 = v0;
  return atexit(sub_180010160);
}

//----- (0000000180001350) ----------------------------------------------------
wchar_t *__fastcall sub_180001350(__int64 a1, unsigned __int16 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rax
  unsigned __int64 v19; // rcx
  unsigned __int64 v21; // rdx

  v3 = 0;
  _R9 = L"\\/";
  if ( !dword_180017478 || a3 < 0x10 )
  {
LABEL_6:
    if ( v3 + 4 <= a3 )
    {
      _ECX = (__int16)a2;
      __asm { vmovd   xmm2, ecx }
      __asm
      {
        vpunpcklwd xmm2, xmm2, xmm2
        vpshufd xmm2, xmm2, 0
      }
      if ( v3 + 8 <= a3 )
      {
        while ( 1 )
        {
          __asm
          {
            vpcmpeqw xmm1, xmm2, xmmword ptr [r9]
            vpmovmskb ecx, xmm1
          }
          if ( (_WORD)_RCX )
            break;
          v3 += 8LL;
          _R9 += 8;
          if ( v3 + 8 > a3 )
            goto LABEL_10;
        }
        _BitScanForward((unsigned int *)&_RCX, (unsigned __int16)_RCX);
        __asm { vzeroupper }
        return &asc_180013C98[v3 + (_RCX >> 1)];
      }
LABEL_10:
      if ( v3 + 4 <= a3 )
      {
        __asm
        {
          vmovq   xmm0, qword ptr [r9]
          vpcmpeqw xmm1, xmm0, xmm2
          vpmovmskb r9d, xmm1
        }
        if ( (_BYTE)_R9D )
        {
          _BitScanForward((unsigned int *)&v19, (unsigned __int8)_R9D);
          __asm { vzeroupper }
          return &asc_180013C98[v3 + (v19 >> 1)];
        }
        v3 += 4LL;
      }
    }
    if ( v3 >= a3 )
    {
LABEL_19:
      __asm { vzeroupper }
      return 0;
    }
    else
    {
      while ( asc_180013C98[v3] != a2 )
      {
        if ( ++v3 >= a3 )
          goto LABEL_19;
      }
      __asm { vzeroupper }
      return &asc_180013C98[v3];
    }
  }
  _ECX = a2;
  __asm
  {
    vmovd   xmm0, ecx
    vpbroadcastw ymm2, xmm0
  }
  while ( 1 )
  {
    __asm
    {
      vpcmpeqw ymm1, ymm2, ymmword ptr [r9]
      vpmovmskb ecx, ymm1
    }
    if ( _ECX )
      break;
    v3 += 16LL;
    _R9 += 16;
    if ( v3 + 16 > a3 )
      goto LABEL_6;
  }
  _BitScanForward((unsigned int *)&v21, _ECX);
  __asm { vzeroupper }
  return &asc_180013C98[v3 + (v21 >> 1)];
}
// 180001425: variable 'v19' is possibly undefined
// 180001447: variable 'v21' is possibly undefined
// 18000146C: variable '_RCX' is possibly undefined
// 180013C98: using guessed type wchar_t asc_180013C98[3];
// 180017478: using guessed type int dword_180017478;

//----- (00000001800014E0) ----------------------------------------------------
_QWORD *__fastcall sub_1800014E0(_QWORD *a1, __int64 a2)
{
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *a1 = &std::exception::`vftable';
  _RDX = a1 + 1;
  __asm { vmovups xmmword ptr [rdx], xmm0 }
  _std_exception_copy(a2 + 8);
  return a1;
}
// 180011208: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 180013BE0: using guessed type void *std::exception::`vftable';

//----- (0000000180001520) ----------------------------------------------------
const char *__fastcall sub_180001520(__int64 a1)
{
  const char *result; // rax

  result = "Unknown exception";
  if ( *(_QWORD *)(a1 + 8) )
    return *(const char **)(a1 + 8);
  return result;
}

//----- (0000000180001540) ----------------------------------------------------
char *__fastcall sub_180001540(char *Block, char a2)
{
  *(_QWORD *)Block = &std::exception::`vftable';
  _std_exception_destroy(Block + 8);
  if ( (a2 & 1) != 0 )
    j_j_free(Block);
  return Block;
}
// 180011200: using guessed type __int64 __fastcall _std_exception_destroy(_QWORD);
// 180013BE0: using guessed type void *std::exception::`vftable';

//----- (0000000180001590) ----------------------------------------------------
__int64 __fastcall sub_180001590(_QWORD *a1)
{
  *a1 = &std::exception::`vftable';
  return _std_exception_destroy(a1 + 1);
}
// 180011200: using guessed type __int64 __fastcall _std_exception_destroy(_QWORD);
// 180013BE0: using guessed type void *std::exception::`vftable';

//----- (00000001800015B0) ----------------------------------------------------
_QWORD *__fastcall sub_1800015B0(_QWORD *a1)
{
  a1[2] = 0;
  a1[1] = "bad array new length";
  *a1 = &std::bad_array_new_length::`vftable';
  return a1;
}
// 180013C20: using guessed type void *std::bad_array_new_length::`vftable';

//----- (0000000180001600) ----------------------------------------------------
_QWORD *__fastcall sub_180001600(_QWORD *a1, __int64 a2)
{
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *a1 = &std::exception::`vftable';
  _RDX = a1 + 1;
  __asm { vmovups xmmword ptr [rdx], xmm0 }
  _std_exception_copy(a2 + 8);
  *a1 = &std::bad_array_new_length::`vftable';
  return a1;
}
// 180011208: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 180013BE0: using guessed type void *std::exception::`vftable';
// 180013C20: using guessed type void *std::bad_array_new_length::`vftable';

//----- (0000000180001640) ----------------------------------------------------
_QWORD *__fastcall sub_180001640(_QWORD *a1, __int64 a2)
{
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *a1 = &std::exception::`vftable';
  _RDX = a1 + 1;
  __asm { vmovups xmmword ptr [rdx], xmm0 }
  _std_exception_copy(a2 + 8);
  *a1 = &std::bad_alloc::`vftable';
  return a1;
}
// 180011208: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 180013BE0: using guessed type void *std::exception::`vftable';
// 180013BF8: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000180001680) ----------------------------------------------------
void __noreturn sub_180001680()
{
  std::_Xlength_error("string too long");
}
// 180011140: using guessed type void __noreturn std::_Xlength_error(const char *);

//----- (00000001800016A0) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
// Hidden C++ exception states: #wind=3
void __fastcall sub_1800016A0(HMODULE a1, __int64 a2, double _XMM2_8)
{
  size_t v5; // rax
  const wchar_t *v6; // r8
  __int64 v7; // r9
  __m256 *p_Src; // rbx
  __int64 v12; // rdi
  __int64 v13; // r11
  char *i; // r11
  __int64 v15; // rax
  __int64 v16; // rcx
  unsigned __int64 v18; // r8
  __m256 *v19; // rdx
  void *v20; // rcx
  __m256 *v23; // rbx
  __m256 *v24; // rdx
  char v25; // r14
  size_t v26; // rax
  unsigned __int64 v27; // rax
  void **v28; // rcx
  void **v29; // r8
  unsigned __int64 v30; // rdx
  void **v31; // rcx
  void **v32; // rcx
  unsigned __int64 v33; // rax
  void **v34; // rcx
  void **v35; // rdi
  const __m128i *v36; // rbx
  const __m128i *v37; // rax
  void **v38; // rdx
  CHAR *v39; // rcx
  void **v40; // rdi
  const __m128i *v41; // rbx
  const __m128i *v42; // rax
  void **v43; // rdx
  __m256 *v44; // rcx
  void **v45; // rdi
  const __m128i *v46; // rbx
  const __m128i *v47; // rax
  void **v48; // rdx
  __m256 *v49; // rcx
  __m256 *v50; // rbx
  unsigned __int64 v51; // rdi
  __int64 v52; // rsi
  __m256 *v53; // rcx
  __m256 *v54; // rcx
  void **v55; // rdi
  const __m128i *v56; // rbx
  const __m128i *v57; // rax
  void **v58; // rdx
  void *v59; // rcx
  void **v60; // rdi
  const __m128i *v61; // rbx
  const __m128i *v62; // rax
  void **v63; // rdx
  void *v64; // rcx
  FILE *Stream; // [rsp+38h] [rbp-C8h] BYREF
  void *Block[2]; // [rsp+40h] [rbp-C0h] BYREF
  unsigned __int64 v67; // [rsp+50h] [rbp-B0h]
  unsigned __int64 v68; // [rsp+58h] [rbp-A8h]
  __m256 v69; // [rsp+60h] [rbp-A0h] BYREF
  __m256 Src; // [rsp+80h] [rbp-80h] BYREF
  char Buffer[256]; // [rsp+A0h] [rbp-60h] BYREF
  WCHAR Filename[264]; // [rsp+1A0h] [rbp+A0h] BYREF

  if ( !GetModuleFileNameW(a1, Filename, 0x104u) )
    return;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups xmmword ptr [rbp+300h+Src], xmm0
  }
  *(_OWORD *)&Src.m256_f32[4] = 0u;
  v5 = wcslen(Filename);
  sub_180002A10(&Src, Filename, v5);
  _R14 = *(_QWORD *)&Src.m256_f32[6];
  p_Src = &Src;
  _R15 = *(__m256 **)Src.m256_f32;
  if ( *(_QWORD *)&Src.m256_f32[6] > 7u )
    p_Src = *(__m256 **)Src.m256_f32;
  _RSI = *(_QWORD *)&Src.m256_f32[4];
  if ( !*(_QWORD *)&Src.m256_f32[4] )
    goto LABEL_21;
  v12 = *(_QWORD *)&Src.m256_f32[4] - 1LL;
  if ( (unsigned __int64)(*(_QWORD *)&Src.m256_f32[4] - 1LL + 3) < 0x10 )
  {
    memset(Buffer, 0, sizeof(Buffer));
    v6 = L"\\/";
    while ( *v6 < 0x100u )
    {
      Buffer[(unsigned __int8)*v6++] = 1;
      if ( v6 == L"" )
      {
        for ( i = (char *)p_Src + 2 * v12; ; i -= 2 )
        {
          v15 = *(unsigned __int16 *)i;
          if ( (unsigned __int16)v15 < 0x100u )
          {
            if ( Buffer[v15] )
              break;
          }
          if ( i == (char *)p_Src )
            goto LABEL_21;
        }
        goto LABEL_19;
      }
    }
    if ( sub_180001350((__int64)L"", *((_WORD *)p_Src->m256_f32 + v12), 2u) )
    {
LABEL_18:
      _R14 = *(_QWORD *)&Src.m256_f32[6];
      _RSI = *(_QWORD *)&Src.m256_f32[4];
      _R15 = *(__m256 **)Src.m256_f32;
LABEL_19:
      v13 = (i - (char *)p_Src) >> 1;
      goto LABEL_22;
    }
    while ( i != (char *)p_Src )
    {
      if ( sub_180001350(v16, *((_WORD *)i - 1), 2u) )
        goto LABEL_18;
    }
    _R14 = *(_QWORD *)&Src.m256_f32[6];
    _RSI = *(_QWORD *)&Src.m256_f32[4];
    _R15 = *(__m256 **)Src.m256_f32;
LABEL_21:
    v13 = -1;
    goto LABEL_22;
  }
  v13 = sub_18000E7A0(p_Src);
  _R14 = *(_QWORD *)&Src.m256_f32[6];
  _RSI = *(_QWORD *)&Src.m256_f32[4];
  _R15 = *(__m256 **)Src.m256_f32;
LABEL_22:
  if ( v13 != -1 )
  {
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovups xmmword ptr [rsp+400h+var_3A0], xmm0
    }
    *(_OWORD *)&v69.m256_f32[4] = 0u;
    v18 = v13 + 1;
    if ( _RSI < v13 + 1 )
      v18 = _RSI;
    v19 = &Src;
    if ( _R14 > 7 )
      v19 = _R15;
    sub_180002A10(&v69, v19, v18);
    if ( *(_QWORD *)&Src.m256_f32[6] > 7u )
    {
      if ( (unsigned __int64)(2LL * *(_QWORD *)&Src.m256_f32[6] + 2) < 0x1000 )
      {
        v20 = *(void **)Src.m256_f32;
      }
      else
      {
        v20 = *(void **)(*(_QWORD *)Src.m256_f32 - 8LL);
        if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - (_QWORD)v20 - 8LL) > 0x1F )
LABEL_158:
          __fastfail(5u);
      }
      j_j_free(v20);
    }
    __asm
    {
      vmovups ymm2, [rsp+400h+var_3A0]
      vmovups [rbp+300h+Src], ymm2
      vextractf128 xmm0, ymm2, 1
      vpextrq r14, xmm0, 1
      vextractf128 xmm1, ymm2, 1
      vmovq   rsi, xmm1
      vmovq   r15, xmm2
    }
  }
  if ( _R14 - _RSI < 0x10 )
  {
    __asm { vzeroupper }
    sub_180002F60((void **)&Src, 0x10u, (__int64)v6, v7, 16);
  }
  else
  {
    *(_QWORD *)&Src.m256_f32[4] = _RSI + 16;
    v23 = &Src;
    if ( _R14 > 7 )
      v23 = _R15;
    __asm { vzeroupper }
    memmove((char *)v23 + 2 * _RSI, L"proxy_config.txt", 0x20u);
    *((_WORD *)v23[1].m256_f32 + _RSI) = 0;
  }
  Stream = 0;
  v24 = &Src;
  if ( *(_QWORD *)&Src.m256_f32[6] > 7u )
    v24 = *(__m256 **)Src.m256_f32;
  if ( !wfopen_s(&Stream, (const wchar_t *)v24, L"r") && Stream )
  {
    v25 = 1;
    while ( fgets(Buffer, 256, Stream) )
    {
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vmovups xmmword ptr [rsp+400h+Block], xmm0
      }
      v67 = 0;
      v68 = 0;
      v26 = strlen(Buffer);
      sub_180002B40(Block, Buffer, v26);
      v27 = v67;
      if ( v67 )
      {
        while ( 1 )
        {
          v28 = Block;
          v29 = (void **)Block[0];
          v30 = v68;
          if ( v68 > 0xF )
            v28 = (void **)Block[0];
          if ( *((_BYTE *)v28 + v27 - 1) != 13 )
          {
            v31 = Block;
            if ( v68 > 0xF )
              v31 = (void **)Block[0];
            if ( *((_BYTE *)v31 + v27 - 1) != 10 )
            {
              v32 = Block;
              if ( v68 > 0xF )
                v32 = (void **)Block[0];
              if ( *((_BYTE *)v32 + v27 - 1) != 32 )
                break;
            }
          }
          v33 = v27 - 1;
          v67 = v33;
          v34 = Block;
          if ( v68 > 0xF )
            v34 = (void **)Block[0];
          *((_BYTE *)v34 + v33) = 0;
          v27 = v67;
          if ( !v67 )
            goto LABEL_57;
        }
      }
      else
      {
LABEL_57:
        v30 = v68;
        v29 = (void **)Block[0];
      }
      v35 = Block;
      if ( v30 > 0xF )
        v35 = v29;
      if ( v27 >= 0xA )
      {
        v36 = (const __m128i *)((char *)v35 + v27);
        v37 = sub_18000E7B0(
                (const __m128i *)v35,
                (const __m128i *)((char *)v35 + v27),
                (const __m128i *)"ProxyHost=",
                0xAu);
        if ( v37 != v36 && v37 == (const __m128i *)v35 )
        {
          __asm
          {
            vpxor   xmm0, xmm0, xmm0
            vmovups xmmword ptr [rsp+400h+var_3A0], xmm0
          }
          *(_OWORD *)&v69.m256_f32[4] = 0u;
          if ( v67 < 0xA )
            goto LABEL_163;
          v38 = Block;
          if ( v68 > 0xF )
            v38 = (void **)Block[0];
          sub_180002B40(&v69, (char *)v38 + 10, v67 - 10);
          if ( (unsigned __int64)*(&ymmword_1800174B0 + 3) > 0xF )
          {
            v39 = (CHAR *)ymmword_1800174B0;
            if ( (unsigned __int64)(*(&ymmword_1800174B0 + 3) + 1) >= 0x1000 )
            {
              if ( (unsigned __int64)&ymmword_1800174B0[-*((_QWORD *)ymmword_1800174B0 - 1) - 8] > 0x1F )
                goto LABEL_157;
              v39 = (CHAR *)*((_QWORD *)ymmword_1800174B0 - 1);
            }
            j_j_free(v39);
          }
          *(__m256 *)&ymmword_1800174B0 = v69;
          goto LABEL_145;
        }
        v30 = v68;
        v27 = v67;
        v29 = (void **)Block[0];
      }
      v40 = Block;
      if ( v30 > 0xF )
        v40 = v29;
      if ( v27 >= 0xA )
      {
        v41 = (const __m128i *)((char *)v40 + v27);
        v42 = sub_18000E7B0(
                (const __m128i *)v40,
                (const __m128i *)((char *)v40 + v27),
                (const __m128i *)"ProxyPort=",
                0xAu);
        if ( v42 != v41 && v42 == (const __m128i *)v40 )
        {
          __asm
          {
            vpxor   xmm0, xmm0, xmm0
            vmovups xmmword ptr [rsp+400h+var_3A0], xmm0
          }
          *(_OWORD *)&v69.m256_f32[4] = 0u;
          if ( v67 < 0xA )
            sub_180003240();
          v43 = Block;
          if ( v68 > 0xF )
            v43 = (void **)Block[0];
          sub_180002B40(&v69, (char *)v43 + 10, v67 - 10);
          v44 = &v69;
          if ( *(_QWORD *)&v69.m256_f32[6] > 0xFu )
            v44 = *(__m256 **)v69.m256_f32;
          word_1800174D0 = atoi((const char *)v44);
          goto LABEL_140;
        }
        v30 = v68;
        v27 = v67;
        v29 = (void **)Block[0];
      }
      v45 = Block;
      if ( v30 > 0xF )
        v45 = v29;
      if ( v27 >= 0xA )
      {
        v46 = (const __m128i *)((char *)v45 + v27);
        v47 = sub_18000E7B0(
                (const __m128i *)v45,
                (const __m128i *)((char *)v45 + v27),
                (const __m128i *)"UseFakeIp=",
                0xAu);
        if ( v47 != v46 && v47 == (const __m128i *)v45 )
        {
          __asm
          {
            vpxor   xmm0, xmm0, xmm0
            vmovups xmmword ptr [rsp+400h+var_3A0], xmm0
          }
          *(_OWORD *)&v69.m256_f32[4] = 0u;
          if ( v67 < 0xA )
            goto LABEL_163;
          v48 = Block;
          if ( v68 > 0xF )
            v48 = (void **)Block[0];
          sub_180002B40(&v69, (char *)v48 + 10, v67 - 10);
          v49 = &v69;
          v50 = *(__m256 **)v69.m256_f32;
          v51 = *(_QWORD *)&v69.m256_f32[6];
          if ( *(_QWORD *)&v69.m256_f32[6] > 0xFu )
            v49 = *(__m256 **)v69.m256_f32;
          v52 = *(_QWORD *)&v69.m256_f32[4];
          if ( *(_QWORD *)&v69.m256_f32[4] == 4 && !memcmp(v49, "true", 4u) )
            goto LABEL_101;
          v53 = &v69;
          if ( v51 > 0xF )
            v53 = v50;
          if ( v52 == 1 && !memcmp(v53, "1", 1u) )
LABEL_101:
            byte_1800174F0 = 1;
          else
            byte_1800174F0 = 0;
          if ( v51 <= 0xF )
            goto LABEL_145;
          if ( v51 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)v50 - *(_QWORD *)&v50[-1].m256_f32[6] - 8 > 0x1F )
              goto LABEL_157;
            v50 = *(__m256 **)&v50[-1].m256_f32[6];
          }
          v54 = v50;
          goto LABEL_144;
        }
        v30 = v68;
        v27 = v67;
        v29 = (void **)Block[0];
      }
      v55 = Block;
      if ( v30 > 0xF )
        v55 = v29;
      if ( v27 >= 0xA )
      {
        v56 = (const __m128i *)((char *)v55 + v27);
        v57 = sub_18000E7B0(
                (const __m128i *)v55,
                (const __m128i *)((char *)v55 + v27),
                (const __m128i *)"DnsServer=",
                0xAu);
        if ( v57 != v56 && v57 == (const __m128i *)v55 )
        {
          __asm
          {
            vpxor   xmm0, xmm0, xmm0
            vmovups xmmword ptr [rsp+400h+var_3A0], xmm0
          }
          *(_OWORD *)&v69.m256_f32[4] = 0u;
          if ( v67 < 0xA )
            goto LABEL_163;
          v58 = Block;
          if ( v68 > 0xF )
            v58 = (void **)Block[0];
          sub_180002B40(&v69, (char *)v58 + 10, v67 - 10);
          if ( (unsigned __int64)*(&ymmword_1800174F8 + 3) > 0xF )
          {
            v59 = ymmword_1800174F8;
            if ( (unsigned __int64)*(&ymmword_1800174F8 + 3) + 1 >= 0x1000 )
            {
              if ( (unsigned __int64)ymmword_1800174F8 - *((_QWORD *)ymmword_1800174F8 - 1) - 8 > 0x1F )
                goto LABEL_157;
              v59 = (void *)*((_QWORD *)ymmword_1800174F8 - 1);
            }
            j_j_free(v59);
          }
          *(__m256 *)&ymmword_1800174F8 = v69;
          goto LABEL_145;
        }
        v30 = v68;
        v27 = v67;
        v29 = (void **)Block[0];
      }
      v60 = Block;
      if ( v30 > 0xF )
        v60 = v29;
      if ( v27 < 0xE )
        goto LABEL_146;
      v61 = (const __m128i *)((char *)v60 + v27);
      v62 = sub_18000E7B0(
              (const __m128i *)v60,
              (const __m128i *)((char *)v60 + v27),
              (const __m128i *)"TargetProcess=",
              0xEu);
      if ( v62 != v61 && v62 == (const __m128i *)v60 )
      {
        if ( v25 )
        {
          if ( qword_1800174D8 != (_QWORD)xmmword_1800174E0 )
          {
            sub_180002980((char **)qword_1800174D8, (char **)xmmword_1800174E0);
            *(_QWORD *)&xmmword_1800174E0 = qword_1800174D8;
          }
          v25 = 0;
        }
        __asm
        {
          vpxor   xmm0, xmm0, xmm0
          vmovups xmmword ptr [rsp+400h+var_3A0], xmm0
        }
        *(_OWORD *)&v69.m256_f32[4] = 0u;
        if ( v67 < 0xE )
LABEL_163:
          sub_180003240();
        v63 = Block;
        if ( v68 > 0xF )
          v63 = (void **)Block[0];
        sub_180002B40(&v69, (char *)v63 + 14, v67 - 14);
        if ( *(_QWORD *)&v69.m256_f32[4] )
        {
          if ( (_QWORD)xmmword_1800174E0 == *((_QWORD *)&xmmword_1800174E0 + 1) )
          {
            sub_180002CB0((__int64)&qword_1800174D8, xmmword_1800174E0, (unsigned __int64 *)&v69);
          }
          else
          {
            sub_180002860((_QWORD *)xmmword_1800174E0, (unsigned __int64 *)&v69);
            *(_QWORD *)&xmmword_1800174E0 = xmmword_1800174E0 + 32;
          }
        }
LABEL_140:
        if ( *(_QWORD *)&v69.m256_f32[6] > 0xFu )
        {
          v54 = *(__m256 **)v69.m256_f32;
          if ( (unsigned __int64)(*(_QWORD *)&v69.m256_f32[6] + 1LL) >= 0x1000 )
          {
            if ( (unsigned __int64)(*(_QWORD *)v69.m256_f32 - *(_QWORD *)(*(_QWORD *)v69.m256_f32 - 8LL) - 8LL) > 0x1F )
LABEL_157:
              __fastfail(5u);
            v54 = *(__m256 **)(*(_QWORD *)v69.m256_f32 - 8LL);
          }
LABEL_144:
          j_j_free(v54);
        }
      }
LABEL_145:
      v29 = (void **)Block[0];
      v30 = v68;
LABEL_146:
      if ( v30 > 0xF )
      {
        if ( v30 + 1 >= 0x1000 )
        {
          if ( (unsigned __int64)((char *)v29 - (_BYTE *)*(v29 - 1) - 8) > 0x1F )
            goto LABEL_158;
          v29 = (void **)*(v29 - 1);
        }
        j_j_free(v29);
      }
    }
    fclose(Stream);
  }
  if ( *(_QWORD *)&Src.m256_f32[6] > 7u )
  {
    if ( (unsigned __int64)(2LL * *(_QWORD *)&Src.m256_f32[6] + 2) < 0x1000 )
    {
      v64 = *(void **)Src.m256_f32;
    }
    else
    {
      v64 = *(void **)(*(_QWORD *)Src.m256_f32 - 8LL);
      if ( (unsigned __int64)(*(_QWORD *)Src.m256_f32 - (_QWORD)v64 - 8LL) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v64);
  }
}
// 180001AC9: conditional instruction was optimized away because %var_3B0.8>=Au
// 180001BDF: conditional instruction was optimized away because %var_3B0.8>=Au
// 180001CAA: conditional instruction was optimized away because %var_3B0.8>=Au
// 180001DF8: conditional instruction was optimized away because %var_3B0.8>=Au
// 180001F44: conditional instruction was optimized away because %var_3B0.8>=Eu
// 1800016A0: inconsistent variable size for 'xmm2_8.8'
// 180013C98: using guessed type wchar_t asc_180013C98[3];
// 180013CA0: using guessed type wchar_t aProxyConfigTxt[17];
// 1800174D0: using guessed type __int16 word_1800174D0;
// 1800174D8: using guessed type __int64 qword_1800174D8;
// 1800174E0: using guessed type __int128 xmmword_1800174E0;
// 1800174F0: using guessed type char byte_1800174F0;

//----- (00000001800020D0) ----------------------------------------------------
// Hidden C++ exception states: #wind=3
char __fastcall sub_1800020D0(const wchar_t *a1)
{
  size_t v5; // rax
  __int128 *v6; // rcx
  __int128 *v7; // rsi
  __int128 *v8; // rdi
  size_t v10; // r8
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rbx
  unsigned __int64 v13; // rax
  size_t v14; // rax
  void *v15; // rax
  void *v16; // rcx
  size_t v17; // rcx
  __int128 *v18; // r8
  __int128 *v19; // rcx
  unsigned __int64 i; // rdx
  __int128 *v21; // rsi
  __int128 *v22; // rbx
  char *v23; // rbx
  char *v24; // rdi
  unsigned __int64 *v25; // r14
  unsigned __int64 *v26; // r12
  _BYTE *v27; // rsi
  __m128i *v28; // rcx
  unsigned __int64 v29; // rdx
  _QWORD *v30; // rbx
  size_t v31; // r9
  char *v32; // rbx
  char *v33; // rdi
  const __m128i *v34; // r8
  const __m128i *v35; // rdi
  const __m128i *v36; // rbx
  const __m128i *v37; // rax
  char v38; // bl
  void *v39; // rcx
  void *v40; // rcx
  __int128 v41; // [rsp+20h] [rbp-59h] BYREF
  size_t v42; // [rsp+30h] [rbp-49h]
  unsigned __int64 v43; // [rsp+38h] [rbp-41h]
  _QWORD v44[2]; // [rsp+40h] [rbp-39h] BYREF
  size_t v45; // [rsp+50h] [rbp-29h]
  unsigned __int64 v46; // [rsp+58h] [rbp-21h]
  __int128 v47; // [rsp+60h] [rbp-19h] BYREF
  __int64 v48; // [rsp+70h] [rbp-9h]
  unsigned __int64 v49; // [rsp+78h] [rbp-1h]

  if ( !a1 )
    return 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups [rbp+57h+var_70], xmm0
  }
  v48 = 0;
  v49 = 0;
  v5 = wcslen(a1);
  sub_180002A10(&v47, a1, v5);
  v6 = &v47;
  if ( v49 > 7 )
    v6 = (__int128 *)v47;
  v7 = (__int128 *)((char *)v6 + 2 * v48);
  v8 = &v47;
  if ( v49 > 7 )
    v8 = (__int128 *)v47;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups [rbp+57h+var_B0], xmm0
  }
  v42 = 0;
  if ( v8 == v7 )
  {
    v10 = 0;
    v43 = 15;
    LOBYTE(v41) = 0;
    goto LABEL_29;
  }
  v11 = ((char *)v7 - (char *)v8) >> 1;
  v12 = 15;
  v43 = 15;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL )
    sub_180001680();
  v13 = 0;
  if ( v11 > 0xF )
  {
    v12 = v11 | 0xF;
    if ( (v11 | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
    {
      v12 = 0x7FFFFFFFFFFFFFFFLL;
      v14 = 0x8000000000000027uLL;
LABEL_13:
      v15 = sub_18000E800(v14);
      v16 = v15;
      if ( !v15 )
        goto LABEL_82;
      v13 = ((unsigned __int64)v15 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
      *(_QWORD *)(v13 - 8) = v16;
      goto LABEL_23;
    }
    if ( v12 < 0x16 )
      v12 = 22;
    v17 = v12 + 1;
    if ( v12 == -1 )
    {
      v13 = 0;
    }
    else
    {
      if ( v17 >= 0x1000 )
      {
        v14 = v12 + 40;
        if ( v12 + 40 < v12 + 1 )
          Concurrency::cancel_current_task();
        goto LABEL_13;
      }
      v13 = (unsigned __int64)sub_18000E800(v17);
    }
LABEL_23:
    *(_QWORD *)&v41 = v13;
    v43 = v12;
  }
  v18 = &v41;
  if ( v12 > 0xF )
    v18 = (__int128 *)v13;
  v19 = v18;
  for ( i = v11; i; --i )
  {
    *(_BYTE *)v19 = *(_BYTE *)v8;
    v19 = (__int128 *)((char *)v19 + 1);
    v8 = (__int128 *)((char *)v8 + 2);
  }
  v42 = v11;
  *((_BYTE *)v18 + v11) = 0;
  v10 = v42;
LABEL_29:
  v21 = &v41;
  if ( v43 > 0xF )
    v21 = (__int128 *)v41;
  v22 = &v41;
  if ( v43 > 0xF )
    v22 = (__int128 *)v41;
  v23 = (char *)v22 + v10;
  v24 = (char *)&v41;
  if ( v43 > 0xF )
    v24 = (char *)v41;
  for ( ; v24 != v23; ++v24 )
  {
    *(_BYTE *)v21 = ((__int64 (__fastcall *)(_QWORD))tolower)((unsigned int)*v24);
    v21 = (__int128 *)((char *)v21 + 1);
  }
  v25 = (unsigned __int64 *)qword_1800174D8;
  v26 = (unsigned __int64 *)xmmword_1800174E0;
  if ( qword_1800174D8 == (_QWORD)xmmword_1800174E0 )
  {
LABEL_62:
    v38 = 0;
    goto LABEL_63;
  }
  while ( 1 )
  {
    sub_180002860(v44, v25);
    v27 = v44;
    v28 = (__m128i *)v44[0];
    v29 = v46;
    if ( v46 > 0xF )
      v27 = (_BYTE *)v44[0];
    v30 = v44;
    if ( v46 > 0xF )
      v30 = (_QWORD *)v44[0];
    v31 = v45;
    v32 = (char *)v30 + v45;
    v33 = (char *)v44;
    if ( v46 > 0xF )
      v33 = (char *)v44[0];
    if ( v33 != v32 )
    {
      do
        *v27++ = ((__int64 (__fastcall *)(_QWORD))tolower)((unsigned int)*v33++);
      while ( v33 != v32 );
      v29 = v46;
      v31 = v45;
      v28 = (__m128i *)v44[0];
    }
    v34 = (const __m128i *)v44;
    if ( v29 > 0xF )
      v34 = v28;
    v35 = (const __m128i *)&v41;
    if ( v43 > 0xF )
      v35 = (const __m128i *)v41;
    if ( v31 > v42 )
      goto LABEL_56;
    if ( !v31 )
      goto LABEL_75;
    v36 = (const __m128i *)((char *)v35 + v42);
    v37 = sub_18000E7B0(v35, (const __m128i *)((char *)v35 + v42), v34, v31);
    if ( v37 != v36 && (char *)v37 - (char *)v35 != -1 )
      break;
    v29 = v46;
    v28 = (__m128i *)v44[0];
LABEL_56:
    if ( v29 > 0xF )
    {
      if ( v29 + 1 >= 0x1000 )
      {
        if ( (unsigned __int64)v28 - v28[-1].m128i_i64[1] - 8 > 0x1F )
          goto LABEL_81;
        v28 = (__m128i *)v28[-1].m128i_i64[1];
      }
      j_j_free(v28);
    }
    v25 += 4;
    if ( v25 == v26 )
      goto LABEL_62;
  }
  v29 = v46;
  v28 = (__m128i *)v44[0];
LABEL_75:
  if ( v29 > 0xF )
  {
    if ( v29 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)v28 - v28[-1].m128i_i64[1] - 8 > 0x1F )
LABEL_81:
        __fastfail(5u);
      v28 = (__m128i *)v28[-1].m128i_i64[1];
    }
    j_j_free(v28);
  }
  v38 = 1;
LABEL_63:
  if ( v43 <= 0xF )
    goto LABEL_68;
  v39 = (void *)v41;
  if ( v43 + 1 < 0x1000 )
    goto LABEL_67;
  if ( (unsigned __int64)(v41 - *(_QWORD *)(v41 - 8) - 8) > 0x1F )
LABEL_82:
    __fastfail(5u);
  v39 = *(void **)(v41 - 8);
LABEL_67:
  j_j_free(v39);
LABEL_68:
  v42 = 0;
  v43 = 15;
  LOBYTE(v41) = 0;
  if ( v49 > 7 )
  {
    v40 = (void *)v47;
    if ( 2 * v49 + 2 >= 0x1000 )
    {
      if ( (unsigned __int64)(v47 - *(_QWORD *)(v47 - 8) - 8) > 0x1F )
        __fastfail(5u);
      v40 = *(void **)(v47 - 8);
    }
    j_j_free(v40);
  }
  return v38;
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800174D8: using guessed type __int64 qword_1800174D8;
// 1800174E0: using guessed type __int128 xmmword_1800174E0;

//----- (00000001800024E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_1800024E0(const char *a1)
{
  size_t v5; // rax
  void **v6; // rsi
  void **v7; // rdi
  void **v8; // rbx
  unsigned __int64 *v9; // r14
  unsigned __int64 *v10; // r12
  void **v11; // rsi
  void **v12; // rax
  unsigned __int64 v13; // rdx
  void **v14; // rbx
  size_t v15; // r9
  void **v16; // rbx
  void **v17; // rdi
  void **v18; // r8
  void **v19; // rdi
  const __m128i *v20; // rbx
  const __m128i *v21; // rax
  char v22; // bl
  void *v23; // rcx
  _BYTE *v24; // rcx
  void *v25[2]; // [rsp+20h] [rbp-50h] BYREF
  size_t v26; // [rsp+30h] [rbp-40h]
  unsigned __int64 v27; // [rsp+38h] [rbp-38h]
  void *Block[2]; // [rsp+40h] [rbp-30h] BYREF
  size_t v29; // [rsp+50h] [rbp-20h]
  unsigned __int64 v30; // [rsp+58h] [rbp-18h]

  if ( !a1 )
    return 0;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups xmmword ptr [rbp+var_50], xmm0
  }
  v26 = 0;
  v27 = 0;
  v5 = strlen(a1);
  sub_180002B40(v25, a1, v5);
  if ( v27 <= 0xF )
  {
    v6 = v25;
    v8 = (void **)((char *)v25 + v26);
    v7 = v25;
  }
  else
  {
    v6 = (void **)v25[0];
    v7 = (void **)v25[0];
    v8 = (void **)((char *)v25[0] + v26);
  }
  for ( ; v7 != v8; v7 = (void **)((char *)v7 + 1) )
  {
    *(_BYTE *)v6 = ((__int64 (__fastcall *)(_QWORD))tolower)((unsigned int)*(char *)v7);
    v6 = (void **)((char *)v6 + 1);
  }
  v9 = (unsigned __int64 *)qword_1800174D8;
  v10 = (unsigned __int64 *)xmmword_1800174E0;
  if ( qword_1800174D8 == (_QWORD)xmmword_1800174E0 )
  {
LABEL_33:
    v22 = 0;
    goto LABEL_34;
  }
  while ( 1 )
  {
    sub_180002860(Block, v9);
    v11 = Block;
    v12 = (void **)Block[0];
    v13 = v30;
    if ( v30 > 0xF )
      v11 = (void **)Block[0];
    v14 = Block;
    if ( v30 > 0xF )
      v14 = (void **)Block[0];
    v15 = v29;
    v16 = (void **)((char *)v14 + v29);
    v17 = Block;
    if ( v30 > 0xF )
      v17 = (void **)Block[0];
    if ( v17 != v16 )
    {
      do
      {
        *(_BYTE *)v11 = ((__int64 (__fastcall *)(_QWORD))tolower)((unsigned int)*(char *)v17);
        v11 = (void **)((char *)v11 + 1);
        v17 = (void **)((char *)v17 + 1);
      }
      while ( v17 != v16 );
      v13 = v30;
      v15 = v29;
      v12 = (void **)Block[0];
    }
    v18 = Block;
    if ( v13 > 0xF )
      v18 = v12;
    v19 = v25;
    if ( v27 > 0xF )
      v19 = (void **)v25[0];
    if ( v15 > v26 )
      goto LABEL_27;
    if ( !v15 )
      goto LABEL_39;
    v20 = (const __m128i *)((char *)v19 + v26);
    v21 = sub_18000E7B0((const __m128i *)v19, (const __m128i *)((char *)v19 + v26), (const __m128i *)v18, v15);
    if ( v21 != v20 && (char *)v21 - (char *)v19 != -1 )
      break;
    v13 = v30;
    v12 = (void **)Block[0];
LABEL_27:
    if ( v13 > 0xF )
    {
      if ( v13 + 1 >= 0x1000 )
      {
        if ( (unsigned __int64)((char *)v12 - (_BYTE *)*(v12 - 1) - 8) > 0x1F )
          goto LABEL_45;
        v12 = (void **)*(v12 - 1);
      }
      j_j_free(v12);
    }
    v9 += 4;
    if ( v9 == v10 )
      goto LABEL_33;
  }
  v13 = v30;
  v12 = (void **)Block[0];
LABEL_39:
  if ( v13 <= 0xF )
  {
LABEL_44:
    v22 = 1;
    goto LABEL_34;
  }
  if ( v13 + 1 < 0x1000 )
  {
    j_j_free(v12);
    goto LABEL_44;
  }
  v24 = *(v12 - 1);
  if ( (unsigned __int64)((char *)v12 - v24 - 8) > 0x1F )
LABEL_45:
    __fastfail(5u);
  j_j_free(v24);
  v22 = 1;
LABEL_34:
  if ( v27 > 0xF )
  {
    if ( v27 + 1 < 0x1000 )
    {
      v23 = v25[0];
    }
    else
    {
      v23 = (void *)*((_QWORD *)v25[0] - 1);
      if ( (unsigned __int64)((char *)v25[0] - (char *)v23 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v23);
  }
  return v22;
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800174D8: using guessed type __int64 qword_1800174D8;
// 1800174E0: using guessed type __int128 xmmword_1800174E0;

//----- (0000000180002860) ----------------------------------------------------
_QWORD *__fastcall sub_180002860(_QWORD *_RCX, unsigned __int64 *a2)
{
  _QWORD *v3; // rbx
  unsigned __int64 v6; // rsi
  __int64 v7; // rdi
  size_t v10; // rax
  void *v11; // rax
  void *v12; // rcx
  size_t v13; // rcx
  _QWORD *v14; // rax

  v3 = _RCX;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups xmmword ptr [rcx], xmm0
  }
  _RCX[2] = 0;
  _RCX[3] = 0;
  if ( a2[3] <= 0xF )
    _RBP = a2;
  else
    _RBP = (const void *)*a2;
  v6 = a2[2];
  v7 = 0x7FFFFFFFFFFFFFFFLL;
  if ( v6 > 0x7FFFFFFFFFFFFFFFLL )
    sub_180001680();
  if ( v6 <= 0xF )
  {
    _RCX[2] = v6;
    _RCX[3] = 15;
    __asm
    {
      vmovups xmm0, xmmword ptr [rbp+0]
      vmovups xmmword ptr [rcx], xmm0
    }
    return _RCX;
  }
  if ( (v6 | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    v10 = 0x8000000000000027uLL;
LABEL_9:
    v11 = sub_18000E800(v10);
    v12 = v11;
    if ( !v11 )
      __fastfail(5u);
    v14 = (_QWORD *)(((unsigned __int64)v11 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v14 - 1) = v12;
    goto LABEL_20;
  }
  v7 = v6 | 0xF;
  if ( (v6 | 0xF) < 0x16 )
    v7 = 22;
  v13 = v7 + 1;
  if ( v7 == -1 )
  {
    v14 = 0;
  }
  else
  {
    if ( v13 >= 0x1000 )
    {
      v10 = v7 + 40;
      if ( v7 + 40 < (unsigned __int64)(v7 + 1) )
        Concurrency::cancel_current_task();
      goto LABEL_9;
    }
    v14 = sub_18000E800(v13);
  }
LABEL_20:
  *v3 = v14;
  v3[2] = v6;
  v3[3] = v7;
  memcpy(v14, _RBP, v6 + 1);
  return v3;
}

//----- (0000000180002980) ----------------------------------------------------
void __fastcall sub_180002980(char **a1, char **a2)
{
  char **v3; // rbx
  unsigned __int64 v4; // rdx
  char *v5; // rax
  char *v6; // rcx

  if ( a1 != a2 )
  {
    v3 = a1;
    do
    {
      v4 = (unsigned __int64)v3[3];
      if ( v4 > 0xF )
      {
        v5 = *v3;
        if ( v4 + 1 < 0x1000 )
        {
          v6 = *v3;
        }
        else
        {
          v6 = (char *)*((_QWORD *)v5 - 1);
          if ( (unsigned __int64)(v5 - v6 - 8) > 0x1F )
            __fastfail(5u);
        }
        j_j_free(v6);
      }
      v3[2] = 0;
      v3[3] = (char *)15;
      *(_BYTE *)v3 = 0;
      v3 += 4;
    }
    while ( v3 != a2 );
  }
}

//----- (0000000180002A10) ----------------------------------------------------
void *__fastcall sub_180002A10(_QWORD *a1, const void *a2, unsigned __int64 a3)
{
  __int64 v3; // rbp
  __int64 v7; // rbx
  void *result; // rax
  size_t v9; // rcx
  void *v10; // rax
  _QWORD *v11; // rdi
  size_t v12; // rbx

  v3 = 0x7FFFFFFFFFFFFFFELL;
  if ( a3 > 0x7FFFFFFFFFFFFFFELL )
    sub_180001680();
  if ( a3 <= 7 )
  {
    a1[2] = a3;
    v7 = 2 * a3;
    a1[3] = 7;
    result = memcpy(a1, a2, 2 * a3);
    *(_WORD *)((char *)a1 + v7) = 0;
    return result;
  }
  if ( (a3 | 7) <= 0x7FFFFFFFFFFFFFFELL )
  {
    v3 = a3 | 7;
    if ( (a3 | 7) < 0xA )
      v3 = 10;
    if ( (unsigned __int64)(v3 + 1) > 0x7FFFFFFFFFFFFFFFLL )
      goto LABEL_19;
    v9 = 2 * (v3 + 1);
    if ( !v9 )
    {
      v11 = 0;
      goto LABEL_17;
    }
  }
  else
  {
    v9 = -2;
  }
  if ( v9 >= 0x1000 )
  {
    if ( v9 + 39 >= v9 )
    {
      v10 = sub_18000E800(v9 + 39);
      if ( !v10 )
        __fastfail(5u);
      v11 = (_QWORD *)(((unsigned __int64)v10 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v11 - 1) = v10;
      goto LABEL_17;
    }
LABEL_19:
    Concurrency::cancel_current_task();
  }
  v11 = sub_18000E800(v9);
LABEL_17:
  a1[2] = a3;
  v12 = 2 * a3;
  *a1 = v11;
  a1[3] = v3;
  result = memcpy(v11, a2, v12);
  *(_WORD *)((char *)v11 + v12) = 0;
  return result;
}

//----- (0000000180002B40) ----------------------------------------------------
void *__fastcall sub_180002B40(_QWORD *a1, const void *a2, size_t a3)
{
  __int64 v3; // rsi
  void *result; // rax
  size_t v8; // rax
  void *v9; // rax
  size_t v10; // rcx
  _QWORD *v11; // rdi

  v3 = 0x7FFFFFFFFFFFFFFFLL;
  if ( a3 > 0x7FFFFFFFFFFFFFFFLL )
    sub_180001680();
  if ( a3 <= 0xF )
  {
    a1[2] = a3;
    a1[3] = 15;
    result = memcpy(a1, a2, a3);
    *((_BYTE *)a1 + a3) = 0;
    return result;
  }
  if ( (a3 | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    v8 = 0x8000000000000027uLL;
LABEL_6:
    v9 = sub_18000E800(v8);
    if ( !v9 )
      __fastfail(5u);
    v11 = (_QWORD *)(((unsigned __int64)v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v11 - 1) = v9;
    goto LABEL_17;
  }
  v3 = a3 | 0xF;
  if ( (a3 | 0xF) < 0x16 )
    v3 = 22;
  v10 = v3 + 1;
  if ( v3 == -1 )
  {
    v11 = 0;
  }
  else
  {
    if ( v10 >= 0x1000 )
    {
      v8 = v3 + 40;
      if ( v3 + 40 < (unsigned __int64)(v3 + 1) )
        Concurrency::cancel_current_task();
      goto LABEL_6;
    }
    v11 = sub_18000E800(v10);
  }
LABEL_17:
  *a1 = v11;
  a1[2] = a3;
  a1[3] = v3;
  result = memcpy(v11, a2, a3);
  *((_BYTE *)v11 + a3) = 0;
  return result;
}

//----- (0000000180002C40) ----------------------------------------------------
void __fastcall sub_180002C40(__int64 a1)
{
  char **v2; // rcx
  char **v3; // rax
  char **v4; // rcx

  v2 = *(char ***)a1;
  if ( v2 )
  {
    sub_180002980(v2, *(char ***)(a1 + 8));
    v3 = *(char ***)a1;
    if ( ((*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFE0uLL) < 0x1000 )
    {
      v4 = *(char ***)a1;
    }
    else
    {
      v4 = (char **)*(v3 - 1);
      if ( (unsigned __int64)((char *)v3 - (char *)v4 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v4);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
}

//----- (0000000180002CB0) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
unsigned __int64 __fastcall sub_180002CB0(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  char **v6; // r13
  __int64 v7; // rdx
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r8
  __int64 v10; // r12
  unsigned __int64 v11; // rbp
  unsigned __int64 v12; // r14
  unsigned __int64 v13; // rdi
  void *v14; // rax
  __int64 v15; // r15
  char **v16; // rdx
  __int64 v20; // r15
  __int64 v22; // rax
  char **v25; // rax
  char **v26; // rcx

  _RBX = a2;
  v6 = *(char ***)a1;
  v7 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 5;
  if ( v7 == 0x7FFFFFFFFFFFFFFLL )
    sub_180003190();
  v8 = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v6) >> 5;
  v9 = v8 >> 1;
  if ( v8 > 0x7FFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_31;
  v10 = v7 + 1;
  v11 = v7 + 1;
  if ( v9 + v8 >= v7 + 1 )
    v11 = v9 + v8;
  if ( v11 > 0x7FFFFFFFFFFFFFFLL )
    goto LABEL_31;
  v12 = 32 * v11;
  if ( !(32 * v11) )
  {
    v13 = 0;
    goto LABEL_14;
  }
  if ( v12 < 0x1000 )
  {
    v13 = (unsigned __int64)sub_18000E800(32 * v11);
    goto LABEL_14;
  }
  if ( v12 + 39 < v12 )
LABEL_31:
    Concurrency::cancel_current_task();
  v14 = sub_18000E800(v12 + 39);
  if ( !v14 )
    __fastfail(5u);
  v13 = ((unsigned __int64)v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v13 - 8) = v14;
LABEL_14:
  v15 = (_RBX - (__int64)v6) >> 5;
  sub_180002860((_QWORD *)(v13 + 32 * v15), a3);
  v16 = *(char ***)(a1 + 8);
  _RAX = *(char ***)a1;
  _RCX = v13;
  if ( (char **)_RBX == v16 )
  {
    for ( ; _RAX != v16; _RAX += 4 )
    {
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vmovups xmmword ptr [rcx], xmm0
      }
      *(_QWORD *)(_RCX + 16) = 0;
      *(_QWORD *)(_RCX + 24) = 0;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rcx], ymm0
      }
      _RAX[2] = 0;
      _RAX[3] = (char *)15;
      *(_BYTE *)_RAX = 0;
      _RCX += 32LL;
    }
    __asm { vzeroupper }
    sub_180002980((char **)_RCX, (char **)_RCX);
    v20 = 32 * v15;
  }
  else
  {
    for ( ; _RAX != (char **)_RBX; _RAX += 4 )
    {
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vmovups xmmword ptr [rcx], xmm0
      }
      *(_QWORD *)(_RCX + 16) = 0;
      *(_QWORD *)(_RCX + 24) = 0;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rcx], ymm0
      }
      _RAX[2] = 0;
      _RAX[3] = (char *)15;
      *(_BYTE *)_RAX = 0;
      _RCX += 32LL;
    }
    __asm { vzeroupper }
    sub_180002980((char **)_RCX, (char **)_RCX);
    v20 = 32 * v15;
    v22 = *(_QWORD *)(a1 + 8);
    for ( _RCX = v13 + v20 + 32; _RBX != v22; _RBX += 32 )
    {
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vmovups xmmword ptr [rcx], xmm0
      }
      *(_QWORD *)(_RCX + 16) = 0;
      *(_QWORD *)(_RCX + 24) = 0;
      __asm
      {
        vmovups ymm0, ymmword ptr [rbx]
        vmovups ymmword ptr [rcx], ymm0
      }
      *(_QWORD *)(_RBX + 16) = 0;
      *(_QWORD *)(_RBX + 24) = 15;
      *(_BYTE *)_RBX = 0;
      _RCX += 32LL;
    }
    __asm { vzeroupper }
    sub_180002980((char **)_RCX, (char **)_RCX);
  }
  if ( *(_QWORD *)a1 )
  {
    sub_180002980(*(char ***)a1, *(char ***)(a1 + 8));
    v25 = *(char ***)a1;
    if ( ((*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFE0uLL) < 0x1000 )
    {
      v26 = *(char ***)a1;
    }
    else
    {
      v26 = (char **)*(v25 - 1);
      if ( (unsigned __int64)((char *)v25 - (char *)v26 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v26);
  }
  *(_QWORD *)a1 = v13;
  *(_QWORD *)(a1 + 8) = v13 + 32 * v10;
  *(_QWORD *)(a1 + 16) = v12 + v13;
  return v20 + v13;
}

//----- (0000000180002F60) ----------------------------------------------------
void **__fastcall sub_180002F60(void **Src, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  void *v5; // r15
  __int64 v6; // rbx
  char *v8; // rbp
  unsigned __int64 v9; // r14
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  size_t v12; // rcx
  _QWORD *v13; // rdi
  void *v14; // rax
  size_t v15; // r8
  char *v16; // r12
  size_t v17; // rbp
  _WORD *v18; // r15
  void *v19; // rbx
  _BYTE *v20; // rcx

  v5 = Src[2];
  v6 = 0x7FFFFFFFFFFFFFFELL;
  if ( 0x7FFFFFFFFFFFFFFELL - (__int64)v5 < a2 )
    sub_180001680();
  v8 = (char *)v5 + a2;
  v9 = (unsigned __int64)Src[3];
  v10 = ((unsigned __int64)v5 + a2) | 7;
  if ( v10 > 0x7FFFFFFFFFFFFFFELL || (v11 = v9 >> 1, v9 > 0x7FFFFFFFFFFFFFFELL - (v9 >> 1)) )
  {
    v12 = -2;
  }
  else
  {
    v6 = v10;
    if ( v10 < v9 + v11 )
      v6 = v9 + v11;
    if ( (unsigned __int64)(v6 + 1) > 0x7FFFFFFFFFFFFFFFLL )
      goto LABEL_24;
    v12 = 2 * (v6 + 1);
    if ( !v12 )
    {
      v13 = 0;
      goto LABEL_15;
    }
  }
  if ( v12 < 0x1000 )
  {
    v13 = sub_18000E800(v12);
    goto LABEL_15;
  }
  if ( v12 + 39 < v12 )
LABEL_24:
    Concurrency::cancel_current_task();
  v14 = sub_18000E800(v12 + 39);
  if ( !v14 )
    goto LABEL_19;
  v13 = (_QWORD *)(((unsigned __int64)v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v13 - 1) = v14;
LABEL_15:
  v15 = 2LL * (_QWORD)v5;
  Src[2] = v8;
  v16 = (char *)v13 + 2 * (_QWORD)v5;
  Src[3] = (void *)v6;
  v17 = 2 * a5;
  v18 = (_WORD *)v13 + (_QWORD)v5 + a5;
  if ( v9 <= 7 )
  {
    memcpy(v13, Src, v15);
    memcpy(v16, L"proxy_config.txt", v17);
    *v18 = 0;
    goto LABEL_22;
  }
  v19 = *Src;
  memcpy(v13, *Src, v15);
  memcpy(v16, L"proxy_config.txt", v17);
  *v18 = 0;
  if ( 2 * v9 + 2 < 0x1000 )
  {
    j_j_free(v19);
    goto LABEL_22;
  }
  v20 = (_BYTE *)*((_QWORD *)v19 - 1);
  if ( (unsigned __int64)((_BYTE *)v19 - v20 - 8) > 0x1F )
LABEL_19:
    __fastfail(5u);
  j_j_free(v20);
LABEL_22:
  *Src = v13;
  return Src;
}
// 180013CA0: using guessed type wchar_t aProxyConfigTxt[17];

//----- (0000000180003190) ----------------------------------------------------
void __noreturn sub_180003190()
{
  std::_Xlength_error("vector too long");
}
// 180011140: using guessed type void __noreturn std::_Xlength_error(const char *);

//----- (00000001800031B0) ----------------------------------------------------
size_t __fastcall sub_1800031B0(unsigned __int64 *a1, unsigned __int64 a2)
{
  size_t v3; // rbx
  unsigned __int64 v4; // rax
  void *v5; // rax
  void *v6; // rcx
  size_t result; // rax

  if ( a2 > 0x7FFFFFFFFFFFFFFLL )
    goto LABEL_11;
  v3 = 32 * a2;
  if ( !(32 * a2) )
  {
    v4 = 0;
    goto LABEL_10;
  }
  if ( v3 < 0x1000 )
  {
    v4 = (unsigned __int64)sub_18000E800(v3);
    goto LABEL_10;
  }
  if ( v3 + 39 < v3 )
LABEL_11:
    Concurrency::cancel_current_task();
  v5 = sub_18000E800(v3 + 39);
  v6 = v5;
  if ( !v5 )
    __fastfail(5u);
  v4 = ((unsigned __int64)v5 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(v4 - 8) = v6;
LABEL_10:
  *a1 = v4;
  a1[1] = v4;
  result = v3 + v4;
  a1[2] = result;
  return result;
}

//----- (0000000180003240) ----------------------------------------------------
void __noreturn sub_180003240()
{
  std::_Xout_of_range("invalid string position");
  JUMPOUT(0x180003251LL);
}
// 18000324B: control flows out of bounds to 180003251
// 180011138: using guessed type void std::_Xout_of_range(const char *);

//----- (0000000180003290) ----------------------------------------------------
void __noreturn sub_180003290()
{
  std::_Xlength_error("map/set too long");
}
// 180011140: using guessed type void __noreturn std::_Xlength_error(const char *);

//----- (00000001800032B0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_1800032B0(HANDLE hProcess, unsigned int a2)
{
  _QWORD *v4; // rcx
  _BYTE *v5; // rdx
  SIZE_T v6; // rbp
  void *v7; // rax
  void *v8; // rdi
  HMODULE ModuleHandleW; // rax
  HMODULE (__stdcall *LoadLibraryW)(LPCWSTR); // rax
  HANDLE RemoteThread; // rax
  void *v12; // rbp
  void *v13; // rbp
  _QWORD *v14; // rax
  _BYTE *v15; // rdx
  void *v16; // rsi
  bool v17; // cf
  BOOL v18; // edi
  _DWORD *v19; // rax
  unsigned __int8 v20; // bl
  void *v22; // [rsp+40h] [rbp-278h] BYREF
  BOOL v23; // [rsp+48h] [rbp-270h]
  int v24; // [rsp+4Ch] [rbp-26Ch]
  void **v25; // [rsp+50h] [rbp-268h]
  __int64 v26; // [rsp+58h] [rbp-260h]
  WCHAR Filename[264]; // [rsp+70h] [rbp-248h] BYREF

  v22 = &unk_1800170A0;
  if ( Mtx_lock((_Mtx_t)&unk_1800170A0) )
  {
    std::_Throw_Cpp_error(5);
    __debugbreak();
  }
  if ( dword_1800170EC == 0x7FFFFFFF )
  {
    dword_1800170EC = 2147483646;
    std::_Throw_Cpp_error(6);
  }
  v4 = (_QWORD *)*((_QWORD *)qword_180017518 + 1);
  v5 = qword_180017518;
  while ( !*((_BYTE *)v4 + 25) )
  {
    if ( *((_DWORD *)v4 + 7) >= a2 )
    {
      v5 = v4;
      v4 = (_QWORD *)*v4;
    }
    else
    {
      v4 = (_QWORD *)v4[2];
    }
  }
  if ( !v5[25] && a2 >= *((_DWORD *)v5 + 7) && v5 != qword_180017518 )
    goto LABEL_31;
  if ( !GetModuleFileNameW(hModule, Filename, 0x104u) )
    goto LABEL_31;
  v6 = 2 * wcslen(Filename) + 2;
  v7 = VirtualAllocEx(hProcess, 0, v6, 0x3000u, 4u);
  v8 = v7;
  if ( !v7 )
    goto LABEL_31;
  if ( !WriteProcessMemory(hProcess, v7, Filename, v6, 0)
    || (ModuleHandleW = GetModuleHandleW(L"Kernel32.dll"),
        (LoadLibraryW = (HMODULE (__stdcall *)(LPCWSTR))GetProcAddress(ModuleHandleW, "LoadLibraryW")) == 0)
    || (RemoteThread = CreateRemoteThread(hProcess, 0, 0, (LPTHREAD_START_ROUTINE)LoadLibraryW, v8, 0, 0),
        (v12 = RemoteThread) == 0) )
  {
    VirtualFreeEx(hProcess, v8, 0, 0x8000u);
LABEL_31:
    v20 = 0;
    goto LABEL_32;
  }
  WaitForSingleObject(RemoteThread, 0xFFFFFFFF);
  CloseHandle(v12);
  VirtualFreeEx(hProcess, v8, 0, 0x8000u);
  v13 = qword_180017518;
  v14 = (_QWORD *)*((_QWORD *)qword_180017518 + 1);
  v15 = qword_180017518;
  if ( *((_BYTE *)v14 + 25) )
  {
    v18 = 0;
    v16 = (void *)*((_QWORD *)qword_180017518 + 1);
  }
  else
  {
    do
    {
      v16 = v14;
      v17 = *((_DWORD *)v14 + 7) < a2;
      if ( *((_DWORD *)v14 + 7) >= a2 )
      {
        v15 = v14;
        v14 = (_QWORD *)*v14;
      }
      else
      {
        v14 = (_QWORD *)v14[2];
      }
      v18 = !v17;
    }
    while ( !*((_BYTE *)v14 + 25) );
  }
  if ( v15[25] || a2 < *((_DWORD *)v15 + 7) )
  {
    if ( qword_180017520 == 0x7FFFFFFFFFFFFFFLL )
      sub_180003290();
    v25 = &qword_180017518;
    v26 = 0;
    v19 = sub_18000E800(0x20u);
    v19[7] = a2;
    *(_QWORD *)v19 = v13;
    *((_QWORD *)v19 + 1) = v13;
    *((_QWORD *)v19 + 2) = v13;
    *((_WORD *)v19 + 12) = 0;
    v22 = v16;
    v23 = v18;
    v24 = HIDWORD(v26);
    sub_180003C90(&qword_180017518, (__int64)&v22, (__int64)v19);
  }
  v20 = 1;
LABEL_32:
  Mtx_unlock((_Mtx_t)&unk_1800170A0);
  return v20;
}
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);
// 1800170EC: using guessed type int dword_1800170EC;
// 180017520: using guessed type __int64 qword_180017520;

//----- (0000000180003580) ----------------------------------------------------
__int64 __fastcall sub_180003580(
        const wchar_t *a1,
        const wchar_t *a2,
        __int64 a3,
        __int64 a4,
        int a5,
        char a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10)
{
  __int64 result; // rax
  unsigned int v13; // ebx

  result = ((__int64 (__fastcall *)(const wchar_t *, const wchar_t *, __int64))qword_180017568)(a1, a2, a3);
  v13 = result;
  if ( (_DWORD)result && a10 )
  {
    if ( sub_1800020D0(a1) || sub_1800020D0(a2) )
      sub_1800032B0(*(HANDLE *)a10, *(_DWORD *)(a10 + 16));
    if ( (a6 & 4) == 0 )
      ResumeThread(*(HANDLE *)(a10 + 8));
    return v13;
  }
  return result;
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 180017568: using guessed type __int64 qword_180017568;

//----- (0000000180003650) ----------------------------------------------------
__int64 __fastcall sub_180003650(
        const char *a1,
        const char *a2,
        __int64 a3,
        __int64 a4,
        int a5,
        char a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10)
{
  __int64 result; // rax
  unsigned int v13; // ebx

  result = ((__int64 (__fastcall *)(const char *, const char *, __int64))qword_180017570)(a1, a2, a3);
  v13 = result;
  if ( (_DWORD)result && a10 )
  {
    if ( sub_1800024E0(a1) || sub_1800024E0(a2) )
      sub_1800032B0(*(HANDLE *)a10, *(_DWORD *)(a10 + 16));
    if ( (a6 & 4) == 0 )
      ResumeThread(*(HANDLE *)(a10 + 8));
    return v13;
  }
  return result;
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 180017570: using guessed type __int64 qword_180017570;

//----- (0000000180003720) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
int __fastcall sub_180003720(double a1)
{
  HMODULE ModuleHandleW; // rax
  BOOL (__stdcall *CreateProcessW)(LPCWSTR, LPWSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCWSTR, LPSTARTUPINFOW, LPPROCESS_INFORMATION); // rax
  HANDLE CurrentThread; // rax
  __int64 (__fastcall *v4)(const wchar_t *, const wchar_t *, __int64, __int64, int, char, __int64, __int64, __int64, __int64); // rsi
  __int64 *v5; // rdi
  __int64 v6; // rcx
  __int64 v7; // rdx
  BOOL (__stdcall *CreateProcessA)(LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION); // rax
  HANDLE v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 *v13; // [rsp+30h] [rbp-18h] BYREF
  __int64 (__fastcall *v14)(const wchar_t *, const wchar_t *, __int64, __int64, int, char, __int64, __int64, __int64, __int64); // [rsp+38h] [rbp-10h]

  ModuleHandleW = GetModuleHandleW(L"Kernel32.dll");
  if ( ModuleHandleW || (ModuleHandleW = LoadLibraryW(L"Kernel32.dll")) != 0 )
  {
    CreateProcessW = (BOOL (__stdcall *)(LPCWSTR, LPWSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCWSTR, LPSTARTUPINFOW, LPPROCESS_INFORMATION))GetProcAddress(ModuleHandleW, "CreateProcessW");
    if ( CreateProcessW )
    {
      qword_180017568 = (__int64)CreateProcessW;
      sub_180009150();
      CurrentThread = GetCurrentThread();
      sub_1800097F0(CurrentThread);
      v4 = sub_180003580;
      v5 = &qword_180017568;
      sub_180009890((_BYTE **)&qword_180017568, sub_180003580);
      if ( !(unsigned int)sub_180009230(a1) )
      {
        if ( Mtx_lock((_Mtx_t)&unk_180019020) )
          goto LABEL_16;
        if ( dword_18001906C == 0x7FFFFFFF )
        {
LABEL_18:
          dword_18001906C = 2147483646;
          std::_Throw_Cpp_error(6);
LABEL_19:
          v13 = v5;
          v14 = v4;
          v11 = (__int64)*(&Src + 1);
          if ( *(&Src + 1) == (void *)qword_180017548 )
          {
            sub_18000A910(v10, *(&Src + 1), (__int64)&v13);
          }
          else
          {
            *(_QWORD *)*(&Src + 1) = v5;
            *(_QWORD *)(v11 + 8) = v4;
            *(&Src + 1) = (char *)*(&Src + 1) + 16;
          }
          LODWORD(CreateProcessA) = Mtx_unlock((_Mtx_t)&unk_180019020);
          return (int)CreateProcessA;
        }
        v13 = &qword_180017568;
        v14 = sub_180003580;
        v7 = (__int64)*(&Src + 1);
        if ( *(&Src + 1) == (void *)qword_180017548 )
        {
          sub_18000A910(v6, *(&Src + 1), (__int64)&v13);
        }
        else
        {
          *(_QWORD *)*(&Src + 1) = &qword_180017568;
          *(_QWORD *)(v7 + 8) = sub_180003580;
          *(&Src + 1) = (char *)*(&Src + 1) + 16;
        }
        Mtx_unlock((_Mtx_t)&unk_180019020);
      }
    }
  }
  CreateProcessA = (BOOL (__stdcall *)(LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION))GetModuleHandleW(L"Kernel32.dll");
  if ( CreateProcessA
    || (CreateProcessA = (BOOL (__stdcall *)(LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION))LoadLibraryW(L"Kernel32.dll")) != 0 )
  {
    CreateProcessA = (BOOL (__stdcall *)(LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION))GetProcAddress((HMODULE)CreateProcessA, "CreateProcessA");
    if ( CreateProcessA )
    {
      qword_180017570 = (__int64)CreateProcessA;
      sub_180009150();
      v9 = GetCurrentThread();
      sub_1800097F0(v9);
      v4 = (__int64 (__fastcall *)(const wchar_t *, const wchar_t *, __int64, __int64, int, char, __int64, __int64, __int64, __int64))sub_180003650;
      v5 = &qword_180017570;
      sub_180009890((_BYTE **)&qword_180017570, sub_180003650);
      LODWORD(CreateProcessA) = sub_180009230(a1);
      if ( !(_DWORD)CreateProcessA )
      {
        if ( Mtx_lock((_Mtx_t)&unk_180019020) )
        {
LABEL_16:
          std::_Throw_Cpp_error(5);
          __debugbreak();
        }
        if ( dword_18001906C != 0x7FFFFFFF )
          goto LABEL_19;
        goto LABEL_18;
      }
    }
  }
  return (int)CreateProcessA;
}
// 180003809: variable 'v6' is possibly undefined
// 180003905: variable 'v10' is possibly undefined
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);
// 180017548: using guessed type __int64 qword_180017548;
// 180017568: using guessed type __int64 qword_180017568;
// 180017570: using guessed type __int64 qword_180017570;
// 18001906C: using guessed type int dword_18001906C;

//----- (0000000180003930) ----------------------------------------------------
errno_t sub_180003930()
{
  const wchar_t *CommandLineW; // rax
  wchar_t Destination[32768]; // [rsp+20h] [rbp-10018h] BYREF

  GetCurrentProcessId();
  CommandLineW = GetCommandLineW();
  return wcsncpy_s(Destination, 0x8000u, CommandLineW, 0xFFFFFFFFFFFFFFFFuLL);
}

//----- (0000000180003990) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
__int64 __fastcall sub_180003990(HMODULE hModule, int a2, double a3)
{
  double v3; // xmm0_8
  __int64 v5; // rdx
  BOOL fPending; // [rsp+60h] [rbp-C88h] BYREF
  wchar_t Drive; // [rsp+68h] [rbp-C80h] BYREF
  wchar_t Dir[264]; // [rsp+70h] [rbp-C78h] BYREF
  WCHAR Value[264]; // [rsp+280h] [rbp-A68h] BYREF
  wchar_t String1[264]; // [rsp+490h] [rbp-858h] BYREF
  WCHAR Filename[264]; // [rsp+6A0h] [rbp-648h] BYREF
  WCHAR Buffer[264]; // [rsp+8B0h] [rbp-438h] BYREF
  wchar_t Ext[264]; // [rsp+AC0h] [rbp-228h] BYREF

  if ( a2 )
  {
    if ( a2 != 1 )
      return 1;
    if ( InitOnceBeginInitialize(&InitOnce, 0, &fPending, 0) )
    {
      if ( fPending )
      {
        ::hModule = hModule;
        sub_1800016A0(hModule, v5, a3);
        sub_180003930();
        if ( GetModuleFileNameW(0, Filename, 0x104u) && sub_1800020D0(Filename) )
          sub_18000C460(v3);
        GetSystemDirectoryW(Buffer, 0x105u);
        GetModuleFileNameW(hModule, Value, 0x105u);
        SetEnvironmentVariableW(L"VERSION_DLL_PLUGIN_PROVIDER", Value);
        wsplitpath_s(Value, &Drive, 4u, Dir, 0x101u, String1, 0x101u, Ext, 0x101u);
        if ( wcsicmp(String1, L"version") )
        {
          dword_1800174A8 = 0;
        }
        else
        {
          dword_1800174A8 = 1;
          if ( hLibModule )
          {
            FreeLibrary(hLibModule);
            hLibModule = 0;
          }
          sub_18000D460(Dir, 0x104u, (wchar_t *)L"%s\\%s.dll", Buffer, L"version");
          hLibModule = LoadLibraryW(Dir);
        }
        sub_180003720(v3);
        if ( !InitOnceComplete(&InitOnce, 0, 0) )
          sub_18000E7C0();
      }
      return 1;
    }
LABEL_16:
    __fastfail(5u);
  }
  if ( !InitOnceBeginInitialize(&stru_180017480, 0, &fPending, 0) )
    goto LABEL_16;
  if ( fPending )
  {
    sub_18000A840(v3);
    if ( dword_1800174A8 == 1 && hLibModule )
    {
      FreeLibrary(hLibModule);
      hLibModule = 0;
    }
    sub_18000A840(v3);
    if ( !InitOnceComplete(&stru_180017480, 0, 0) )
      sub_18000E7C0();
  }
  return 1;
}
// 180003A07: variable 'v5' is possibly undefined
// 180003A3C: variable 'v3' is possibly undefined
// 1800174A8: using guessed type int dword_1800174A8;

//----- (0000000180003C40) ----------------------------------------------------
void __fastcall sub_180003C40(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rbx
  void *v6; // rcx

  v3 = (_QWORD *)a3;
  if ( !*(_BYTE *)(a3 + 25) )
  {
    do
    {
      sub_180003C40(a1, a2, v3[2]);
      v6 = v3;
      v3 = (_QWORD *)*v3;
      j_j_free(v6);
    }
    while ( !*((_BYTE *)v3 + 25) );
  }
}

//----- (0000000180003C90) ----------------------------------------------------
__int64 __fastcall sub_180003C90(_QWORD *a1, __int64 a2, __int64 a3)
{
  _QWORD *v4; // r11
  _QWORD *v6; // rax
  _QWORD *v8; // rdx
  __int64 v9; // rax
  __int64 *v10; // r8
  __int64 v11; // rcx
  __int64 v12; // rcx
  _QWORD *v13; // r8
  _QWORD *v14; // rcx
  _QWORD *v15; // rcx
  _QWORD *v16; // r8
  __int64 v17; // rax
  _QWORD *v18; // rax
  _QWORD *v19; // r8
  __int64 v20; // rcx
  _QWORD *v21; // rcx
  _QWORD *v22; // rax

  ++a1[1];
  v4 = (_QWORD *)*a1;
  v6 = *(_QWORD **)a2;
  *(_QWORD *)(a3 + 8) = *(_QWORD *)a2;
  if ( v6 == v4 )
  {
    *v4 = a3;
    v4[1] = a3;
    v4[2] = a3;
    *(_BYTE *)(a3 + 24) = 1;
    return a3;
  }
  if ( *(_DWORD *)(a2 + 8) )
  {
    *v6 = a3;
    if ( v6 == (_QWORD *)*v4 )
      *v4 = a3;
  }
  else
  {
    v6[2] = a3;
    if ( v6 == (_QWORD *)v4[2] )
      v4[2] = a3;
  }
  v8 = (_QWORD *)a3;
  while ( !*(_BYTE *)(v8[1] + 24LL) )
  {
    v9 = v8[1];
    v10 = *(__int64 **)(v9 + 8);
    v11 = *v10;
    if ( v9 == *v10 )
    {
      v12 = v10[2];
      if ( *(_BYTE *)(v12 + 24) )
      {
        v13 = *(_QWORD **)(v9 + 16);
        if ( v8 == v13 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)(v9 + 16) = *v13;
          if ( !*(_BYTE *)(*v13 + 25LL) )
            *(_QWORD *)(*v13 + 8LL) = v9;
          v13[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == *(_QWORD *)(*a1 + 8LL) )
          {
            *(_QWORD *)(*a1 + 8LL) = v13;
          }
          else
          {
            v14 = *(_QWORD **)(v9 + 8);
            if ( v9 == *v14 )
              *v14 = v13;
            else
              v14[2] = v13;
          }
          *v13 = v9;
          *(_QWORD *)(v9 + 8) = v13;
        }
        *(_BYTE *)(v8[1] + 24LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)*v15;
        *v15 = *(_QWORD *)(*v15 + 16LL);
        v17 = v16[2];
        if ( !*(_BYTE *)(v17 + 25) )
          *(_QWORD *)(v17 + 8) = v15;
        v16[1] = v15[1];
        if ( v15 == *(_QWORD **)(*a1 + 8LL) )
        {
          *(_QWORD *)(*a1 + 8LL) = v16;
          v16[2] = v15;
        }
        else
        {
          v18 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)v18[2] )
            v18[2] = v16;
          else
            *v18 = v16;
          v16[2] = v15;
        }
LABEL_48:
        v15[1] = v16;
        continue;
      }
      *(_BYTE *)(v9 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
    else
    {
      if ( *(_BYTE *)(v11 + 24) )
      {
        v19 = *(_QWORD **)v9;
        if ( v8 == *(_QWORD **)v9 )
        {
          v8 = (_QWORD *)v8[1];
          *(_QWORD *)v9 = v19[2];
          v20 = v19[2];
          if ( !*(_BYTE *)(v20 + 25) )
            *(_QWORD *)(v20 + 8) = v9;
          v19[1] = *(_QWORD *)(v9 + 8);
          if ( v9 == *(_QWORD *)(*a1 + 8LL) )
          {
            *(_QWORD *)(*a1 + 8LL) = v19;
          }
          else
          {
            v21 = *(_QWORD **)(v9 + 8);
            if ( v9 == v21[2] )
              v21[2] = v19;
            else
              *v21 = v19;
          }
          v19[2] = v9;
          *(_QWORD *)(v9 + 8) = v19;
        }
        *(_BYTE *)(v8[1] + 24LL) = 1;
        *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
        v15 = *(_QWORD **)(v8[1] + 8LL);
        v16 = (_QWORD *)v15[2];
        v15[2] = *v16;
        if ( !*(_BYTE *)(*v16 + 25LL) )
          *(_QWORD *)(*v16 + 8LL) = v15;
        v16[1] = v15[1];
        if ( v15 == *(_QWORD **)(*a1 + 8LL) )
        {
          *(_QWORD *)(*a1 + 8LL) = v16;
        }
        else
        {
          v22 = (_QWORD *)v15[1];
          if ( v15 == (_QWORD *)*v22 )
            *v22 = v16;
          else
            v22[2] = v16;
        }
        *v16 = v15;
        goto LABEL_48;
      }
      *(_BYTE *)(v9 + 24) = 1;
      *(_BYTE *)(v11 + 24) = 1;
      *(_BYTE *)(*(_QWORD *)(v8[1] + 8LL) + 24LL) = 0;
      v8 = *(_QWORD **)(v8[1] + 8LL);
    }
  }
  *(_BYTE *)(v4[1] + 24LL) = 1;
  return a3;
}

//----- (0000000180003F10) ----------------------------------------------------
void *sub_180003F10()
{
  return &unk_180017490;
}

//----- (0000000180003F20) ----------------------------------------------------
__int64 sub_180003F20()
{
  return 0;
}

//----- (0000000180003F50) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_180003F50(_QWORD *_RCX, char *a2)
{
  _QWORD *v4; // rbx
  unsigned __int16 TickCount; // ax
  __int64 v7; // r8
  char v8; // si
  __int16 v9; // ax
  _BYTE *v10; // rdx
  _BYTE *v11; // rdx
  _BYTE *v12; // rdx
  _BYTE *v13; // rdx
  _BYTE *v14; // rdx
  _BYTE *v15; // rdx
  _BYTE *v16; // rdx
  _BYTE *v17; // rdx
  _BYTE *v18; // rdx
  _BYTE *v19; // rdx
  _BYTE *v20; // rdx
  _BYTE *v21; // rdx
  unsigned __int64 v23; // rsi
  unsigned __int64 v24; // r14
  char *v25; // rcx
  char *v26; // rdx
  char *v27; // r15
  char *v28; // r13
  char v29; // r9
  void **v30; // rdi
  void **v31; // r12
  void **v32; // rax
  void **i; // rsi
  char v34; // al
  void **v35; // rax
  void **v36; // rax
  _BYTE *v37; // rdx
  _BYTE *v38; // r15
  void **v39; // rax
  void **v40; // rcx
  void **v41; // rdi
  void **v42; // rsi
  char v43; // al
  _BYTE *v44; // rdx
  _BYTE *v45; // rdx
  _BYTE *v46; // rdx
  _BYTE *v47; // rdx
  _BYTE *v48; // rdx
  _BYTE *v49; // rdx
  _BYTE *v50; // rcx
  _BYTE v52[4]; // [rsp+20h] [rbp-48h] BYREF
  int v53; // [rsp+24h] [rbp-44h]
  _QWORD *v54; // [rsp+28h] [rbp-40h]
  void *Block[2]; // [rsp+30h] [rbp-38h] BYREF
  unsigned __int64 v56; // [rsp+40h] [rbp-28h]
  __int64 v57; // [rsp+48h] [rbp-20h]

  v4 = _RCX;
  v54 = _RCX;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups xmmword ptr [rcx], xmm0
  }
  *_RCX = 0;
  _RCX[1] = 0;
  _RCX[2] = 0;
  v53 = 1;
  TickCount = GetTickCount();
  v8 = TickCount;
  v9 = HIBYTE(TickCount);
  v52[0] = v9;
  v10 = (_BYTE *)v4[1];
  if ( v10 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v10, v52);
  }
  else
  {
    *v10 = v9;
    ++v4[1];
  }
  v52[0] = v8;
  v11 = (_BYTE *)v4[1];
  if ( v11 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v11, v52);
  }
  else
  {
    *v11 = v8;
    ++v4[1];
  }
  v52[0] = 1;
  v12 = (_BYTE *)v4[1];
  if ( v12 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v12, v52);
  }
  else
  {
    *v12 = 1;
    ++v4[1];
  }
  v52[0] = 0;
  v13 = (_BYTE *)v4[1];
  if ( v13 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v13, v52);
  }
  else
  {
    *v13 = 0;
    ++v4[1];
  }
  v52[0] = 0;
  v14 = (_BYTE *)v4[1];
  if ( v14 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v14, v52);
  }
  else
  {
    *v14 = 0;
    ++v4[1];
  }
  v52[0] = 1;
  v15 = (_BYTE *)v4[1];
  if ( v15 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v15, v52);
  }
  else
  {
    *v15 = 1;
    ++v4[1];
  }
  v52[0] = 0;
  v16 = (_BYTE *)v4[1];
  if ( v16 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v16, v52);
  }
  else
  {
    *v16 = 0;
    ++v4[1];
  }
  v52[0] = 0;
  v17 = (_BYTE *)v4[1];
  if ( v17 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v17, v52);
  }
  else
  {
    *v17 = 0;
    ++v4[1];
  }
  v52[0] = 0;
  v18 = (_BYTE *)v4[1];
  if ( v18 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v18, v52);
  }
  else
  {
    *v18 = 0;
    ++v4[1];
  }
  v52[0] = 0;
  v19 = (_BYTE *)v4[1];
  if ( v19 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v19, v52);
  }
  else
  {
    *v19 = 0;
    ++v4[1];
  }
  v52[0] = 0;
  v20 = (_BYTE *)v4[1];
  if ( v20 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v20, v52);
  }
  else
  {
    *v20 = 0;
    ++v4[1];
  }
  v52[0] = 0;
  v21 = (_BYTE *)v4[1];
  if ( v21 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v21, v52);
  }
  else
  {
    *v21 = 0;
    ++v4[1];
  }
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups xmmword ptr [rbp+Block], xmm0
  }
  v23 = 0;
  v56 = 0;
  v24 = 15;
  v57 = 15;
  LOBYTE(Block[0]) = 0;
  v25 = a2;
  if ( *((_QWORD *)a2 + 3) <= 0xFu )
  {
    v27 = a2;
    v26 = a2;
  }
  else
  {
    v25 = *(char **)a2;
    v26 = *(char **)a2;
    v27 = *(char **)a2;
  }
  v28 = &v26[*((_QWORD *)a2 + 2)];
  if ( v25 == v28 )
    goto LABEL_78;
  do
  {
    v29 = *v27;
    if ( *v27 == 46 )
    {
      if ( !v23 )
        goto LABEL_64;
      v52[0] = v23;
      v26 = (char *)v4[1];
      if ( v26 == (char *)v4[2] )
      {
        sub_180006CE0(v4, v26, v52);
      }
      else
      {
        *v26 = v23;
        ++v4[1];
      }
      v30 = Block;
      v31 = (void **)Block[0];
      if ( v24 > 0xF )
        v30 = (void **)Block[0];
      v32 = Block;
      if ( v24 > 0xF )
        v32 = (void **)Block[0];
      for ( i = (void **)((char *)v32 + v23); v30 != i; v30 = (void **)((char *)v30 + 1) )
      {
        v34 = *(_BYTE *)v30;
        v52[0] = *(_BYTE *)v30;
        v26 = (char *)v4[1];
        if ( v26 == (char *)v4[2] )
        {
          sub_180006CE0(v4, v26, v52);
        }
        else
        {
          *v26 = v34;
          ++v4[1];
        }
      }
      v56 = 0;
      v35 = Block;
      if ( v24 > 0xF )
        v35 = v31;
      *(_BYTE *)v35 = 0;
    }
    else if ( v23 >= v24 )
    {
      sub_180007180(Block, (__int64)v26, v7, v29);
    }
    else
    {
      v56 = v23 + 1;
      v36 = Block;
      if ( v24 > 0xF )
        v36 = (void **)Block[0];
      *((_BYTE *)v36 + v23) = v29;
      *((_BYTE *)v36 + v23 + 1) = 0;
    }
    v24 = v57;
    v23 = v56;
LABEL_64:
    ++v27;
  }
  while ( v27 != v28 );
  if ( !v23 )
  {
LABEL_78:
    v38 = Block[0];
    goto LABEL_79;
  }
  v52[0] = v23;
  v37 = (_BYTE *)v4[1];
  if ( v37 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v37, v52);
  }
  else
  {
    *v37 = v23;
    ++v4[1];
  }
  v38 = Block[0];
  if ( v24 <= 0xF )
  {
    v39 = Block;
    v41 = Block;
    v40 = Block;
  }
  else
  {
    v39 = (void **)Block[0];
    v40 = (void **)Block[0];
    v41 = (void **)Block[0];
  }
  v42 = (void **)((char *)v40 + v23);
  if ( v39 != v42 )
  {
    do
    {
      v43 = *(_BYTE *)v41;
      v52[0] = *(_BYTE *)v41;
      v44 = (_BYTE *)v4[1];
      if ( v44 == (_BYTE *)v4[2] )
      {
        sub_180006CE0(v4, v44, v52);
      }
      else
      {
        *v44 = v43;
        ++v4[1];
      }
      v41 = (void **)((char *)v41 + 1);
    }
    while ( v41 != v42 );
  }
LABEL_79:
  v52[0] = 0;
  v45 = (_BYTE *)v4[1];
  if ( v45 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v45, v52);
  }
  else
  {
    *v45 = 0;
    ++v4[1];
  }
  v52[0] = 0;
  v46 = (_BYTE *)v4[1];
  if ( v46 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v46, v52);
  }
  else
  {
    *v46 = 0;
    ++v4[1];
  }
  v52[0] = 1;
  v47 = (_BYTE *)v4[1];
  if ( v47 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v47, v52);
  }
  else
  {
    *v47 = 1;
    ++v4[1];
  }
  v52[0] = 0;
  v48 = (_BYTE *)v4[1];
  if ( v48 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v48, v52);
  }
  else
  {
    *v48 = 0;
    ++v4[1];
  }
  v52[0] = 1;
  v49 = (_BYTE *)v4[1];
  if ( v49 == (_BYTE *)v4[2] )
  {
    sub_180006CE0(v4, v49, v52);
  }
  else
  {
    *v49 = 1;
    ++v4[1];
  }
  if ( v24 > 0xF )
  {
    if ( v24 + 1 < 0x1000 )
    {
      v50 = v38;
    }
    else
    {
      v50 = (_BYTE *)*((_QWORD *)v38 - 1);
      if ( (unsigned __int64)(v38 - v50 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v50);
  }
  return v4;
}
// 18000426E: variable 'v26' is possibly undefined
// 18000426E: variable 'v7' is possibly undefined

//----- (0000000180004420) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_180004420(_QWORD *_RCX, __int64 *a2)
{
  __int64 v4; // rdi
  __int64 v6; // r8
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rbx
  __int64 v9; // rcx
  unsigned __int64 v10; // rbx
  int v11; // esi
  int v12; // ebp
  __int64 v13; // r8
  unsigned __int64 v14; // rdx
  __int64 v15; // rcx
  unsigned __int64 v16; // r10
  unsigned __int16 *v17; // r9
  __int64 v18; // r11
  size_t v19; // rax
  unsigned __int64 v22; // rdx
  void *v23; // rcx
  __m256 v25; // [rsp+38h] [rbp-80h] BYREF
  _QWORD *v26; // [rsp+58h] [rbp-60h]
  char Str[32]; // [rsp+60h] [rbp-58h] BYREF

  v4 = (__int64)_RCX;
  v26 = _RCX;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups xmmword ptr [rcx], xmm0
  }
  *_RCX = 0;
  _RCX[1] = 0;
  _RCX[2] = 0;
  v6 = *a2;
  v7 = a2[1] - *a2;
  if ( v7 >= 0xC )
  {
    v8 = 12;
    if ( v7 > 0xC )
    {
      while ( 1 )
      {
        v9 = *(unsigned __int8 *)(v6 + v8);
        if ( !(_BYTE)v9 )
          break;
        if ( (v9 & 0xC0) == 0xC0 )
        {
          v8 += 2LL;
          goto LABEL_9;
        }
        v8 += v9 + 1;
        if ( v8 >= v7 )
          goto LABEL_9;
      }
      ++v8;
    }
LABEL_9:
    v10 = v8 + 4;
    if ( v10 < v7 )
    {
      v11 = 0;
      v12 = *(unsigned __int8 *)(v6 + 7) | (*(unsigned __int8 *)(v6 + 6) << 8);
      if ( v12 )
      {
        do
        {
          v13 = *a2;
          if ( v10 >= a2[1] - *a2 )
            break;
          v14 = a2[1] - v13;
          while ( 1 )
          {
            v15 = *(unsigned __int8 *)(v13 + v10);
            if ( !(_BYTE)v15 )
              break;
            if ( (v15 & 0xC0) == 0xC0 )
            {
              v10 += 2LL;
              goto LABEL_19;
            }
            v10 += v15 + 1;
            if ( v10 >= v14 )
              goto LABEL_19;
          }
          ++v10;
LABEL_19:
          v16 = v10 + 10;
          if ( v10 + 10 > v14 )
            break;
          v17 = (unsigned __int16 *)(v13 + v10);
          v18 = _byteswap_ushort(*(_WORD *)(v13 + v10 + 8));
          v10 = v18 + v16;
          if ( v18 + v16 > v14 )
            break;
          if ( _byteswap_ushort(*v17) == 1 && (_DWORD)v18 == 4 )
          {
            __asm { vzeroupper }
            sub_1800061C0(
              Str,
              "%d.%d.%d.%d",
              *(unsigned __int8 *)(v16 + v13),
              *(unsigned __int8 *)(v16 + v13 + 1),
              *(unsigned __int8 *)(v16 + v13 + 2),
              *(unsigned __int8 *)(v16 + v13 + 3));
            __asm
            {
              vpxor   xmm0, xmm0, xmm0
              vmovups xmmword ptr [rsp+0B8h+var_80], xmm0
            }
            *(_OWORD *)&v25.m256_f32[4] = 0u;
            v19 = strlen(Str);
            sub_180002B40(&v25, Str, v19);
            _RDX = *(_QWORD *)(v4 + 8);
            if ( _RDX == *(_QWORD *)(v4 + 16) )
            {
              sub_180006EC0(v4, _RDX, (__int64)&v25);
              v22 = *(_QWORD *)&v25.m256_f32[6];
            }
            else
            {
              __asm
              {
                vmovups ymm0, [rsp+0B8h+var_80]
                vmovups ymmword ptr [rdx], ymm0
              }
              v22 = 15;
              LOBYTE(v25.m256_f32[0]) = 0;
              *(_QWORD *)(v4 + 8) += 32LL;
            }
            if ( v22 > 0xF )
            {
              v23 = *(void **)v25.m256_f32;
              if ( v22 + 1 >= 0x1000 )
              {
                if ( (unsigned __int64)(*(_QWORD *)v25.m256_f32 - *(_QWORD *)(*(_QWORD *)v25.m256_f32 - 8LL) - 8LL) > 0x1F )
                  __fastfail(5u);
                v23 = *(void **)(*(_QWORD *)v25.m256_f32 - 8LL);
              }
              __asm { vzeroupper }
              j_j_free(v23);
            }
          }
          ++v11;
        }
        while ( v11 < v12 );
      }
    }
  }
  __asm { vzeroupper }
  return v4;
}

//----- (00000001800046E0) ----------------------------------------------------
bool __fastcall sub_1800046E0(__int64 a1, __int64 a2)
{
  SOCKET v6; // rax
  u_short v7; // ax
  bool v8; // cc
  const CHAR *v9; // rdx
  SEC_CHAR *v12; // r8
  SECURITY_STATUS v13; // eax
  SECURITY_STATUS v14; // ebx
  char *v15; // rdx
  int v16; // eax
  SEC_CHAR *v17; // r8
  int len; // [rsp+60h] [rbp-A0h] BYREF
  int v20; // [rsp+64h] [rbp-9Ch]
  char *buf; // [rsp+68h] [rbp-98h]
  struct _SecBufferDesc pOutput; // [rsp+70h] [rbp-90h] BYREF
  struct _SecBufferDesc pInput; // [rsp+80h] [rbp-80h] BYREF
  unsigned int pfContextAttr; // [rsp+90h] [rbp-70h] BYREF
  SECURITY_INTEGER ptsExpiry; // [rsp+98h] [rbp-68h] BYREF
  struct sockaddr name; // [rsp+A0h] [rbp-60h] BYREF
  __m256 pAuthData; // [rsp+B0h] [rbp-50h] BYREF
  _OWORD v28[3]; // [rsp+D0h] [rbp-30h]
  _DWORD v29[2]; // [rsp+100h] [rbp+0h] BYREF
  char *v30; // [rsp+108h] [rbp+8h]
  int v31; // [rsp+114h] [rbp+14h]
  char v32[4096]; // [rsp+120h] [rbp+20h] BYREF

  v6 = socket(2, 1, 6);
  *(_QWORD *)a1 = v6;
  if ( v6 == -1 )
    return 0;
  name.sa_family = 2;
  v7 = htons(0x355u);
  v8 = *(_QWORD *)(a2 + 24) <= 0xFu;
  v9 = (const CHAR *)a2;
  *(_WORD *)name.sa_data = v7;
  if ( !v8 )
    v9 = *(const CHAR **)a2;
  inet_pton(2, v9, &name.sa_data[2]);
  if ( connect(*(_QWORD *)a1, &name, 16) )
    return 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  __asm { vmovups ymmword ptr [rbp+1060h+var_1090], ymm0 }
  v28[0] = *(_OWORD *)_RT0.m256i_i8;
  __asm
  {
    vmovups [rbp+1060h+var_10B0], ymm0
    vmovups ymmword ptr [rbp+1060h+var_1090+10h], ymm0
  }
  LODWORD(pAuthData.m256_f32[0]) = 4;
  DWORD2(v28[1]) = 10240;
  __asm { vzeroupper }
  if ( AcquireCredentialsHandleA(
         0,
         (LPSTR)"Microsoft Unified Security Protocol Provider",
         2u,
         0,
         &pAuthData,
         0,
         0,
         (PCredHandle)(a1 + 8),
         &ptsExpiry) )
  {
    return 0;
  }
  *(_BYTE *)(a1 + 40) = 1;
  v8 = *(_QWORD *)(a2 + 24) <= 0xFu;
  v12 = (SEC_CHAR *)a2;
  pOutput.pBuffers = (PSecBuffer)&len;
  buf = 0;
  v20 = 2;
  len = 0;
  pOutput.cBuffers = 1;
  pOutput.ulVersion = 0;
  if ( !v8 )
    v12 = *(SEC_CHAR **)a2;
  v13 = InitializeSecurityContextA(
          (PCredHandle)(a1 + 8),
          0,
          v12,
          0x811Cu,
          0,
          0,
          0,
          0,
          (PCtxtHandle)(a1 + 24),
          &pOutput,
          &pfContextAttr,
          &ptsExpiry);
  v14 = v13;
  if ( v13 != 590610 )
  {
    if ( v13 )
      return 0;
  }
  v15 = buf;
  *(_BYTE *)(a1 + 41) = 1;
  if ( v15 && len )
  {
    send(*(_QWORD *)a1, v15, len, 0);
    FreeContextBuffer(buf);
  }
  do
  {
    if ( v14 != 590610 && v14 != -2146893032 && v14 != 590624 )
      break;
    v16 = recv(*(_QWORD *)a1, v32, 4096, 0);
    if ( v16 <= 0 )
      return 0;
    v8 = *(_QWORD *)(a2 + 24) <= 0xFu;
    v29[0] = v16;
    pInput.pBuffers = (PSecBuffer)v29;
    pOutput.pBuffers = (PSecBuffer)&len;
    v30 = v32;
    v29[1] = 2;
    v31 = 0;
    pInput.cBuffers = 2;
    pInput.ulVersion = 0;
    buf = 0;
    v20 = 2;
    len = 0;
    pOutput.cBuffers = 1;
    v17 = v8 ? (SEC_CHAR *)a2 : *(SEC_CHAR **)a2;
    v14 = InitializeSecurityContextA(
            (PCredHandle)(a1 + 8),
            (PCtxtHandle)(a1 + 24),
            v17,
            0x811Cu,
            0,
            0,
            &pInput,
            0,
            (PCtxtHandle)(a1 + 24),
            &pOutput,
            &pfContextAttr,
            &ptsExpiry);
    if ( v14 == -2146893032 )
      return 0;
    if ( buf )
    {
      if ( len )
      {
        send(*(_QWORD *)a1, buf, len, 0);
        FreeContextBuffer(buf);
      }
    }
  }
  while ( v14 );
  return v14 == 0;
}

//----- (0000000180004A00) ----------------------------------------------------
bool __fastcall sub_180004A00(__int64 a1, _QWORD *a2)
{
  char *v5; // rax
  size_t v6; // rcx
  char *v7; // rax
  const void *v8; // rdx
  size_t v9; // r8
  char *v10; // rax
  SECURITY_STATUS v11; // edi
  struct _SecBufferDesc pMessage; // [rsp+20h] [rbp-39h] BYREF
  unsigned int pBuffer; // [rsp+30h] [rbp-29h] BYREF
  size_t Size; // [rsp+34h] [rbp-25h]
  int len[2]; // [rsp+50h] [rbp-9h] BYREF
  char *buf; // [rsp+58h] [rbp-1h]
  int v17; // [rsp+60h] [rbp+7h]
  int v18; // [rsp+64h] [rbp+Bh]
  char *v19; // [rsp+68h] [rbp+Fh]
  int v20; // [rsp+70h] [rbp+17h]
  int v21; // [rsp+74h] [rbp+1Bh]
  char *v22; // [rsp+78h] [rbp+1Fh]
  int v23; // [rsp+84h] [rbp+2Bh]

  if ( QueryContextAttributesW((PCtxtHandle)(a1 + 24), 4u, &pBuffer) )
    return 0;
  v5 = (char *)malloc(pBuffer);
  v6 = a2[1] - *a2;
  buf = v5;
  len[0] = pBuffer;
  len[1] = 7;
  v7 = (char *)malloc(v6);
  v8 = (const void *)*a2;
  v9 = a2[1] - *a2;
  v19 = v7;
  memcpy(v7, v8, v9);
  v17 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
  v18 = 1;
  v10 = (char *)malloc((unsigned int)Size);
  v21 = 6;
  v22 = v10;
  v20 = Size;
  pMessage.cBuffers = 4;
  v23 = 0;
  pMessage.ulVersion = 0;
  pMessage.pBuffers = (PSecBuffer)len;
  v11 = EncryptMessage((PCtxtHandle)(a1 + 24), 0, &pMessage, 0);
  if ( !v11 )
  {
    send(*(_QWORD *)a1, buf, len[0], 0);
    send(*(_QWORD *)a1, v19, v17, 0);
    send(*(_QWORD *)a1, v22, v20, 0);
  }
  free(buf);
  free(v19);
  free(v22);
  return v11 == 0;
}

//----- (0000000180004B60) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
__int64 __fastcall sub_180004B60(__int64 a1, _QWORD *_RDX)
{
  __int64 v3; // rbx
  unsigned int v6; // edi
  int v7; // eax
  SECURITY_STATUS v8; // eax
  struct _SecBufferDesc pMessage; // [rsp+30h] [rbp-D0h] BYREF
  unsigned int v11; // [rsp+40h] [rbp-C0h] BYREF
  int v12; // [rsp+44h] [rbp-BCh]
  char *v13; // [rsp+48h] [rbp-B8h]
  unsigned int v14; // [rsp+50h] [rbp-B0h]
  int v15; // [rsp+54h] [rbp-ACh]
  const void *v16; // [rsp+58h] [rbp-A8h]
  unsigned int v17; // [rsp+60h] [rbp-A0h]
  int v18; // [rsp+64h] [rbp-9Ch]
  const void *v19; // [rsp+68h] [rbp-98h]
  unsigned int v20; // [rsp+70h] [rbp-90h]
  int v21; // [rsp+74h] [rbp-8Ch]
  const void *v22; // [rsp+78h] [rbp-88h]
  char v23[4096]; // [rsp+80h] [rbp-80h] BYREF

  v3 = (__int64)_RDX;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups xmmword ptr [rdx], xmm0
  }
  *_RDX = 0;
  _RDX[1] = 0;
  _RDX[2] = 0;
  v6 = 0;
  while ( 1 )
  {
    v7 = recv(*(_QWORD *)a1, &v23[v6], 4096 - v6, 0);
    if ( v7 <= 0 )
      break;
    v6 += v7;
    v13 = v23;
    v11 = v6;
    v12 = 1;
    v15 = 0;
    v18 = 0;
    v21 = 0;
    pMessage.ulVersion = 0;
    pMessage.cBuffers = 4;
    pMessage.pBuffers = (PSecBuffer)&v11;
    v8 = DecryptMessage((PCtxtHandle)(a1 + 24), &pMessage, 0, 0);
    if ( v8 != -2146893032 )
    {
      if ( !v8 )
      {
        if ( v12 == 1 )
          sub_180006600(v3, *(_BYTE **)(v3 + 8), v13, v11);
        if ( v15 == 1 )
          sub_180006600(v3, *(_BYTE **)(v3 + 8), v16, v14);
        if ( v18 == 1 )
          sub_180006600(v3, *(_BYTE **)(v3 + 8), v19, v17);
        if ( v21 == 1 )
          sub_180006600(v3, *(_BYTE **)(v3 + 8), v22, v20);
      }
      return v3;
    }
  }
  return v3;
}

//----- (0000000180004D00) ----------------------------------------------------
// Hidden C++ exception states: #wind=3
_QWORD *__fastcall sub_180004D00(_QWORD *a1, char *a2, const CHAR *a3)
{
  SOCKET v7; // r15
  _QWORD *result; // rax
  char *v12; // rdx
  char *v13; // rcx
  void *v15; // rcx
  char *v16; // rcx
  void *v18; // rcx
  size_t v19; // r13
  char *v21; // rsi
  size_t v22; // rcx
  void *v23; // rax
  _QWORD *v24; // rbx
  int i; // r14d
  int v26; // eax
  void *v27; // rcx
  char *v28; // rcx
  void *v30; // rcx
  __int64 v32; // rdx
  __int64 v33; // rcx
  __int64 v34; // rax
  void *v35; // rcx
  char *v36; // rcx
  void *v38; // rcx
  _QWORD *v39; // rax
  _BYTE v40[8]; // [rsp+30h] [rbp-D8h] BYREF
  char *buf[2]; // [rsp+38h] [rbp-D0h] BYREF
  char *v42; // [rsp+48h] [rbp-C0h]
  void *Block[2]; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v44; // [rsp+60h] [rbp-A8h]
  void *v45[2]; // [rsp+68h] [rbp-A0h] BYREF
  char *v46; // [rsp+78h] [rbp-90h]
  _QWORD *v47; // [rsp+80h] [rbp-88h]
  char v48; // [rsp+8Ch] [rbp-7Ch] BYREF
  unsigned __int8 v49; // [rsp+8Dh] [rbp-7Bh]
  char optval[8]; // [rsp+90h] [rbp-78h] BYREF
  __int128 v51; // [rsp+98h] [rbp-70h] BYREF
  __int64 v52; // [rsp+A8h] [rbp-60h]
  struct sockaddr name; // [rsp+B0h] [rbp-58h] BYREF

  v47 = a1;
  v7 = socket(2, 1, 6);
  if ( v7 == -1 )
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    return a1;
  }
  name.sa_family = 2;
  *(_WORD *)name.sa_data = htons(0x35u);
  if ( *((_QWORD *)a3 + 3) > 0xFu )
    a3 = *(const CHAR **)a3;
  inet_pton(2, a3, &name.sa_data[2]);
  *(_DWORD *)optval = 2000;
  setsockopt(v7, 0xFFFF, 4102, optval, 4);
  setsockopt(v7, 0xFFFF, 4101, optval, 4);
  if ( connect(v7, &name, 16) )
  {
    closesocket(v7);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    return a1;
  }
  __asm { vpxor   xmm0, xmm0, xmm0 }
  __asm { vmovups xmmword ptr [rsp+108h+Block], xmm0 }
  v44 = 0;
  try
  {
    sub_180003F50(Block, a2);
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovdqu xmmword ptr [rsp+108h+buf], xmm0
    }
    v42 = 0;
    v40[0] = (unsigned __int16)(LOWORD(Block[1]) - LOWORD(Block[0])) >> 8;
    sub_180006CE0(buf, 0, v40);
    v40[0] = LOBYTE(Block[1]) - LOBYTE(Block[0]);
    if ( buf[1] == v42 )
    {
      sub_180006CE0(buf, buf[1], v40);
      v12 = buf[1];
    }
    else
    {
      *buf[1] = LOBYTE(Block[1]) - LOBYTE(Block[0]);
      v12 = ++buf[1];
    }
    sub_180006600((__int64)buf, v12, Block[0], (char *)Block[1] - (char *)Block[0]);
    if ( send(v7, buf[0], LODWORD(buf[1]) - LODWORD(buf[0]), 0) <= 0 )
    {
      closesocket(v7);
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
      if ( buf[0] )
      {
        if ( (unsigned __int64)(v42 - buf[0]) < 0x1000 )
        {
          v13 = buf[0];
        }
        else
        {
          v13 = (char *)*((_QWORD *)buf[0] - 1);
          if ( (unsigned __int64)(buf[0] - v13 - 8) > 0x1F )
            goto LABEL_79;
        }
        j_j_free(v13);
        __asm
        {
          vpxor   xmm0, xmm0, xmm0
          vmovdqu xmmword ptr [rsp+108h+buf], xmm0
        }
        v42 = 0;
      }
      if ( Block[0] )
      {
        if ( v44 - (unsigned __int64)Block[0] < 0x1000 )
        {
          v15 = Block[0];
        }
        else
        {
          v15 = (void *)*((_QWORD *)Block[0] - 1);
          if ( (unsigned __int64)((char *)Block[0] - (char *)v15 - 8) > 0x1F )
            goto LABEL_85;
        }
        j_j_free(v15);
      }
      return a1;
    }
    if ( recv(v7, &v48, 2, 0) != 2 )
    {
      closesocket(v7);
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
      if ( buf[0] )
      {
        if ( (unsigned __int64)(v42 - buf[0]) < 0x1000 )
        {
          v16 = buf[0];
        }
        else
        {
          v16 = (char *)*((_QWORD *)buf[0] - 1);
          if ( (unsigned __int64)(buf[0] - v16 - 8) > 0x1F )
            goto LABEL_79;
        }
        j_j_free(v16);
        __asm
        {
          vpxor   xmm0, xmm0, xmm0
          vmovdqu xmmword ptr [rsp+108h+buf], xmm0
        }
        v42 = 0;
      }
      if ( Block[0] )
      {
        if ( v44 - (unsigned __int64)Block[0] < 0x1000 )
        {
          v18 = Block[0];
        }
        else
        {
          v18 = (void *)*((_QWORD *)Block[0] - 1);
          if ( (unsigned __int64)((char *)Block[0] - (char *)v18 - 8) > 0x1F )
            goto LABEL_85;
        }
        j_j_free(v18);
      }
      return a1;
    }
    v19 = v49 | ((unsigned __int8)v48 << 8);
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovdqu xmmword ptr [rsp+108h+var_A0], xmm0
    }
    v21 = 0;
    v46 = 0;
    if ( v49 | ((unsigned __int8)v48 << 8) )
    {
      if ( v19 < 0x1000 )
      {
        v24 = sub_18000E800(v49 | ((unsigned __int8)v48 << 8));
      }
      else
      {
        v22 = (v49 | ((unsigned __int8)v48 << 8)) + 39LL;
        if ( v22 <= v19 )
          Concurrency::cancel_current_task();
        v23 = sub_18000E800(v22);
        if ( !v23 )
          goto LABEL_73;
        v24 = (_QWORD *)(((unsigned __int64)v23 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
        *(v24 - 1) = v23;
      }
      v45[0] = v24;
      v21 = (char *)v24 + v19;
      v46 = (char *)v24 + v19;
      memset(v24, 0, v19);
      v45[1] = (char *)v24 + v19;
    }
    else
    {
      v24 = v45[0];
    }
    for ( i = 0; ; i += v26 )
    {
      if ( i >= (int)v19 )
      {
        closesocket(v7);
        __asm { vpxor   xmm0, xmm0, xmm0 }
        __asm { vmovups [rsp+108h+var_70], xmm0 }
        v52 = 0;
        sub_180004420(&v51, (__int64 *)v45);
        v32 = v52;
        v52 = 0;
        v33 = *((_QWORD *)&v51 + 1);
        v34 = v51;
        v51 = 0u;
        *a1 = v34;
        a1[1] = v33;
        a1[2] = v32;
        sub_180002C40((__int64)&v51);
        if ( v45[0] )
        {
          if ( (unsigned __int64)(v46 - (char *)v45[0]) < 0x1000 )
          {
            v35 = v45[0];
          }
          else
          {
            v35 = (void *)*((_QWORD *)v45[0] - 1);
            if ( (unsigned __int64)((char *)v45[0] - (char *)v35 - 8) > 0x1F )
              goto LABEL_73;
          }
          j_j_free(v35);
        }
        if ( buf[0] )
        {
          if ( (unsigned __int64)(v42 - buf[0]) < 0x1000 )
          {
            v36 = buf[0];
          }
          else
          {
            v36 = (char *)*((_QWORD *)buf[0] - 1);
            if ( (unsigned __int64)(buf[0] - v36 - 8) > 0x1F )
              goto LABEL_79;
          }
          j_j_free(v36);
          __asm
          {
            vpxor   xmm0, xmm0, xmm0
            vmovdqu xmmword ptr [rsp+108h+buf], xmm0
          }
          v42 = 0;
        }
        if ( Block[0] )
        {
          if ( v44 - (unsigned __int64)Block[0] < 0x1000 )
          {
            v38 = Block[0];
          }
          else
          {
            v38 = (void *)*((_QWORD *)Block[0] - 1);
            if ( (unsigned __int64)((char *)Block[0] - (char *)v38 - 8) > 0x1F )
              goto LABEL_85;
          }
          j_j_free(v38);
        }
        return a1;
      }
      v26 = recv(v7, (char *)v24 + i, v19 - i, 0);
      if ( v26 <= 0 )
        break;
    }
    closesocket(v7);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    if ( !v24 )
      goto LABEL_56;
    if ( (unsigned __int64)(v21 - (char *)v24) < 0x1000 )
    {
      v27 = v24;
      goto LABEL_55;
    }
    v27 = (void *)*(v24 - 1);
    if ( (unsigned __int64)((char *)v24 - (_BYTE *)v27 - 8) <= 0x1F )
    {
LABEL_55:
      j_j_free(v27);
LABEL_56:
      if ( buf[0] )
      {
        if ( (unsigned __int64)(v42 - buf[0]) < 0x1000 )
        {
          v28 = buf[0];
          goto LABEL_61;
        }
        v28 = (char *)*((_QWORD *)buf[0] - 1);
        if ( (unsigned __int64)(buf[0] - v28 - 8) <= 0x1F )
        {
LABEL_61:
          j_j_free(v28);
          __asm
          {
            vpxor   xmm0, xmm0, xmm0
            vmovdqu xmmword ptr [rsp+108h+buf], xmm0
          }
          v42 = 0;
          goto LABEL_62;
        }
LABEL_79:
        __fastfail(5u);
      }
LABEL_62:
      if ( Block[0] )
      {
        if ( v44 - (unsigned __int64)Block[0] < 0x1000 )
        {
          v30 = Block[0];
          goto LABEL_67;
        }
        v30 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)((char *)Block[0] - (char *)v30 - 8) <= 0x1F )
        {
LABEL_67:
          j_j_free(v30);
          return a1;
        }
LABEL_85:
        __fastfail(5u);
      }
      return a1;
    }
LABEL_73:
    __fastfail(5u);
  }
  catch ( ... )
  {
    v39 = v47;
    *v47 = 0;
    v39[1] = 0;
    v39[2] = 0;
    return v47;
  }
  return result;
}

//----- (00000001800053A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=23
unsigned __int64 *__fastcall sub_1800053A0(unsigned __int64 *a1, const void **a2, unsigned __int64 *a3)
{
  __int64 v8; // rcx
  __int64 v9; // rbx
  ULONGLONG TickCount64; // rax
  __int64 v11; // rcx
  ULONGLONG v12; // rdx
  _QWORD *v18; // rbx
  _QWORD *v20; // rbx
  __int128 v25; // kr00_16
  __int64 v27; // rcx
  __int64 v28; // rbx
  unsigned __int64 v29; // rax
  __int128 v30; // [rsp+40h] [rbp-C0h] BYREF
  unsigned __int64 v31[4]; // [rsp+50h] [rbp-B0h] BYREF
  unsigned __int64 v32[4]; // [rsp+70h] [rbp-90h] BYREF
  _Thrd_t v33; // [rsp+90h] [rbp-70h] BYREF
  __int128 v34; // [rsp+A0h] [rbp-60h] BYREF
  unsigned __int64 v35; // [rsp+B0h] [rbp-50h]
  __int64 v36[3]; // [rsp+B8h] [rbp-48h] BYREF
  unsigned int v37[4]; // [rsp+D0h] [rbp-30h] BYREF
  unsigned int ThrdAddr[4]; // [rsp+E0h] [rbp-20h] BYREF
  __int128 v39; // [rsp+F0h] [rbp-10h] BYREF
  __int64 v40; // [rsp+100h] [rbp+0h]
  ULONGLONG v41; // [rsp+108h] [rbp+8h]
  char *v42; // [rsp+110h] [rbp+10h]
  char *v43; // [rsp+118h] [rbp+18h]

  v36[0] = (__int64)a1;
  v33._Hnd = &unk_1800170F0;
  if ( Mtx_lock((_Mtx_t)&unk_1800170F0) )
  {
    std::_Throw_Cpp_error(5);
    __debugbreak();
  }
  if ( dword_18001713C == 0x7FFFFFFF )
  {
    dword_18001713C = 2147483646;
    std::_Throw_Cpp_error(6);
  }
  v36[0] = 0;
  sub_1800063A0(v8, v36, a2);
  v9 = v36[0];
  if ( v36[0] != qword_180017528 )
  {
    TickCount64 = GetTickCount64();
    v12 = *(_QWORD *)(v9 + 88);
    if ( TickCount64 >= v12 && TickCount64 - v12 < 0x36EE80 )
    {
      sub_180006540(a1, (unsigned __int64 **)(v9 + 64));
      Mtx_unlock((_Mtx_t)&unk_1800170F0);
      return a1;
    }
    sub_180006220(v11, &v33, (_QWORD *)v9);
  }
  Mtx_unlock((_Mtx_t)&unk_1800170F0);
  _RDI = (char *)sub_18000E800(0x80u);
  v33._Hnd = _RDI;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups xmmword ptr [rax], xmm0
  }
  *((_DWORD *)_RDI + 2) = 1;
  *((_DWORD *)_RDI + 3) = 1;
  *(_QWORD *)_RDI = ___7___Ref_count_obj2_URaceResult__1__resolveDnsFastest__YA_AV__vector_V__basic_string_DU__char_traits_D_std__V__allocator_D_2__std__V__allocator_V__basic_string_DU__char_traits_D_std__V__allocator_D_2__std___2__std__AEBV__basic_string_DU__char_traits_D_std__V__allocator_D_2__4_0_Z__std__6B_;
  _R14 = (__int128 *)(_RDI + 16);
  *((_QWORD *)_RDI + 5) = 2;
  *(_DWORD *)(_RDI + 121) = 0;
  *(_WORD *)(_RDI + 125) = 0;
  _RDI[127] = 0;
  *((_QWORD *)_RDI + 2) = 0;
  *((_QWORD *)_RDI + 3) = 0;
  *((_QWORD *)_RDI + 4) = 0;
  __asm
  {
    vmovups ymmword ptr [r14+30h], ymm0
    vmovups ymmword ptr [r14+40h], ymm0
  }
  *((_QWORD *)_RDI + 6) = 0;
  *((_QWORD *)_RDI + 7) = 0;
  *((_DWORD *)_RDI + 28) = -1;
  *((_DWORD *)_RDI + 29) = 0;
  _RDI[120] = 0;
  __asm { vmovups [rbp+60h+var_50], xmm0 }
  v42 = _RDI + 16;
  v43 = _RDI;
  _InterlockedIncrement((volatile signed __int32 *)_RDI + 2);
  *(_QWORD *)&v30 = _RDI + 16;
  *((_QWORD *)&v30 + 1) = _RDI;
  __asm { vzeroupper }
  sub_180002860(v31, (unsigned __int64 *)a2);
  sub_180002860(v32, a3);
  v18 = sub_18000E800(0x50u);
  v33._Hnd = v18;
  v36[0] = (__int64)v18;
  *(_OWORD *)v18 = v30;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu [rsp+160h+var_120], xmm0
  }
  sub_180002860(v18 + 2, v31);
  sub_180002860(v18 + 6, v32);
  v33._Hnd = v18;
  *(_QWORD *)ThrdAddr = beginthreadex(0, 0, (_beginthreadex_proc_type)StartAddress, v18, 0, &ThrdAddr[2]);
  if ( !*(_QWORD *)ThrdAddr )
  {
LABEL_45:
    ThrdAddr[2] = 0;
    std::_Throw_Cpp_error(6);
    JUMPOUT(0x18000591DLL);
  }
  sub_1800060C0(&v30);
  _InterlockedIncrement((volatile signed __int32 *)_RDI + 2);
  *(_QWORD *)&v30 = _RDI + 16;
  *((_QWORD *)&v30 + 1) = _RDI;
  sub_180002860(v31, (unsigned __int64 *)a2);
  sub_180002860(v32, a3);
  v20 = sub_18000E800(0x50u);
  v33._Hnd = v20;
  v36[0] = (__int64)v20;
  *(_OWORD *)v20 = v30;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu [rsp+160h+var_120], xmm0
  }
  sub_180002860(v20 + 2, v31);
  sub_180002860(v20 + 6, v32);
  v33._Hnd = v20;
  *(_QWORD *)v37 = beginthreadex(0, 0, (_beginthreadex_proc_type)sub_180006CA0, v20, 0, &v37[2]);
  if ( !*(_QWORD *)v37 )
  {
    v37[2] = 0;
    std::_Throw_Cpp_error(6);
    goto LABEL_45;
  }
  sub_1800060C0(&v30);
  if ( ThrdAddr[2] )
  {
    if ( ThrdAddr[2] == Thrd_id() )
      goto LABEL_19;
    __asm
    {
      vmovups xmm0, xmmword ptr [rbp+60h+var_80]
      vmovdqa xmmword ptr [rbp+60h+var_D0._Hnd], xmm0
    }
    if ( Thrd_join(&v33, 0) )
      goto LABEL_21;
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovdqa xmmword ptr [rbp+60h+var_80], xmm0
    }
  }
  if ( v37[2] )
  {
    if ( v37[2] == Thrd_id() )
    {
LABEL_19:
      std::_Throw_Cpp_error(5);
      __debugbreak();
    }
    __asm
    {
      vmovups xmm0, xmmword ptr [rbp+60h+var_90]
      vmovdqa xmmword ptr [rbp+60h+var_D0._Hnd], xmm0
    }
    if ( Thrd_join(&v33, 0) )
    {
LABEL_21:
      std::_Throw_Cpp_error(2);
      __debugbreak();
    }
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovdqa xmmword ptr [rbp+60h+var_90], xmm0
    }
  }
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu [rbp+60h+var_C0], xmm0
  }
  v35 = 0;
  v33._Hnd = _RDI + 40;
  if ( Mtx_lock((_Mtx_t)(_RDI + 40)) )
  {
    std::_Throw_Cpp_error(5);
    __debugbreak();
  }
  if ( *((_DWORD *)_RDI + 29) == 0x7FFFFFFF )
  {
    *((_DWORD *)_RDI + 29) = 2147483646;
    std::_Throw_Cpp_error(6);
  }
  if ( &v34 != _R14 )
    sub_1800069E0(
      (__int64)&v34,
      *((unsigned __int64 **)_RDI + 2),
      (__int64)(*((_QWORD *)_RDI + 3) - *((_QWORD *)_RDI + 2)) >> 5);
  Mtx_unlock((_Mtx_t)(_RDI + 40));
  v25 = v34;
  if ( (_QWORD)v34 != *((_QWORD *)&v34 + 1) )
  {
    v33._Hnd = &unk_1800170F0;
    if ( Mtx_lock((_Mtx_t)&unk_1800170F0) )
    {
      std::_Throw_Cpp_error(5);
      __debugbreak();
    }
    if ( dword_18001713C == 0x7FFFFFFF )
    {
      dword_18001713C = 2147483646;
      std::_Throw_Cpp_error(6);
    }
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovdqu [rbp+60h+var_70], xmm0
    }
    v40 = 0;
    sub_1800069E0((__int64)&v39, (unsigned __int64 *)v34, (__int64)(*((_QWORD *)&v34 + 1) - v34) >> 5);
    v41 = GetTickCount64();
    v28 = *(_QWORD *)sub_180006830(v27, (__int64)v36, (unsigned __int64 *)a2) + 64LL;
    if ( (__int128 *)v28 != &v39 )
      sub_1800069E0(v28, (unsigned __int64 *)v39, (__int64)(*((_QWORD *)&v39 + 1) - v39) >> 5);
    *(_QWORD *)(v28 + 24) = v41;
    sub_180002C40((__int64)&v39);
    Mtx_unlock((_Mtx_t)&unk_1800170F0);
    v25 = v34;
  }
  v29 = v35;
  v35 = 0;
  v34 = 0u;
  *(_OWORD *)a1 = v25;
  a1[2] = v29;
  sub_180002C40((__int64)&v34);
  if ( v37[2] )
    terminate();
  if ( ThrdAddr[2] )
    terminate();
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)_RDI + 2, 0xFFFFFFFF) == 1 )
  {
    (**(void (__fastcall ***)(void *))_RDI)(_RDI);
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)_RDI + 3, 0xFFFFFFFF) == 1 )
      (*(void (__fastcall **)(char *))(*(_QWORD *)_RDI + 8LL))(_RDI);
  }
  return a1;
}
// 180005917: control flows out of bounds to 18000591D
// 18000542A: variable 'v8' is possibly undefined
// 18000549D: variable 'v11' is possibly undefined
// 180005828: variable 'v27' is possibly undefined
// 1800060C0: using guessed type __int64 __fastcall sub_1800060C0(_QWORD);
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);
// 180011330: using guessed type void __noreturn terminate(void);
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 180013E30: using guessed type __int64 (__fastcall *___7___Ref_count_obj2_URaceResult__1__resolveDnsFastest__YA_AV__vector_V__basic_string_DU__char_traits_D_std__V__allocator_D_2__std__V__allocator_V__basic_string_DU__char_traits_D_std__V__allocator_D_2__std___2__std__AEBV__basic_string_DU__char_traits_D_std__V__allocator_D_2__4_0_Z__std__6B_[4])();
// 18001713C: using guessed type int dword_18001713C;
// 180017528: using guessed type __int64 qword_180017528;

//----- (0000000180005920) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
void __fastcall sub_180005920(__int64 a1)
{
  __int64 v4; // rbx
  __int128 *v5; // rcx
  __int128 v6; // [rsp+20h] [rbp-28h] BYREF
  __int64 v7; // [rsp+30h] [rbp-18h]
  __int64 v8; // [rsp+38h] [rbp-10h]

  __asm { vpxor   xmm0, xmm0, xmm0 }
  __asm { vmovups [rsp+48h+var_28], xmm0 }
  v7 = 0;
  try
  {
    sub_180004D00(&v6, (char *)(a1 + 16), (const CHAR *)(a1 + 48));
    if ( (_QWORD)v6 != *((_QWORD *)&v6 + 1) )
    {
      v4 = *(_QWORD *)a1 + 24LL;
      v8 = v4;
      if ( Mtx_lock((_Mtx_t)v4) )
        std::_Throw_Cpp_error(5);
      if ( *(_DWORD *)(v4 + 76) == 0x7FFFFFFF )
      {
        *(_DWORD *)(v4 + 76) = 2147483646;
        std::_Throw_Cpp_error(6);
      }
      v5 = *(__int128 **)a1;
      if ( !*(_BYTE *)(*(_QWORD *)a1 + 104LL) )
      {
        if ( v5 != &v6 )
          sub_1800069E0((__int64)v5, (unsigned __int64 *)v6, (__int64)(*((_QWORD *)&v6 + 1) - v6) >> 5);
        *(_BYTE *)(*(_QWORD *)a1 + 104LL) = 1;
      }
      Mtx_unlock((_Mtx_t)v4);
    }
    sub_180002C40((__int64)&v6);
  }
  catch ( ... )
  {
  }
}
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);

//----- (00000001800059F0) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
// Hidden C++ exception states: #wind=7
void __fastcall sub_1800059F0(char *a1, double _XMM1_8)
{
  _BYTE *v9; // rdx
  void *v10; // rcx
  void *v11; // rcx
  void *v14; // rax
  void *v15; // rcx
  void *v16; // rcx
  char *v19; // r14
  size_t v20; // rdi
  void *v21; // rax
  void *v22; // rcx
  _QWORD *v23; // rax
  char *v24; // rbx
  __int64 v26; // rbx
  __int128 *v27; // rcx
  void *v28; // rcx
  void *v29; // rcx
  void *v30; // rcx
  void *v31; // rcx
  _BYTE v33[8]; // [rsp+20h] [rbp-D8h] BYREF
  void *Block[2]; // [rsp+28h] [rbp-D0h] BYREF
  void *v35; // [rsp+38h] [rbp-C0h]
  void *v36[2]; // [rsp+40h] [rbp-B8h] BYREF
  __int64 v37; // [rsp+50h] [rbp-A8h]
  void *v38[2]; // [rsp+58h] [rbp-A0h] BYREF
  __int64 v39; // [rsp+68h] [rbp-90h]
  void *v40[2]; // [rsp+70h] [rbp-88h] BYREF
  char *v41; // [rsp+80h] [rbp-78h]
  __int64 v42; // [rsp+88h] [rbp-70h]
  SOCKET s; // [rsp+90h] [rbp-68h] BYREF
  struct _SecHandle phCredential; // [rsp+98h] [rbp-60h] BYREF
  struct _SecHandle phContext; // [rsp+A8h] [rbp-50h] BYREF
  __int16 v46; // [rsp+B8h] [rbp-40h]
  __int128 v47; // [rsp+C0h] [rbp-38h] BYREF
  __int64 v48; // [rsp+D0h] [rbp-28h]
  _UNKNOWN *retaddr; // [rsp+F8h] [rbp+0h] BYREF

  _R11 = &retaddr;
  s = -1;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups xmmword ptr [r11-60h], xmm0
    vpxor   xmm1, xmm1, xmm1
    vmovups xmmword ptr [r11-50h], xmm1
  }
  v46 = 0;
  if ( !sub_1800046E0((__int64)&s, (__int64)(a1 + 48)) )
  {
    if ( HIBYTE(v46) )
      DeleteSecurityContext(&phContext);
    if ( (_BYTE)v46 )
      FreeCredentialsHandle(&phCredential);
    if ( s != -1 )
      closesocket(s);
    return;
  }
  __asm { vpxor   xmm0, xmm0, xmm0 }
  __asm { vmovups xmmword ptr [rsp+0F8h+var_B8], xmm0 }
  v37 = 0;
  try
  {
    sub_180003F50(v36, a1 + 16);
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovdqu xmmword ptr [rsp+0F8h+Block], xmm0
    }
    v35 = 0;
    v33[0] = (unsigned __int16)(LOWORD(v36[1]) - LOWORD(v36[0])) >> 8;
    sub_180006CE0(Block, 0, v33);
    v33[0] = LOBYTE(v36[1]) - LOBYTE(v36[0]);
    if ( Block[1] == v35 )
    {
      sub_180006CE0(Block, (_BYTE *)Block[1], v33);
      v9 = Block[1];
    }
    else
    {
      *(_BYTE *)Block[1] = LOBYTE(v36[1]) - LOBYTE(v36[0]);
      v9 = ++Block[1];
    }
    sub_180006600((__int64)Block, v9, v36[0], (char *)v36[1] - (char *)v36[0]);
    if ( !sub_180004A00((__int64)&s, Block) )
    {
      if ( !Block[0] )
      {
LABEL_20:
        if ( !v36[0] )
        {
LABEL_26:
          if ( HIBYTE(v46) )
            DeleteSecurityContext(&phContext);
          if ( (_BYTE)v46 )
            FreeCredentialsHandle(&phCredential);
          if ( s != -1 )
            closesocket(s);
          return;
        }
        if ( v37 - (unsigned __int64)v36[0] < 0x1000 )
        {
          v11 = v36[0];
LABEL_25:
          j_j_free(v11);
          __asm
          {
            vpxor   xmm0, xmm0, xmm0
            vmovdqu xmmword ptr [rsp+0F8h+var_B8], xmm0
          }
          v37 = 0;
          goto LABEL_26;
        }
        v11 = (void *)*((_QWORD *)v36[0] - 1);
        if ( (unsigned __int64)((char *)v36[0] - (char *)v11 - 8) <= 0x1F )
          goto LABEL_25;
LABEL_98:
        __fastfail(5u);
      }
      if ( (unsigned __int64)v35 - (unsigned __int64)Block[0] < 0x1000 )
      {
        v10 = Block[0];
LABEL_19:
        j_j_free(v10);
        __asm
        {
          vpxor   xmm0, xmm0, xmm0
          vmovdqu xmmword ptr [rsp+0F8h+Block], xmm0
        }
        v35 = 0;
        goto LABEL_20;
      }
      v10 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v10 - 8) <= 0x1F )
        goto LABEL_19;
LABEL_92:
      __fastfail(5u);
    }
    __asm { vpxor   xmm0, xmm0, xmm0 }
    __asm { vmovups xmmword ptr [rsp+0F8h+var_A0], xmm0 }
    v39 = 0;
    sub_180004B60((__int64)&s, v38);
    if ( (void *)((char *)v38[1] - (char *)v38[0]) < (void *)2 )
    {
      if ( !v38[0] )
        goto LABEL_40;
      if ( v39 - (unsigned __int64)v38[0] < 0x1000 )
      {
        v14 = v38[0];
LABEL_39:
        j_j_free(v14);
        __asm
        {
          vpxor   xmm0, xmm0, xmm0
          vmovdqu xmmword ptr [rsp+0F8h+var_A0], xmm0
        }
        v39 = 0;
LABEL_40:
        if ( Block[0] )
        {
          if ( (unsigned __int64)v35 - (unsigned __int64)Block[0] < 0x1000 )
          {
            v15 = Block[0];
          }
          else
          {
            v15 = (void *)*((_QWORD *)Block[0] - 1);
            if ( (unsigned __int64)((char *)Block[0] - (char *)v15 - 8) > 0x1F )
              goto LABEL_92;
          }
          j_j_free(v15);
          __asm
          {
            vpxor   xmm0, xmm0, xmm0
            vmovdqu xmmword ptr [rsp+0F8h+Block], xmm0
          }
          v35 = 0;
        }
        if ( v36[0] )
        {
          if ( v37 - (unsigned __int64)v36[0] < 0x1000 )
          {
            v16 = v36[0];
          }
          else
          {
            v16 = (void *)*((_QWORD *)v36[0] - 1);
            if ( (unsigned __int64)((char *)v36[0] - (char *)v16 - 8) > 0x1F )
              goto LABEL_98;
          }
          j_j_free(v16);
          __asm
          {
            vpxor   xmm0, xmm0, xmm0
            vmovdqu xmmword ptr [rsp+0F8h+var_B8], xmm0
          }
          v37 = 0;
        }
        if ( HIBYTE(v46) )
          DeleteSecurityContext(&phContext);
        if ( (_BYTE)v46 )
          FreeCredentialsHandle(&phCredential);
        if ( s != -1 )
          closesocket(s);
        return;
      }
      v14 = (void *)*((_QWORD *)v38[0] - 1);
      if ( (unsigned __int64)((char *)v38[0] - (char *)v14 - 8) <= 0x1F )
        goto LABEL_39;
LABEL_86:
      __fastfail(5u);
    }
    __asm { vpxor   xmm0, xmm0, xmm0 }
    v19 = (char *)v38[0] + 2;
    __asm { vmovdqu xmmword ptr [rsp+0F8h+var_88], xmm0 }
    v41 = 0;
    v20 = (char *)v38[1] - ((char *)v38[0] + 2);
    if ( v20 )
    {
      if ( v20 > 0x7FFFFFFFFFFFFFFFLL )
        sub_180003190();
      if ( v20 < 0x1000 )
      {
        v23 = sub_18000E800(v20);
      }
      else
      {
        if ( v20 + 39 < v20 )
          Concurrency::cancel_current_task();
        v21 = sub_18000E800(v20 + 39);
        v22 = v21;
        if ( !v21 )
LABEL_80:
          __fastfail(5u);
        v23 = (_QWORD *)(((unsigned __int64)v21 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
        *(v23 - 1) = v22;
      }
      v40[0] = v23;
      v24 = (char *)v23 + v20;
      v41 = (char *)v23 + v20;
      memmove(v23, v19, v20);
      v40[1] = v24;
    }
    __asm { vpxor   xmm0, xmm0, xmm0 }
    __asm { vmovups [rsp+0F8h+var_38], xmm0 }
    v48 = 0;
    sub_180004420(&v47, (__int64 *)v40);
    if ( (_QWORD)v47 != *((_QWORD *)&v47 + 1) )
    {
      v26 = *(_QWORD *)a1 + 24LL;
      v42 = v26;
      if ( Mtx_lock((_Mtx_t)v26) )
        std::_Throw_Cpp_error(5);
      if ( *(_DWORD *)(v26 + 76) == 0x7FFFFFFF )
      {
        *(_DWORD *)(v26 + 76) = 2147483646;
        std::_Throw_Cpp_error(6);
      }
      v27 = *(__int128 **)a1;
      if ( !*(_BYTE *)(*(_QWORD *)a1 + 104LL) )
      {
        if ( v27 != &v47 )
          sub_1800069E0((__int64)v27, (unsigned __int64 *)v47, (__int64)(*((_QWORD *)&v47 + 1) - v47) >> 5);
        *(_BYTE *)(*(_QWORD *)a1 + 104LL) = 1;
      }
      Mtx_unlock((_Mtx_t)v26);
    }
    sub_180002C40((__int64)&v47);
    if ( v40[0] )
    {
      if ( (unsigned __int64)(v41 - (char *)v40[0]) < 0x1000 )
      {
        v28 = v40[0];
      }
      else
      {
        v28 = (void *)*((_QWORD *)v40[0] - 1);
        if ( (unsigned __int64)((char *)v40[0] - (char *)v28 - 8) > 0x1F )
          goto LABEL_80;
      }
      j_j_free(v28);
    }
    if ( v38[0] )
    {
      if ( v39 - (unsigned __int64)v38[0] < 0x1000 )
      {
        v29 = v38[0];
      }
      else
      {
        v29 = (void *)*((_QWORD *)v38[0] - 1);
        if ( (unsigned __int64)((char *)v38[0] - (char *)v29 - 8) > 0x1F )
          goto LABEL_86;
      }
      j_j_free(v29);
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vmovdqu xmmword ptr [rsp+0F8h+var_A0], xmm0
      }
      v39 = 0;
    }
    if ( Block[0] )
    {
      if ( (unsigned __int64)v35 - (unsigned __int64)Block[0] < 0x1000 )
      {
        v30 = Block[0];
      }
      else
      {
        v30 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)((char *)Block[0] - (char *)v30 - 8) > 0x1F )
          goto LABEL_92;
      }
      j_j_free(v30);
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vmovdqu xmmword ptr [rsp+0F8h+Block], xmm0
      }
      v35 = 0;
    }
    if ( v36[0] )
    {
      if ( v37 - (unsigned __int64)v36[0] < 0x1000 )
      {
        v31 = v36[0];
      }
      else
      {
        v31 = (void *)*((_QWORD *)v36[0] - 1);
        if ( (unsigned __int64)((char *)v36[0] - (char *)v31 - 8) > 0x1F )
          goto LABEL_98;
      }
      j_j_free(v31);
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vmovdqu xmmword ptr [rsp+0F8h+var_B8], xmm0
      }
      v37 = 0;
    }
    if ( HIBYTE(v46) )
      DeleteSecurityContext(&phContext);
    if ( (_BYTE)v46 )
      FreeCredentialsHandle(&phCredential);
    if ( s != -1 )
      closesocket(s);
  }
  catch ( ... )
  {
  }
}
// 1800059F0: inconsistent variable size for 'xmm1_8.8'
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);

//----- (00000001800061C0) ----------------------------------------------------
int sub_1800061C0(char *Buffer, char *Format, ...)
{
  unsigned __int64 *v4; // rax
  int result; // eax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_180003F10();
  result = _stdio_common_vsprintf_s(*v4, Buffer, 0x20u, Format, 0, va);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (0000000180006220) ----------------------------------------------------
_QWORD *__fastcall sub_180006220(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int64 *v3; // rbx
  _QWORD *i; // rax
  __int64 *v6; // rcx
  char **v7; // rdi

  v3 = (__int64 *)a3[2];
  if ( *((_BYTE *)v3 + 25) )
  {
    v3 = (__int64 *)a3[1];
    for ( i = a3; !*((_BYTE *)v3 + 25); v3 = (__int64 *)v3[1] )
    {
      if ( i != (_QWORD *)v3[2] )
        break;
      i = v3;
    }
  }
  else
  {
    v6 = (__int64 *)*v3;
    if ( !*(_BYTE *)(*v3 + 25) )
    {
      do
      {
        v3 = v6;
        v6 = (__int64 *)*v6;
      }
      while ( !*((_BYTE *)v6 + 25) );
    }
  }
  v7 = (char **)sub_180007320(&qword_180017528, a3);
  sub_1800077E0(v7 + 4);
  j_j_free(v7);
  *a2 = v3;
  return a2;
}
// 180017528: using guessed type __int64 qword_180017528;

//----- (00000001800063A0) ----------------------------------------------------
__int64 *__fastcall sub_1800063A0(__int64 a1, __int64 *a2, const void **a3)
{
  __int64 v3; // rbp
  __int64 v6; // r14
  __int64 v7; // rdi
  size_t v8; // rbp
  unsigned __int64 v9; // r12
  _QWORD *v10; // rcx
  const void *v11; // rdx
  size_t v12; // rbx
  size_t v13; // r8
  int v14; // ecx
  __int64 *v15; // rax
  const void *v16; // rdx
  const void *v17; // rcx
  size_t v18; // rdi
  size_t v19; // rbx
  size_t v20; // r8
  int v21; // eax

  v3 = qword_180017528;
  v6 = qword_180017528;
  v7 = *(_QWORD *)(qword_180017528 + 8);
  if ( !*(_BYTE *)(v7 + 25) )
  {
    v8 = (size_t)a3[2];
    v9 = (unsigned __int64)a3[3];
    do
    {
      v10 = (_QWORD *)(v7 + 32);
      if ( v9 <= 0xF )
        v11 = a3;
      else
        v11 = *a3;
      if ( *(_QWORD *)(v7 + 56) > 0xFu )
        v10 = (_QWORD *)*v10;
      v12 = *(_QWORD *)(v7 + 48);
      v13 = v12;
      if ( v8 < v12 )
        v13 = v8;
      v14 = memcmp(v10, v11, v13);
      if ( !v14 )
      {
        if ( v12 >= v8 )
          v14 = v12 > v8;
        else
          v14 = -1;
      }
      v15 = (__int64 *)(v7 + 16);
      if ( v14 >= 0 )
      {
        v15 = (__int64 *)v7;
        v6 = v7;
      }
      v7 = *v15;
    }
    while ( !*(_BYTE *)(*v15 + 25) );
    v3 = qword_180017528;
  }
  if ( *(_BYTE *)(v6 + 25) )
    goto LABEL_33;
  if ( *(_QWORD *)(v6 + 56) <= 0xFu )
    v16 = (const void *)(v6 + 32);
  else
    v16 = *(const void **)(v6 + 32);
  if ( (unsigned __int64)a3[3] <= 0xF )
    v17 = a3;
  else
    v17 = *a3;
  v18 = *(_QWORD *)(v6 + 48);
  v19 = (size_t)a3[2];
  v20 = v19;
  if ( v18 < v19 )
    v20 = *(_QWORD *)(v6 + 48);
  v21 = memcmp(v17, v16, v20);
  if ( !v21 )
  {
    if ( v19 >= v18 )
      v21 = v19 > v18;
    else
      v21 = -1;
  }
  if ( v21 < 0 )
LABEL_33:
    *a2 = v3;
  else
    *a2 = v6;
  return a2;
}
// 180017528: using guessed type __int64 qword_180017528;

//----- (00000001800064D0) ----------------------------------------------------
void __fastcall sub_1800064D0(void **a1)
{
  char *v2; // rbx
  char **v3; // rdi

  v2 = (char *)*((_QWORD *)*a1 + 1);
  while ( !v2[25] )
  {
    sub_180006E60((__int64)a1, (__int64)a1, *((char **)v2 + 2));
    v3 = (char **)v2;
    v2 = *(char **)v2;
    sub_1800077E0(v3 + 4);
    j_j_free(v3);
  }
  j_j_free(*a1);
}

//----- (0000000180006540) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
unsigned __int64 *__fastcall sub_180006540(unsigned __int64 *a1, unsigned __int64 **a2)
{
  unsigned __int64 v5; // rdx
  char **v6; // rbx
  unsigned __int64 *v7; // rbp
  unsigned __int64 *v8; // rdi

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v5 = ((char *)a2[1] - (char *)*a2) >> 5;
  if ( v5 )
  {
    if ( v5 > 0x7FFFFFFFFFFFFFFLL )
      sub_180003190();
    sub_1800031B0(a1, v5);
    v6 = (char **)*a1;
    v7 = a2[1];
    v8 = *a2;
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovups [rsp+58h+var_38], xmm0
    }
    for ( ; v8 != v7; v8 += 4 )
    {
      sub_180002860(v6, v8);
      v6 += 4;
    }
    sub_180002980(v6, v6);
    a1[1] = (unsigned __int64)v6;
  }
  return a1;
}

//----- (0000000180006600) ----------------------------------------------------
void __fastcall sub_180006600(__int64 a1, _BYTE *a2, const void *a3, size_t a4)
{
  _BYTE *v8; // r12
  __int64 v9; // rcx
  _BYTE *v10; // r13
  char *v11; // rbp
  size_t v12; // rdi
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rdx
  size_t v15; // rcx
  void *v16; // rax
  unsigned __int64 v17; // rsi
  size_t v18; // r8
  const void *v19; // rdx
  char *v20; // rcx
  _BYTE *v21; // rax
  _BYTE *v22; // rcx
  signed __int64 v23; // rsi
  char *v24; // rdi
  char *v25; // rdi
  size_t Size; // [rsp+28h] [rbp-50h]
  char *v28; // [rsp+30h] [rbp-48h]

  if ( !a4 )
    return;
  v8 = *(_BYTE **)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 16);
  if ( a4 <= v9 - (__int64)v8 )
  {
    v23 = v8 - a2;
    if ( a4 >= v8 - a2 )
    {
      v25 = &a2[a4];
      memmove(&a2[a4], a2, v8 - a2);
      *(_QWORD *)(a1 + 8) = &v25[v23];
    }
    else
    {
      v24 = &v8[-a4];
      memmove(v8, &v8[-a4], a4);
      *(_QWORD *)(a1 + 8) = &v8[a4];
      memmove(&v8[-(v24 - a2)], a2, v24 - a2);
    }
    memmove(a2, a3, a4);
    return;
  }
  v10 = *(_BYTE **)a1;
  v11 = &v8[-*(_QWORD *)a1];
  v12 = 0x7FFFFFFFFFFFFFFFLL;
  if ( a4 > 0x7FFFFFFFFFFFFFFFLL - (__int64)v11 )
    sub_180003190();
  v28 = &v11[a4];
  v13 = v9 - (_QWORD)v10;
  v14 = v13 >> 1;
  if ( v13 > 0x7FFFFFFFFFFFFFFFLL - (v13 >> 1) )
  {
    v15 = 0x8000000000000026uLL;
LABEL_6:
    v16 = sub_18000E800(v15);
    if ( !v16 )
      goto LABEL_23;
    v17 = ((unsigned __int64)v16 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
    *(_QWORD *)(v17 - 8) = v16;
    goto LABEL_16;
  }
  v12 = (size_t)&v11[a4];
  if ( v13 + v14 >= (unsigned __int64)&v11[a4] )
    v12 = v13 + v14;
  if ( v12 )
  {
    if ( v12 >= 0x1000 )
    {
      v15 = v12 + 39;
      if ( v12 + 39 < v12 )
        Concurrency::cancel_current_task();
      goto LABEL_6;
    }
    v17 = (unsigned __int64)sub_18000E800(v12);
  }
  else
  {
    v17 = 0;
  }
LABEL_16:
  Size = a2 - v10;
  memmove((void *)(a2 - v10 + v17), a3, a4);
  if ( a4 == 1 && a2 == v8 )
  {
    v18 = (size_t)v11;
    v19 = v10;
    v20 = (char *)v17;
  }
  else
  {
    memmove((void *)v17, v10, Size);
    v20 = (char *)(v17 + a4 + Size);
    v18 = v8 - a2;
    v19 = a2;
  }
  memmove(v20, v19, v18);
  v21 = *(_BYTE **)a1;
  if ( *(_QWORD *)a1 )
  {
    if ( *(_QWORD *)(a1 + 16) - (_QWORD)v21 < 0x1000u )
    {
      v22 = *(_BYTE **)a1;
    }
    else
    {
      v22 = (_BYTE *)*((_QWORD *)v21 - 1);
      if ( (unsigned __int64)(v21 - v22 - 8) > 0x1F )
LABEL_23:
        __fastfail(5u);
    }
    j_j_free(v22);
  }
  *(_QWORD *)a1 = v17;
  *(_QWORD *)(a1 + 8) = &v28[v17];
  *(_QWORD *)(a1 + 16) = v17 + v12;
}

//----- (0000000180006830) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_180006830(__int64 a1, __int64 a2, unsigned __int64 *a3)
{
  __int64 v5; // r15
  __int64 v6; // r12
  int v7; // esi
  __int64 v8; // rbp
  _QWORD *v9; // rcx
  __int64 v10; // rbx
  size_t v11; // r15
  const void *v12; // rdx
  const void *v13; // rcx
  size_t v14; // rdi
  size_t v15; // r8
  int v16; // eax
  const void *v17; // rdx
  const void *v18; // rcx
  size_t v19; // rdi
  size_t v20; // rbx
  size_t v21; // r8
  int v22; // eax
  _QWORD *v23; // rdi
  __int64 v25; // [rsp+20h] [rbp-78h] BYREF
  int v26; // [rsp+28h] [rbp-70h]
  int v27; // [rsp+2Ch] [rbp-6Ch]

  v5 = qword_180017528;
  v25 = qword_180017528;
  v6 = *(_QWORD *)(qword_180017528 + 8);
  v7 = 0;
  v8 = qword_180017528;
  v9 = a3 + 3;
  if ( !*(_BYTE *)(v6 + 25) )
  {
    v10 = *(_QWORD *)(qword_180017528 + 8);
    v11 = a3[2];
    while ( 1 )
    {
      v6 = v10;
      if ( a3[3] <= 0xF )
        v12 = a3;
      else
        v12 = (const void *)*a3;
      if ( *(_QWORD *)(v10 + 56) <= 0xFu )
        v13 = (const void *)(v10 + 32);
      else
        v13 = *(const void **)(v10 + 32);
      v14 = *(_QWORD *)(v10 + 48);
      v15 = v14;
      if ( v11 < v14 )
        v15 = v11;
      v16 = memcmp(v13, v12, v15);
      if ( v16 )
      {
        if ( v16 < 0 )
          goto LABEL_20;
      }
      else if ( v14 < v11 )
      {
LABEL_20:
        v7 = 0;
        v10 = *(_QWORD *)(v10 + 16);
        goto LABEL_14;
      }
      v7 = 1;
      v8 = v10;
      v10 = *(_QWORD *)v10;
LABEL_14:
      if ( *(_BYTE *)(v10 + 25) )
      {
        v9 = a3 + 3;
        v5 = v25;
        break;
      }
    }
  }
  if ( *(_BYTE *)(v8 + 25) )
    goto LABEL_29;
  if ( *(_QWORD *)(v8 + 56) <= 0xFu )
    v17 = (const void *)(v8 + 32);
  else
    v17 = *(const void **)(v8 + 32);
  if ( *v9 <= 0xFu )
    v18 = a3;
  else
    v18 = (const void *)*a3;
  v19 = *(_QWORD *)(v8 + 48);
  v20 = a3[2];
  v21 = v20;
  if ( v19 < v20 )
    v21 = *(_QWORD *)(v8 + 48);
  v22 = memcmp(v18, v17, v21);
  if ( !v22 )
  {
    if ( v20 < v19 )
      goto LABEL_29;
LABEL_33:
    *(_QWORD *)a2 = v8;
    *(_BYTE *)(a2 + 8) = 0;
    return a2;
  }
  if ( v22 >= 0 )
    goto LABEL_33;
LABEL_29:
  if ( qword_180017530 == 0x2AAAAAAAAAAAAAALL )
    sub_180003290();
  v23 = sub_18000E800(0x60u);
  v27 = HIDWORD(v23);
  sub_180002860(v23 + 4, a3);
  v23[11] = 0;
  v23[8] = 0;
  v23[9] = 0;
  v23[10] = 0;
  *v23 = v5;
  v23[1] = v5;
  v23[2] = v5;
  *((_WORD *)v23 + 12) = 0;
  v25 = v6;
  v26 = v7;
  *(_QWORD *)a2 = sub_180003C90(&qword_180017528, (__int64)&v25, (__int64)v23);
  *(_BYTE *)(a2 + 8) = 1;
  return a2;
}
// 180017528: using guessed type __int64 qword_180017528;
// 180017530: using guessed type __int64 qword_180017530;

//----- (00000001800069E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
void __fastcall sub_1800069E0(__int64 a1, unsigned __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // rbp
  void **v7; // rdi
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rsi
  unsigned __int64 v10; // rdx
  void **v11; // rax
  void **v12; // rcx
  void **v13; // rdi
  void **v16; // rsi
  unsigned __int64 v17; // r15
  const void *v18; // rdx
  unsigned __int64 i; // rbp
  char **v22; // rdx
  const void *v23; // rdx

  v4 = a3;
  v7 = *(void ***)a1;
  v8 = (__int64)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 5;
  if ( a3 <= v8 )
  {
    v16 = *(void ***)(a1 + 8);
    v17 = ((char *)v16 - (char *)v7) >> 5;
    if ( a3 <= v17 )
    {
      v16 = &v7[4 * a3];
      if ( a3 )
      {
        do
        {
          if ( v7 != (void **)a2 )
          {
            if ( a2[3] <= 0xF )
              v23 = a2;
            else
              v23 = (const void *)*a2;
            sub_180007850(v7, v23, a2[2]);
          }
          v7 += 4;
          a2 += 4;
          --v4;
        }
        while ( v4 );
      }
      v22 = *(char ***)(a1 + 8);
    }
    else
    {
      for ( ; v7 != v16; v16 = *(void ***)(a1 + 8) )
      {
        if ( v7 != (void **)a2 )
        {
          if ( a2[3] <= 0xF )
            v18 = a2;
          else
            v18 = (const void *)*a2;
          sub_180007850(v7, v18, a2[2]);
        }
        v7 += 4;
        a2 += 4;
      }
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vmovups [rsp+68h+var_48], xmm0
      }
      for ( i = v4 - v17; i; --i )
      {
        sub_180002860(v16, a2);
        v16 += 4;
        a2 += 4;
      }
      v22 = (char **)v16;
    }
    sub_180002980((char **)v16, v22);
    *(_QWORD *)(a1 + 8) = v16;
  }
  else
  {
    v9 = 0x7FFFFFFFFFFFFFFLL;
    if ( a3 > 0x7FFFFFFFFFFFFFFLL )
      sub_180003190();
    v10 = v8 >> 1;
    if ( v8 <= 0x7FFFFFFFFFFFFFFLL - (v8 >> 1) )
    {
      v9 = v8 + v10;
      if ( v8 + v10 < a3 )
        v9 = a3;
    }
    if ( v7 )
    {
      sub_180002980((char **)v7, *(char ***)(a1 + 8));
      v11 = *(void ***)a1;
      if ( ((*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFE0uLL) < 0x1000 )
      {
        v12 = *(void ***)a1;
      }
      else
      {
        v12 = (void **)*(v11 - 1);
        if ( (unsigned __int64)((char *)v11 - (char *)v12 - 8) > 0x1F )
          __fastfail(5u);
      }
      j_j_free(v12);
      *(_QWORD *)a1 = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
    }
    sub_1800031B0((unsigned __int64 *)a1, v9);
    v13 = *(void ***)a1;
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovups [rsp+68h+var_48], xmm0
    }
    for ( ; v4; --v4 )
    {
      sub_180002860(v13, a2);
      v13 += 4;
      a2 += 4;
    }
    sub_180002980((char **)v13, (char **)v13);
    *(_QWORD *)(a1 + 8) = v13;
  }
}

//----- (0000000180006C00) ----------------------------------------------------
__int64 __fastcall sub_180006C00(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    return (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 16LL))(a1, 1);
  return result;
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (0000000180006C20) ----------------------------------------------------
void __fastcall sub_180006C20(__int64 a1)
{
  sub_180002C40(a1 + 16);
}

//----- (0000000180006C30) ----------------------------------------------------
_QWORD *__fastcall sub_180006C30(_QWORD *a1, char a2)
{
  *a1 = ___7___Ref_count_obj2_URaceResult__1__resolveDnsFastest__YA_AV__vector_V__basic_string_DU__char_traits_D_std__V__allocator_D_2__std__V__allocator_V__basic_string_DU__char_traits_D_std__V__allocator_D_2__std___2__std__AEBV__basic_string_DU__char_traits_D_std__V__allocator_D_2__4_0_Z__std__6B_;
  if ( (a2 & 1) != 0 )
    j_j_free(a1);
  return a1;
}
// 180013E30: using guessed type __int64 (__fastcall *___7___Ref_count_obj2_URaceResult__1__resolveDnsFastest__YA_AV__vector_V__basic_string_DU__char_traits_D_std__V__allocator_D_2__std__V__allocator_V__basic_string_DU__char_traits_D_std__V__allocator_D_2__std___2__std__AEBV__basic_string_DU__char_traits_D_std__V__allocator_D_2__4_0_Z__std__6B_[4])();

//----- (0000000180006C60) ----------------------------------------------------
__int64 __fastcall StartAddress(void *a1)
{
  sub_180005920((__int64)a1);
  Cnd_do_broadcast_at_thread_exit();
  if ( a1 )
  {
    sub_1800060C0(a1);
    j_j_free(a1);
  }
  return 0;
}
// 1800060C0: using guessed type __int64 __fastcall sub_1800060C0(_QWORD);

//----- (0000000180006CA0) ----------------------------------------------------
__int64 __fastcall sub_180006CA0(char *a1, double a2)
{
  sub_1800059F0(a1, a2);
  Cnd_do_broadcast_at_thread_exit();
  if ( a1 )
  {
    sub_1800060C0(a1);
    j_j_free(a1);
  }
  return 0;
}
// 1800060C0: using guessed type __int64 __fastcall sub_1800060C0(_QWORD);

//----- (0000000180006CE0) ----------------------------------------------------
_BYTE *__fastcall sub_180006CE0(_QWORD *a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v3; // r14
  size_t v4; // rbx
  __int64 v6; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r15
  unsigned __int64 v11; // rdx
  size_t v12; // rcx
  void *v13; // rax
  _QWORD *v14; // rdi
  _BYTE *v15; // r14
  void *v16; // rcx
  _BYTE *v17; // r8
  _BYTE *v18; // rdx
  size_t v19; // r8
  _BYTE *v20; // rax
  _BYTE *v21; // rcx

  v3 = (_BYTE *)*a1;
  v4 = 0x7FFFFFFFFFFFFFFFLL;
  v6 = a1[1] - *a1;
  if ( v6 == 0x7FFFFFFFFFFFFFFFLL )
    sub_180003190();
  v9 = a1[2] - (_QWORD)v3;
  v10 = v6 + 1;
  v11 = v9 >> 1;
  if ( v9 <= 0x7FFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    v4 = v6 + 1;
    if ( v9 + v11 >= v10 )
      v4 = v9 + v11;
    if ( !v4 )
    {
      v14 = 0;
      goto LABEL_14;
    }
    if ( v4 < 0x1000 )
    {
      v14 = sub_18000E800(v4);
      goto LABEL_14;
    }
    v12 = v4 + 39;
    if ( v4 + 39 < v4 )
      Concurrency::cancel_current_task();
  }
  else
  {
    v12 = 0x8000000000000026uLL;
  }
  v13 = sub_18000E800(v12);
  if ( !v13 )
    goto LABEL_20;
  v14 = (_QWORD *)(((unsigned __int64)v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v14 - 1) = v13;
LABEL_14:
  v15 = (char *)v14 + a2 - v3;
  *v15 = *a3;
  v16 = v14;
  v17 = (_BYTE *)a1[1];
  v18 = (_BYTE *)*a1;
  if ( a2 == v17 )
  {
    v19 = v17 - v18;
  }
  else
  {
    memmove(v14, v18, a2 - v18);
    v16 = v15 + 1;
    v19 = a1[1] - (_QWORD)a2;
    v18 = a2;
  }
  memmove(v16, v18, v19);
  v20 = (_BYTE *)*a1;
  if ( *a1 )
  {
    if ( a1[2] - (_QWORD)v20 < 0x1000u )
    {
      v21 = (_BYTE *)*a1;
    }
    else
    {
      v21 = (_BYTE *)*((_QWORD *)v20 - 1);
      if ( (unsigned __int64)(v20 - v21 - 8) > 0x1F )
LABEL_20:
        __fastfail(5u);
    }
    j_j_free(v21);
  }
  *a1 = v14;
  a1[1] = (char *)v14 + v10;
  a1[2] = (char *)v14 + v4;
  return v15;
}

//----- (0000000180006E60) ----------------------------------------------------
void __fastcall sub_180006E60(__int64 a1, __int64 a2, char *a3)
{
  char *v3; // rbx
  char **v6; // rdi

  v3 = a3;
  while ( !v3[25] )
  {
    sub_180006E60(a1, a2, *((_QWORD *)v3 + 2));
    v6 = (char **)v3;
    v3 = *(char **)v3;
    sub_1800077E0(v6 + 4);
    j_j_free(v6);
  }
}

//----- (0000000180006EC0) ----------------------------------------------------
unsigned __int64 __fastcall sub_180006EC0(__int64 a1, __int64 a2, __int64 a3)
{
  char **v4; // r12
  __int64 v7; // rdx
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r8
  __int64 v11; // r15
  unsigned __int64 v12; // rbp
  size_t v13; // rbp
  void *v15; // rax
  __int64 v17; // r14
  char **v21; // rdx
  __int64 v24; // r14
  __int64 v26; // rax
  char **v29; // rax
  char **v30; // rcx

  v4 = *(char ***)a1;
  _RBX = a2;
  _R13 = a3;
  v7 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 5;
  if ( v7 == 0x7FFFFFFFFFFFFFFLL )
    sub_180003190();
  v9 = (__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v4) >> 5;
  v10 = v9 >> 1;
  if ( v9 > 0x7FFFFFFFFFFFFFFLL - (v9 >> 1) )
    goto LABEL_30;
  v11 = v7 + 1;
  v12 = v7 + 1;
  if ( v9 + v10 >= v7 + 1 )
    v12 = v9 + v10;
  if ( v12 > 0x7FFFFFFFFFFFFFFLL )
    goto LABEL_30;
  v13 = 32 * v12;
  if ( !v13 )
  {
    _RDI = 0;
    goto LABEL_13;
  }
  if ( v13 < 0x1000 )
  {
    _RDI = (unsigned __int64)sub_18000E800(v13);
    goto LABEL_13;
  }
  if ( v13 + 39 < v13 )
LABEL_30:
    Concurrency::cancel_current_task();
  v15 = sub_18000E800(v13 + 39);
  if ( !v15 )
    goto LABEL_25;
  _RDI = ((unsigned __int64)v15 + 39) & 0xFFFFFFFFFFFFFFE0uLL;
  *(_QWORD *)(_RDI - 8) = v15;
LABEL_13:
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v17 = (_RBX - (__int64)v4) >> 5;
  _RCX = 32 * v17;
  __asm { vmovups xmmword ptr [rcx+rdi], xmm0 }
  *(_QWORD *)(_RCX + _RDI + 16) = 0;
  *(_QWORD *)(_RCX + _RDI + 24) = 0;
  __asm
  {
    vmovups ymm0, ymmword ptr [r13+0]
    vmovups ymmword ptr [rcx+rdi], ymm0
  }
  *(_QWORD *)(_R13 + 16) = 0;
  _RCX = _RDI;
  *(_QWORD *)(_R13 + 24) = 15;
  *(_BYTE *)_R13 = 0;
  v21 = *(char ***)(a1 + 8);
  _RAX = *(char ***)a1;
  if ( (char **)_RBX == v21 )
  {
    for ( ; _RAX != v21; _RAX += 4 )
    {
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vmovups xmmword ptr [rcx], xmm0
      }
      *(_QWORD *)(_RCX + 16) = 0;
      *(_QWORD *)(_RCX + 24) = 0;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rcx], ymm0
      }
      _RAX[2] = 0;
      _RCX += 32LL;
      _RAX[3] = (char *)15;
      *(_BYTE *)_RAX = 0;
    }
    __asm { vzeroupper }
    sub_180002980((char **)_RCX, (char **)_RCX);
    v24 = 32 * v17;
  }
  else
  {
    for ( ; _RAX != (char **)_RBX; _RAX += 4 )
    {
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vmovups xmmword ptr [rcx], xmm0
      }
      *(_QWORD *)(_RCX + 16) = 0;
      *(_QWORD *)(_RCX + 24) = 0;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rcx], ymm0
      }
      _RAX[2] = 0;
      _RCX += 32LL;
      _RAX[3] = (char *)15;
      *(_BYTE *)_RAX = 0;
    }
    __asm { vzeroupper }
    sub_180002980((char **)_RCX, (char **)_RCX);
    v26 = *(_QWORD *)(a1 + 8);
    v24 = 32 * v17;
    for ( _RCX = _RDI + v24 + 32; _RBX != v26; _RBX += 32 )
    {
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vmovups xmmword ptr [rcx], xmm0
      }
      *(_QWORD *)(_RCX + 16) = 0;
      *(_QWORD *)(_RCX + 24) = 0;
      __asm
      {
        vmovups ymm0, ymmword ptr [rbx]
        vmovups ymmword ptr [rcx], ymm0
      }
      *(_QWORD *)(_RBX + 16) = 0;
      _RCX += 32LL;
      *(_QWORD *)(_RBX + 24) = 15;
      *(_BYTE *)_RBX = 0;
    }
    __asm { vzeroupper }
    sub_180002980((char **)_RCX, (char **)_RCX);
  }
  if ( *(_QWORD *)a1 )
  {
    sub_180002980(*(char ***)a1, *(char ***)(a1 + 8));
    v29 = *(char ***)a1;
    if ( ((*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFE0uLL) < 0x1000 )
    {
      v30 = *(char ***)a1;
    }
    else
    {
      v30 = (char **)*(v29 - 1);
      if ( (unsigned __int64)((char *)v29 - (char *)v30 - 8) > 0x1F )
LABEL_25:
        __fastfail(5u);
    }
    j_j_free(v30);
  }
  *(_QWORD *)a1 = _RDI;
  *(_QWORD *)(a1 + 8) = _RDI + 32 * v11;
  *(_QWORD *)(a1 + 16) = _RDI + v13;
  return v24 + _RDI;
}

//----- (0000000180007180) ----------------------------------------------------
void **__fastcall sub_180007180(void **Src, __int64 a2, __int64 a3, char a4)
{
  size_t v4; // r14
  __int64 v5; // rbx
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  _QWORD *v11; // rdi
  size_t v12; // rcx
  void *v13; // rax
  void *v14; // rbx
  _BYTE *v15; // rcx

  v4 = (size_t)Src[2];
  v5 = 0x7FFFFFFFFFFFFFFFLL;
  if ( v4 == 0x7FFFFFFFFFFFFFFFLL )
    sub_180001680();
  v8 = (unsigned __int64)Src[3];
  v9 = (v4 + 1) | 0xF;
  if ( v9 > 0x7FFFFFFFFFFFFFFFLL || (v10 = v8 >> 1, v8 > 0x7FFFFFFFFFFFFFFFLL - (v8 >> 1)) )
  {
    v12 = 0x8000000000000027uLL;
  }
  else
  {
    v5 = (v4 + 1) | 0xF;
    if ( v9 < v8 + v10 )
      v5 = v8 + v10;
    if ( v5 == -1 )
    {
      v11 = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int64)(v5 + 1) < 0x1000 )
    {
      v11 = sub_18000E800(v5 + 1);
      goto LABEL_15;
    }
    v12 = v5 + 40;
    if ( v5 + 40 < (unsigned __int64)(v5 + 1) )
      Concurrency::cancel_current_task();
  }
  v13 = sub_18000E800(v12);
  if ( !v13 )
    goto LABEL_19;
  v11 = (_QWORD *)(((unsigned __int64)v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v11 - 1) = v13;
LABEL_15:
  Src[2] = (void *)(v4 + 1);
  Src[3] = (void *)v5;
  if ( v8 <= 0xF )
  {
    memcpy(v11, Src, v4);
    *((_BYTE *)v11 + v4) = a4;
    *((_BYTE *)v11 + v4 + 1) = 0;
    goto LABEL_22;
  }
  v14 = *Src;
  memcpy(v11, *Src, v4);
  *((_BYTE *)v11 + v4) = a4;
  *((_BYTE *)v11 + v4 + 1) = 0;
  if ( v8 + 1 < 0x1000 )
  {
    j_j_free(v14);
    goto LABEL_22;
  }
  v15 = (_BYTE *)*((_QWORD *)v14 - 1);
  if ( (unsigned __int64)((_BYTE *)v14 - v15 - 8) > 0x1F )
LABEL_19:
    __fastfail(5u);
  j_j_free(v15);
LABEL_22:
  *Src = v11;
  return Src;
}

//----- (0000000180007320) ----------------------------------------------------
_QWORD *__fastcall sub_180007320(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // r9
  _QWORD *v3; // r11
  _QWORD *v5; // rbx
  _QWORD *v6; // rbp
  _QWORD *v7; // rdi
  char v8; // r8
  _QWORD *v9; // rax
  _QWORD **i; // r10
  __int64 *v11; // rdx
  _QWORD *v12; // r8
  _QWORD *v13; // rdx
  __int64 *v14; // rcx
  __int64 v15; // rdx
  _BYTE *v16; // r10
  _QWORD *j; // rcx
  _QWORD *v18; // rcx
  _QWORD *v19; // rcx
  char v20; // dl
  __int64 *v21; // rcx
  _QWORD *v22; // rcx
  _QWORD *v23; // rax
  __int64 v24; // rdx
  __int64 v25; // rax
  __int64 *v26; // rcx
  __int64 v27; // rax
  _QWORD *v28; // rax
  __int64 v29; // rdx
  _QWORD *v30; // rax
  _QWORD *v31; // rcx
  _QWORD *v32; // rax
  __int64 *v33; // rdx
  __int64 **v34; // rax
  __int64 v35; // rax
  _QWORD *v36; // rax
  __int64 v37; // rcx
  _QWORD *result; // rax

  v2 = (_QWORD *)a2[2];
  v3 = a2 + 2;
  v5 = a2;
  v6 = a2;
  v7 = a2;
  v8 = *((_BYTE *)v2 + 25);
  if ( v8 )
  {
    v9 = (_QWORD *)a2[1];
    for ( i = (_QWORD **)(a2 + 1); !*((_BYTE *)v9 + 25); v9 = (_QWORD *)v9[1] )
    {
      if ( a2 != (_QWORD *)v9[2] )
        break;
      a2 = v9;
    }
  }
  else
  {
    v11 = (__int64 *)*v2;
    if ( *(_BYTE *)(*v2 + 25LL) )
    {
      v9 = v2;
    }
    else
    {
      do
      {
        v9 = v11;
        v11 = (__int64 *)*v11;
      }
      while ( !*((_BYTE *)v11 + 25) );
    }
    i = (_QWORD **)(v7 + 1);
  }
  if ( !*(_BYTE *)(*v5 + 25LL) )
  {
    if ( v8 )
    {
      v2 = (_QWORD *)*v5;
    }
    else
    {
      v2 = (_QWORD *)v9[2];
      if ( v9 != v6 )
      {
        *(_QWORD *)(*v5 + 8LL) = v9;
        *v9 = *v5;
        if ( v9 == (_QWORD *)*v3 )
        {
          v12 = v9;
        }
        else
        {
          v12 = (_QWORD *)v9[1];
          if ( !*((_BYTE *)v2 + 25) )
            v2[1] = v12;
          *v12 = v2;
          v9[2] = *v3;
          *(_QWORD *)(*v3 + 8LL) = v9;
        }
        if ( *(_QWORD **)(*a1 + 8LL) == v6 )
        {
          *(_QWORD *)(*a1 + 8LL) = v9;
        }
        else
        {
          v18 = *i;
          if ( (_QWORD *)**i == v6 )
            *v18 = v9;
          else
            v18[2] = v9;
        }
        v19 = *i;
        v16 = v6 + 3;
        v20 = *((_BYTE *)v9 + 24);
        v9[1] = v19;
        *((_BYTE *)v9 + 24) = *((_BYTE *)v6 + 24);
        *((_BYTE *)v6 + 24) = v20;
        goto LABEL_48;
      }
    }
  }
  v12 = *i;
  if ( !*((_BYTE *)v2 + 25) )
    v2[1] = v12;
  if ( *(_QWORD **)(*a1 + 8LL) == v6 )
  {
    *(_QWORD *)(*a1 + 8LL) = v2;
  }
  else if ( (_QWORD *)*v12 == v6 )
  {
    *v12 = v2;
  }
  else
  {
    v12[2] = v2;
  }
  if ( *(_QWORD **)*a1 == v6 )
  {
    if ( *((_BYTE *)v2 + 25) )
    {
      v13 = v12;
    }
    else
    {
      v14 = (__int64 *)*v2;
      if ( *(_BYTE *)(*v2 + 25LL) )
      {
        v13 = v2;
      }
      else
      {
        do
        {
          v13 = v14;
          v14 = (__int64 *)*v14;
        }
        while ( !*((_BYTE *)v14 + 25) );
      }
    }
    *(_QWORD *)*a1 = v13;
  }
  v15 = *a1;
  if ( *(_QWORD **)(*a1 + 16LL) == v6 )
  {
    if ( *((_BYTE *)v2 + 25) )
    {
      v16 = v7 + 3;
      *(_QWORD *)(v15 + 16) = v12;
      goto LABEL_48;
    }
    for ( j = v2; !*(_BYTE *)(j[2] + 25LL); j = (_QWORD *)j[2] )
      ;
    *(_QWORD *)(v15 + 16) = j;
  }
  v16 = v7 + 3;
LABEL_48:
  if ( *v16 == 1 )
  {
    for ( ; v2 != *(_QWORD **)(*a1 + 8LL); v12 = (_QWORD *)v12[1] )
    {
      if ( *((_BYTE *)v2 + 24) != 1 )
        break;
      v21 = (__int64 *)*v12;
      if ( v2 == (_QWORD *)*v12 )
      {
        v21 = (__int64 *)v12[2];
        if ( !*((_BYTE *)v21 + 24) )
        {
          *((_BYTE *)v21 + 24) = 1;
          v22 = (_QWORD *)v12[2];
          *((_BYTE *)v12 + 24) = 0;
          v12[2] = *v22;
          if ( !*(_BYTE *)(*v22 + 25LL) )
            *(_QWORD *)(*v22 + 8LL) = v12;
          v22[1] = v12[1];
          if ( v12 == *(_QWORD **)(*a1 + 8LL) )
          {
            *(_QWORD *)(*a1 + 8LL) = v22;
          }
          else
          {
            v23 = (_QWORD *)v12[1];
            if ( v12 == (_QWORD *)*v23 )
              *v23 = v22;
            else
              v23[2] = v22;
          }
          *v22 = v12;
          v12[1] = v22;
          v21 = (__int64 *)v12[2];
        }
        if ( *((_BYTE *)v21 + 25) )
          goto LABEL_82;
        if ( *(_BYTE *)(*v21 + 24) != 1 || *(_BYTE *)(v21[2] + 24) != 1 )
        {
          if ( *(_BYTE *)(v21[2] + 24) == 1 )
          {
            *(_BYTE *)(*v21 + 24) = 1;
            v24 = *v21;
            *((_BYTE *)v21 + 24) = 0;
            *v21 = *(_QWORD *)(v24 + 16);
            v25 = *(_QWORD *)(v24 + 16);
            if ( !*(_BYTE *)(v25 + 25) )
              *(_QWORD *)(v25 + 8) = v21;
            *(_QWORD *)(v24 + 8) = v21[1];
            if ( v21 == *(__int64 **)(*a1 + 8LL) )
            {
              *(_QWORD *)(*a1 + 8LL) = v24;
            }
            else
            {
              v30 = (_QWORD *)v21[1];
              if ( v21 == (__int64 *)v30[2] )
                v30[2] = v24;
              else
                *v30 = v24;
            }
            *(_QWORD *)(v24 + 16) = v21;
            v21[1] = v24;
            v21 = (__int64 *)v12[2];
          }
          *((_BYTE *)v21 + 24) = *((_BYTE *)v12 + 24);
          *((_BYTE *)v12 + 24) = 1;
          *(_BYTE *)(v21[2] + 24) = 1;
          v31 = (_QWORD *)v12[2];
          v12[2] = *v31;
          if ( !*(_BYTE *)(*v31 + 25LL) )
            *(_QWORD *)(*v31 + 8LL) = v12;
          v31[1] = v12[1];
          if ( v12 == *(_QWORD **)(*a1 + 8LL) )
          {
            *(_QWORD *)(*a1 + 8LL) = v31;
            *v31 = v12;
          }
          else
          {
            v32 = (_QWORD *)v12[1];
            if ( v12 == (_QWORD *)*v32 )
              *v32 = v31;
            else
              v32[2] = v31;
            *v31 = v12;
          }
LABEL_113:
          v12[1] = v31;
          break;
        }
      }
      else
      {
        if ( !*((_BYTE *)v21 + 24) )
        {
          *((_BYTE *)v21 + 24) = 1;
          v26 = (__int64 *)*v12;
          *((_BYTE *)v12 + 24) = 0;
          *v12 = v26[2];
          v27 = v26[2];
          if ( !*(_BYTE *)(v27 + 25) )
            *(_QWORD *)(v27 + 8) = v12;
          v26[1] = v12[1];
          if ( v12 == *(_QWORD **)(*a1 + 8LL) )
          {
            *(_QWORD *)(*a1 + 8LL) = v26;
          }
          else
          {
            v28 = (_QWORD *)v12[1];
            if ( v12 == (_QWORD *)v28[2] )
              v28[2] = v26;
            else
              *v28 = v26;
          }
          v26[2] = (__int64)v12;
          v12[1] = v26;
          v21 = (__int64 *)*v12;
        }
        if ( *((_BYTE *)v21 + 25) )
          goto LABEL_82;
        v29 = v21[2];
        if ( *(_BYTE *)(v29 + 24) != 1 || *(_BYTE *)(*v21 + 24) != 1 )
        {
          if ( *(_BYTE *)(*v21 + 24) == 1 )
          {
            *(_BYTE *)(v29 + 24) = 1;
            v33 = (__int64 *)v21[2];
            *((_BYTE *)v21 + 24) = 0;
            v21[2] = *v33;
            if ( !*(_BYTE *)(*v33 + 25) )
              *(_QWORD *)(*v33 + 8) = v21;
            v33[1] = v21[1];
            if ( v21 == *(__int64 **)(*a1 + 8LL) )
            {
              *(_QWORD *)(*a1 + 8LL) = v33;
            }
            else
            {
              v34 = (__int64 **)v21[1];
              if ( v21 == *v34 )
                *v34 = v33;
              else
                v34[2] = v33;
            }
            *v33 = (__int64)v21;
            v21[1] = (__int64)v33;
            v21 = (__int64 *)*v12;
          }
          *((_BYTE *)v21 + 24) = *((_BYTE *)v12 + 24);
          *((_BYTE *)v12 + 24) = 1;
          *(_BYTE *)(*v21 + 24) = 1;
          v31 = (_QWORD *)*v12;
          *v12 = *(_QWORD *)(*v12 + 16LL);
          v35 = v31[2];
          if ( !*(_BYTE *)(v35 + 25) )
            *(_QWORD *)(v35 + 8) = v12;
          v31[1] = v12[1];
          if ( v12 == *(_QWORD **)(*a1 + 8LL) )
          {
            *(_QWORD *)(*a1 + 8LL) = v31;
          }
          else
          {
            v36 = (_QWORD *)v12[1];
            if ( v12 == (_QWORD *)v36[2] )
              v36[2] = v31;
            else
              *v36 = v31;
          }
          v31[2] = v12;
          goto LABEL_113;
        }
      }
      *((_BYTE *)v21 + 24) = 0;
LABEL_82:
      v2 = v12;
    }
    *((_BYTE *)v2 + 24) = 1;
  }
  v37 = a1[1];
  result = v6;
  if ( v37 )
    a1[1] = v37 - 1;
  return result;
}

//----- (00000001800077E0) ----------------------------------------------------
void __fastcall sub_1800077E0(char **a1)
{
  unsigned __int64 v2; // rdx
  char *v3; // rax
  char *v4; // rcx

  sub_180002C40((__int64)(a1 + 4));
  v2 = (unsigned __int64)a1[3];
  if ( v2 > 0xF )
  {
    v3 = *a1;
    if ( v2 + 1 < 0x1000 )
    {
      v4 = *a1;
    }
    else
    {
      v4 = (char *)*((_QWORD *)v3 - 1);
      if ( (unsigned __int64)(v3 - v4 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v4);
  }
  a1[2] = 0;
  a1[3] = (char *)15;
  *(_BYTE *)a1 = 0;
}

//----- (0000000180007850) ----------------------------------------------------
void **__fastcall sub_180007850(void **a1, const void *a2, size_t a3)
{
  unsigned __int64 v3; // rbp
  void *v7; // rdi
  __int64 v9; // rdi
  __int64 v10; // rdx
  _QWORD *v11; // r14
  size_t v12; // rcx
  void *v13; // rax
  char *v14; // rcx
  char *v15; // rax

  v3 = (unsigned __int64)a1[3];
  if ( a3 > v3 )
  {
    v9 = 0x7FFFFFFFFFFFFFFFLL;
    if ( a3 > 0x7FFFFFFFFFFFFFFFLL )
      sub_180001680();
    if ( (a3 | 0xF) > 0x7FFFFFFFFFFFFFFFLL || (v10 = v3 >> 1, v3 > 0x7FFFFFFFFFFFFFFFLL - (v3 >> 1)) )
    {
      v12 = 0x8000000000000027uLL;
    }
    else
    {
      v9 = a3 | 0xF;
      if ( (a3 | 0xF) < v10 + v3 )
        v9 = v10 + v3;
      if ( v9 == -1 )
      {
        v11 = 0;
        goto LABEL_20;
      }
      if ( (unsigned __int64)(v9 + 1) < 0x1000 )
      {
        v11 = sub_18000E800(v9 + 1);
        goto LABEL_20;
      }
      v12 = v9 + 40;
      if ( v9 + 40 < (unsigned __int64)(v9 + 1) )
        Concurrency::cancel_current_task();
    }
    v13 = sub_18000E800(v12);
    if ( !v13 )
      goto LABEL_23;
    v11 = (_QWORD *)(((unsigned __int64)v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v11 - 1) = v13;
LABEL_20:
    a1[2] = (void *)a3;
    a1[3] = (void *)v9;
    memcpy(v11, a2, a3);
    *((_BYTE *)v11 + a3) = 0;
    if ( v3 > 0xF )
    {
      v14 = (char *)*a1;
      if ( v3 + 1 < 0x1000 )
      {
        v15 = (char *)*a1;
      }
      else
      {
        v15 = (char *)*((_QWORD *)v14 - 1);
        if ( (unsigned __int64)(v14 - v15 - 8) > 0x1F )
LABEL_23:
          __fastfail(5u);
      }
      j_j_free(v15);
    }
    *a1 = v11;
    return a1;
  }
  if ( v3 <= 0xF )
    v7 = a1;
  else
    v7 = *a1;
  a1[2] = (void *)a3;
  memmove(v7, a2, a3);
  *((_BYTE *)v7 + a3) = 0;
  return a1;
}

//----- (00000001800079B0) ----------------------------------------------------
void __fastcall sub_1800079B0(__int64 a1)
{
  __int64 v1; // rdx
  void *v3; // rcx

  v1 = *(_QWORD *)(a1 + 24);
  if ( v1 )
  {
    if ( (unsigned __int64)(8 * ((*(_QWORD *)(a1 + 40) - v1) >> 3)) < 0x1000 )
    {
      v3 = *(void **)(a1 + 24);
    }
    else
    {
      v3 = *(void **)(v1 - 8);
      if ( (unsigned __int64)(v1 - (_QWORD)v3 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v3);
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 40) = 0;
  }
  sub_1800082B0(a1, *(_QWORD ***)(a1 + 8));
  j_j_free(*(void **)(a1 + 8));
}
// 180007A18: variable 'a1' is possibly undefined

//----- (0000000180007A30) ----------------------------------------------------
void __fastcall sub_180007A30(__int64 a1)
{
  __int64 v1; // rdx
  void *v3; // rcx

  v1 = *(_QWORD *)(a1 + 24);
  if ( v1 )
  {
    if ( (unsigned __int64)(8 * ((*(_QWORD *)(a1 + 40) - v1) >> 3)) < 0x1000 )
    {
      v3 = *(void **)(a1 + 24);
    }
    else
    {
      v3 = *(void **)(v1 - 8);
      if ( (unsigned __int64)(v1 - (_QWORD)v3 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v3);
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 40) = 0;
  }
  sub_180008210(a1, *(_QWORD ***)(a1 + 8));
  j_j_free(*(void **)(a1 + 8));
}
// 180007A98: variable 'a1' is possibly undefined

//----- (0000000180007AB0) ----------------------------------------------------
__int64 __fastcall sub_180007AB0(char **a1)
{
  char *v1; // rdx
  char *v3; // rcx
  __int64 result; // rax

  v1 = *a1;
  if ( *a1 )
  {
    if ( (unsigned __int64)(8 * ((a1[2] - v1) >> 3)) < 0x1000 )
    {
      v3 = *a1;
    }
    else
    {
      v3 = (char *)*((_QWORD *)v1 - 1);
      if ( (unsigned __int64)(v1 - v3 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v3);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    return 0;
  }
  return result;
}

//----- (0000000180007B20) ----------------------------------------------------
void __fastcall sub_180007B20(void **a1)
{
  sub_180008210((__int64)a1, (_QWORD **)*a1);
  j_j_free(*a1);
}

//----- (0000000180007B50) ----------------------------------------------------
void __fastcall sub_180007B50(void **a1)
{
  sub_1800082B0((__int64)a1, (_QWORD **)*a1);
  j_j_free(*a1);
}

//----- (0000000180007B80) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_180007B80(double _XMM0_8, __int64 a2, size_t *a3)
{
  size_t v6; // rdx
  __int64 v7; // rdi
  unsigned __int64 v8; // r8
  unsigned __int64 i; // rcx
  _QWORD *v10; // r14
  __int64 v11; // r8
  unsigned __int64 v15; // rdx
  bool v17; // zf
  unsigned __int64 v29; // rcx
  __int64 *v30; // rbx
  __int64 v31; // rdx
  __int64 *v32; // r12
  unsigned __int64 v33; // r13
  size_t v34; // rsi
  const void *v35; // rdx
  const void *v36; // rcx
  _QWORD *v37; // r9
  __int64 v38; // rcx
  __int64 v39; // rax
  __int64 v40; // r8
  __int64 v42; // [rsp+30h] [rbp-48h] BYREF
  __int64 v43; // [rsp+38h] [rbp-40h]

  if ( a3[3] <= 0xF )
    v6 = (size_t)a3;
  else
    v6 = *a3;
  v7 = 0xCBF29CE484222325uLL;
  v8 = a3[2];
  for ( i = 0; i < v8; ++i )
    v7 = 0x100000001B3LL * (*(unsigned __int8 *)(v6 + i) ^ (unsigned __int64)v7);
  sub_180008130(i, &v42, a3, v7);
  if ( !v43 )
  {
    if ( qword_1800175D0 == 0x492492492492492LL )
      std::_Xlength_error("unordered_map/set too long");
    v10 = sub_18000E800(0x38u);
    sub_180002860(v10 + 2, a3);
    *((_DWORD *)v10 + 12) = 0;
    v11 = qword_1800175D0;
    __asm { vxorps  xmm1, xmm1, xmm1 }
    if ( qword_1800175D0 + 1 < 0 )
    {
      __asm
      {
        vcvtsi2ss xmm1, xmm1, rax
        vaddss  xmm1, xmm1, xmm1
      }
    }
    else
    {
      __asm { vcvtsi2ss xmm1, xmm1, rcx }
    }
    v15 = qword_1800175F8;
    __asm { vxorps  xmm0, xmm0, xmm0 }
    v17 = qword_1800175F8 == 0;
    if ( qword_1800175F8 < 0 )
    {
      v17 = (qword_1800175F8 & 1 | ((unsigned __int64)qword_1800175F8 >> 1)) == 0;
      __asm
      {
        vcvtsi2ss xmm0, xmm0, rcx
        vaddss  xmm0, xmm0, xmm0
      }
    }
    else
    {
      __asm { vcvtsi2ss xmm0, xmm0, rdx }
    }
    __asm
    {
      vdivss  xmm0, xmm1, xmm0
      vmovss  xmm2, cs:dword_1800175C0
      vcomiss xmm0, xmm2
    }
    if ( v17 )
    {
      v31 = v42;
    }
    else
    {
      __asm
      {
        vdivss  xmm0, xmm1, xmm2
        vxorps  xmm1, xmm1, xmm1
        vroundss xmm1, xmm1, xmm0, 2
      }
      __asm
      {
        vmovss  xmm0, cs:dword_18001410C
        vcomiss xmm1, xmm0
      }
      __asm
      {
        vsubss  xmm1, xmm1, xmm0
        vcomiss xmm1, xmm0
      }
      __asm { vcvttss2si rax, xmm1 }
      v29 = 8;
      if ( _RAX > 8 )
        v29 = _RAX;
      if ( qword_1800175F8 < v29 )
      {
        if ( (unsigned __int64)qword_1800175F8 >= 0x200 || (v15 = 8 * qword_1800175F8, 8 * qword_1800175F8 < v29) )
          v15 = v29;
      }
      sub_1800085D0(v29, v15);
      v30 = *(__int64 **)(qword_1800175D8 + 16 * (v7 & qword_1800175F0) + 8);
      v31 = qword_1800175C8;
      if ( v30 != (__int64 *)qword_1800175C8 )
      {
        v32 = *(__int64 **)(qword_1800175D8 + 16 * (v7 & qword_1800175F0));
        v33 = v10[5];
        v34 = v10[4];
        while ( 1 )
        {
          if ( (unsigned __int64)v30[5] <= 0xF )
            v35 = v30 + 2;
          else
            v35 = (const void *)v30[2];
          if ( v33 <= 0xF )
            v36 = v10 + 2;
          else
            v36 = (const void *)v10[2];
          if ( v34 == v30[4] && (!v34 || !memcmp(v36, v35, v34)) )
          {
            v31 = *v30;
            v11 = qword_1800175D0;
            goto LABEL_40;
          }
          if ( v30 == v32 )
            break;
          v30 = (__int64 *)v30[1];
        }
        v31 = (__int64)v30;
      }
      v11 = qword_1800175D0;
    }
LABEL_40:
    v37 = *(_QWORD **)(v31 + 8);
    qword_1800175D0 = v11 + 1;
    *v10 = v31;
    v10[1] = v37;
    *v37 = v10;
    *(_QWORD *)(v31 + 8) = v10;
    v38 = qword_1800175D8;
    v39 = 2 * (v7 & qword_1800175F0);
    v40 = *(_QWORD *)(qword_1800175D8 + 16 * (v7 & qword_1800175F0));
    if ( v40 == qword_1800175C8 )
    {
      *(_QWORD *)(qword_1800175D8 + 16 * (v7 & qword_1800175F0)) = v10;
LABEL_45:
      *(_QWORD *)(v38 + 8 * v39 + 8) = v10;
      goto LABEL_46;
    }
    if ( v40 == v31 )
    {
      *(_QWORD *)(qword_1800175D8 + 16 * (v7 & qword_1800175F0)) = v10;
    }
    else if ( *(_QWORD **)(qword_1800175D8 + 16 * (v7 & qword_1800175F0) + 8) == v37 )
    {
      goto LABEL_45;
    }
LABEL_46:
    *(_QWORD *)a2 = v10;
    *(_BYTE *)(a2 + 8) = 1;
    return a2;
  }
  *(_QWORD *)a2 = v43;
  *(_BYTE *)(a2 + 8) = 0;
  return a2;
}
// 180007B80: inconsistent variable size for 'xmm0_8.8'
// 180011140: using guessed type void __noreturn std::_Xlength_error(const char *);
// 1800175C0: using guessed type int dword_1800175C0;
// 1800175C8: using guessed type __int64 qword_1800175C8;
// 1800175D0: using guessed type __int64 qword_1800175D0;
// 1800175D8: using guessed type __int64 qword_1800175D8;
// 1800175F0: using guessed type __int64 qword_1800175F0;
// 1800175F8: using guessed type __int64 qword_1800175F8;

//----- (0000000180007E60) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_180007E60(double _XMM0_8, __int64 a2, unsigned __int8 *a3)
{
  unsigned __int64 v6; // rbp
  __int64 v7; // rcx
  __int64 v8; // rdi
  __int64 v12; // r8
  unsigned __int64 v16; // rdx
  bool v18; // zf
  unsigned __int64 v30; // rcx
  __int64 v31; // rcx
  int v32; // eax
  _QWORD *v33; // rdx
  __int64 v34; // rcx
  __int64 v35; // rax
  __int64 v36; // r8

  v6 = 0x100000001B3LL
     * (a3[3]
      ^ (0x100000001B3LL * (a3[2] ^ (0x100000001B3LL * (a3[1] ^ (0x100000001B3LL * (*a3 ^ 0xCBF29CE484222325uLL)))))));
  v7 = *(_QWORD *)(qword_180017598 + 16 * (qword_1800175B0 & v6) + 8);
  v8 = qword_180017588;
  if ( v7 == qword_180017588 )
    goto LABEL_8;
  if ( *(_DWORD *)a3 != *(_DWORD *)(v7 + 16) )
  {
    while ( v7 != *(_QWORD *)(qword_180017598
                            + 16
                            * (qword_1800175B0
                             & (0x100000001B3LL
                              * (a3[3]
                               ^ (0x100000001B3LL
                                * (a3[2]
                                 ^ (0x100000001B3LL * (a3[1] ^ (0x100000001B3LL * (*a3 ^ 0xCBF29CE484222325uLL)))))))))) )
    {
      v7 = *(_QWORD *)(v7 + 8);
      if ( *(_DWORD *)a3 == *(_DWORD *)(v7 + 16) )
        goto LABEL_5;
    }
    v8 = v7;
LABEL_8:
    if ( qword_180017590 == 0x492492492492492LL )
      std::_Xlength_error("unordered_map/set too long");
    _RBX = sub_18000E800(0x38u);
    _RBX[4] = *(_DWORD *)a3;
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovups xmmword ptr [rbx+18h], xmm0
    }
    *((_QWORD *)_RBX + 5) = 0;
    *((_QWORD *)_RBX + 6) = 15;
    *((_BYTE *)_RBX + 24) = 0;
    v12 = qword_180017590;
    __asm { vxorps  xmm1, xmm1, xmm1 }
    if ( qword_180017590 + 1 < 0 )
    {
      __asm
      {
        vcvtsi2ss xmm1, xmm1, rax
        vaddss  xmm1, xmm1, xmm1
      }
    }
    else
    {
      __asm { vcvtsi2ss xmm1, xmm1, rcx }
    }
    v16 = qword_1800175B8;
    __asm { vxorps  xmm0, xmm0, xmm0 }
    v18 = qword_1800175B8 == 0;
    if ( qword_1800175B8 < 0 )
    {
      v18 = (qword_1800175B8 & 1 | ((unsigned __int64)qword_1800175B8 >> 1)) == 0;
      __asm
      {
        vcvtsi2ss xmm0, xmm0, rcx
        vaddss  xmm0, xmm0, xmm0
      }
    }
    else
    {
      __asm { vcvtsi2ss xmm0, xmm0, rdx }
    }
    __asm
    {
      vdivss  xmm0, xmm1, xmm0
      vmovss  xmm2, cs:dword_180017580
      vcomiss xmm0, xmm2
    }
    if ( !v18 )
    {
      __asm
      {
        vdivss  xmm0, xmm1, xmm2
        vxorps  xmm1, xmm1, xmm1
        vroundss xmm1, xmm1, xmm0, 2
      }
      __asm
      {
        vmovss  xmm0, cs:dword_18001410C
        vcomiss xmm1, xmm0
      }
      __asm
      {
        vsubss  xmm1, xmm1, xmm0
        vcomiss xmm1, xmm0
      }
      __asm { vcvttss2si rax, xmm1 }
      v30 = 8;
      if ( _RAX > 8 )
        v30 = _RAX;
      if ( qword_1800175B8 < v30 )
      {
        if ( (unsigned __int64)qword_1800175B8 >= 0x200 || (v16 = 8 * qword_1800175B8, 8 * qword_1800175B8 < v30) )
          v16 = v30;
      }
      sub_180008830(v30, v16);
      v31 = *(_QWORD *)(qword_180017598 + 16 * (v6 & qword_1800175B0) + 8);
      v8 = qword_180017588;
      if ( v31 != qword_180017588 )
      {
        v32 = _RBX[4];
        if ( v32 == *(_DWORD *)(v31 + 16) )
        {
LABEL_27:
          v8 = *(_QWORD *)v31;
        }
        else
        {
          while ( v31 != *(_QWORD *)(qword_180017598 + 16 * (v6 & qword_1800175B0)) )
          {
            v31 = *(_QWORD *)(v31 + 8);
            if ( v32 == *(_DWORD *)(v31 + 16) )
              goto LABEL_27;
          }
          v8 = v31;
        }
      }
      v12 = qword_180017590;
    }
    v33 = *(_QWORD **)(v8 + 8);
    qword_180017590 = v12 + 1;
    *(_QWORD *)_RBX = v8;
    *((_QWORD *)_RBX + 1) = v33;
    *v33 = _RBX;
    *(_QWORD *)(v8 + 8) = _RBX;
    v34 = qword_180017598;
    v35 = 2 * (v6 & qword_1800175B0);
    v36 = *(_QWORD *)(qword_180017598 + 16 * (v6 & qword_1800175B0));
    if ( v36 == qword_180017588 )
    {
      *(_QWORD *)(qword_180017598 + 16 * (v6 & qword_1800175B0)) = _RBX;
LABEL_35:
      *(_QWORD *)(v34 + 8 * v35 + 8) = _RBX;
      goto LABEL_36;
    }
    if ( v36 == v8 )
    {
      *(_QWORD *)(qword_180017598 + 16 * (v6 & qword_1800175B0)) = _RBX;
    }
    else if ( *(_QWORD **)(qword_180017598 + 16 * (v6 & qword_1800175B0) + 8) == v33 )
    {
      goto LABEL_35;
    }
LABEL_36:
    *(_QWORD *)a2 = _RBX;
    *(_BYTE *)(a2 + 8) = 1;
    return a2;
  }
LABEL_5:
  *(_QWORD *)a2 = v7;
  *(_BYTE *)(a2 + 8) = 0;
  return a2;
}
// 180007E60: inconsistent variable size for 'xmm0_8.8'
// 180011140: using guessed type void __noreturn std::_Xlength_error(const char *);
// 180017580: using guessed type int dword_180017580;
// 180017588: using guessed type __int64 qword_180017588;
// 180017590: using guessed type __int64 qword_180017590;
// 180017598: using guessed type __int64 qword_180017598;
// 1800175B0: using guessed type __int64 qword_1800175B0;
// 1800175B8: using guessed type __int64 qword_1800175B8;

//----- (0000000180008130) ----------------------------------------------------
_QWORD *__fastcall sub_180008130(__int64 a1, _QWORD *a2, size_t *a3, __int64 a4)
{
  _QWORD *v6; // rdx
  _QWORD *v7; // rbx
  _QWORD *v9; // rbp
  size_t v10; // rsi
  unsigned __int64 v11; // r15
  _QWORD *v12; // rdx
  const void *v13; // rcx

  v6 = (_QWORD *)(qword_1800175D8 + 16 * (a4 & qword_1800175F0));
  v7 = (_QWORD *)v6[1];
  if ( v7 == (_QWORD *)qword_1800175C8 )
  {
    *a2 = qword_1800175C8;
    a2[1] = 0;
    return a2;
  }
  else
  {
    v9 = (_QWORD *)*v6;
    v10 = a3[2];
    v11 = a3[3];
    while ( 1 )
    {
      v12 = v7 + 2;
      if ( v7[5] > 0xFu )
        v12 = (_QWORD *)*v12;
      if ( v11 <= 0xF )
        v13 = a3;
      else
        v13 = (const void *)*a3;
      if ( v10 == v7[4] && (!v10 || !memcmp(v13, v12, v10)) )
      {
        *a2 = *v7;
        a2[1] = v7;
        return a2;
      }
      if ( v7 == v9 )
        break;
      v7 = (_QWORD *)v7[1];
    }
    *a2 = v7;
    a2[1] = 0;
    return a2;
  }
}
// 1800175C8: using guessed type __int64 qword_1800175C8;
// 1800175D8: using guessed type __int64 qword_1800175D8;
// 1800175F0: using guessed type __int64 qword_1800175F0;

//----- (0000000180008210) ----------------------------------------------------
void __fastcall sub_180008210(__int64 a1, _QWORD **a2)
{
  _QWORD *v2; // rbx
  unsigned __int64 v3; // rdx
  _QWORD *v4; // rdi
  __int64 v5; // rax
  void *v6; // rcx

  *a2[1] = 0;
  v2 = *a2;
  if ( *a2 )
  {
    do
    {
      v3 = v2[5];
      v4 = (_QWORD *)*v2;
      if ( v3 > 0xF )
      {
        v5 = v2[2];
        if ( v3 + 1 < 0x1000 )
        {
          v6 = (void *)v2[2];
        }
        else
        {
          v6 = *(void **)(v5 - 8);
          if ( (unsigned __int64)(v5 - (_QWORD)v6 - 8) > 0x1F )
            __fastfail(5u);
        }
        j_j_free(v6);
      }
      v2[4] = 0;
      v2[5] = 15;
      *((_BYTE *)v2 + 16) = 0;
      j_j_free(v2);
      v2 = v4;
    }
    while ( v4 );
  }
}

//----- (00000001800082B0) ----------------------------------------------------
void __fastcall sub_1800082B0(__int64 a1, _QWORD **a2)
{
  _QWORD *v2; // rbx
  unsigned __int64 v3; // rdx
  _QWORD *v4; // rdi
  __int64 v5; // rax
  void *v6; // rcx

  *a2[1] = 0;
  v2 = *a2;
  if ( *a2 )
  {
    do
    {
      v3 = v2[6];
      v4 = (_QWORD *)*v2;
      if ( v3 > 0xF )
      {
        v5 = v2[3];
        if ( v3 + 1 < 0x1000 )
        {
          v6 = (void *)v2[3];
        }
        else
        {
          v6 = *(void **)(v5 - 8);
          if ( (unsigned __int64)(v5 - (_QWORD)v6 - 8) > 0x1F )
            __fastfail(5u);
        }
        j_j_free(v6);
      }
      v2[5] = 0;
      v2[6] = 15;
      *((_BYTE *)v2 + 24) = 0;
      j_j_free(v2);
      v2 = v4;
    }
    while ( v4 );
  }
}

//----- (0000000180008470) ----------------------------------------------------
__int64 __fastcall sub_180008470(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r9
  char *v6; // r8
  __int64 v7; // rcx
  __int64 result; // rax
  unsigned __int64 v9; // rsi
  _QWORD *v10; // rdi
  void *v11; // rax
  char *v12; // rax
  __int64 v13; // rcx
  char *v14; // rcx
  unsigned __int64 v15; // rcx

  v3 = *(_QWORD *)(a1 + 8);
  v6 = *(char **)a1;
  v7 = v3 - *(_QWORD *)a1;
  result = v7 >> 3;
  if ( v7 >> 3 >= a2 )
  {
    v15 = (unsigned __int64)(v7 + 7) >> 3;
    if ( (unsigned __int64)v6 > v3 )
      v15 = 0;
    if ( v15 )
    {
      memset64(v6, a3, v15);
      return a3;
    }
    return result;
  }
  if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_23;
  v9 = 8 * a2;
  if ( 8 * a2 )
  {
    if ( v9 < 0x1000 )
    {
      v10 = sub_18000E800(8 * a2);
      goto LABEL_10;
    }
    if ( v9 + 39 >= v9 )
    {
      v11 = sub_18000E800(v9 + 39);
      if ( !v11 )
        goto LABEL_13;
      v10 = (_QWORD *)(((unsigned __int64)v11 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v10 - 1) = v11;
      goto LABEL_10;
    }
LABEL_23:
    Concurrency::cancel_current_task();
  }
  v10 = 0;
LABEL_10:
  v12 = *(char **)a1;
  v13 = (__int64)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3;
  if ( v13 )
  {
    if ( (unsigned __int64)(8 * v13) < 0x1000 )
    {
      v14 = *(char **)a1;
    }
    else
    {
      v14 = (char *)*((_QWORD *)v12 - 1);
      if ( (unsigned __int64)(v12 - v14 - 8) > 0x1F )
LABEL_13:
        __fastfail(5u);
    }
    j_j_free(v14);
  }
  result = (__int64)&v10[v9 / 8];
  *(_QWORD *)a1 = v10;
  *(_QWORD *)(a1 + 8) = &v10[v9 / 8];
  for ( *(_QWORD *)(a1 + 16) = &v10[v9 / 8]; v10 != (_QWORD *)result; ++v10 )
    *v10 = a3;
  return result;
}

//----- (00000001800085D0) ----------------------------------------------------
int __fastcall sub_1800085D0(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rcx
  __int64 v3; // rbp
  unsigned __int64 v4; // rcx
  __int64 v5; // rbx
  unsigned __int64 v6; // rax
  __int64 v7; // r9
  _QWORD *v8; // rdi
  _QWORD *v9; // rsi
  unsigned __int64 v10; // r10
  _QWORD *v11; // r8
  size_t v12; // r14
  size_t v13; // rdx
  __int64 i; // rcx
  _QWORD *v15; // r12
  _QWORD *v16; // r13
  _QWORD *v17; // rbx
  const void *v18; // rdx
  const void *v19; // rcx
  _QWORD *v20; // r8
  _QWORD *v21; // rdx
  _QWORD *v22; // rcx
  const void *v23; // rdx
  const void *v24; // rcx
  _QWORD *v25; // rdx
  _QWORD *v26; // rcx
  _QWORD *v27; // r8
  _QWORD *v28; // rdx
  _QWORD *v29; // rcx

  _BitScanReverse64(&v2, 0xFFFFFFFFFFFFFFFuLL);
  if ( a2 > 1LL << v2 )
    std::_Xlength_error("invalid hash bucket count");
  v3 = qword_1800175C8;
  _BitScanReverse64(&v4, (a2 - 1) | 1);
  v5 = 1LL << ((unsigned __int8)v4 + 1);
  LODWORD(v6) = sub_180008470((__int64)&qword_1800175D8, 2 * v5, qword_1800175C8);
  v7 = v5 - 1;
  qword_1800175F0 = v5 - 1;
  qword_1800175F8 = v5;
  v8 = *(_QWORD **)qword_1800175C8;
  v9 = *(_QWORD **)qword_1800175C8;
  if ( *(_QWORD *)qword_1800175C8 != v3 )
  {
    while ( 1 )
    {
      v10 = v8[5];
      v11 = v8 + 2;
      v9 = (_QWORD *)*v9;
      LODWORD(v6) = -2078137563;
      if ( v10 > 0xF )
        v11 = (_QWORD *)v8[2];
      v12 = v8[4];
      v13 = 0;
      for ( i = 0xCBF29CE484222325uLL; v13 < v12; i = 0x100000001B3LL * (v6 ^ i) )
        v6 = *((unsigned __int8 *)v11 + v13++);
      v15 = (_QWORD *)(16 * (v7 & i) + qword_1800175D8);
      v16 = (_QWORD *)*v15;
      if ( *v15 == v3 )
      {
        *v15 = v8;
        v15[1] = v8;
        goto LABEL_35;
      }
      v17 = (_QWORD *)v15[1];
      if ( v17[5] <= 0xFu )
        v18 = v17 + 2;
      else
        v18 = (const void *)v17[2];
      v19 = v8 + 2;
      if ( v10 > 0xF )
        v19 = (const void *)v8[2];
      if ( v12 != v17[4] )
        goto LABEL_22;
      if ( v12 )
      {
        LODWORD(v6) = memcmp(v19, v18, v8[4]);
        if ( (_DWORD)v6 )
          break;
      }
      v20 = (_QWORD *)*v17;
      if ( (_QWORD *)*v17 != v8 )
      {
        v21 = (_QWORD *)v8[1];
        *v21 = v9;
        v22 = (_QWORD *)v9[1];
        *v22 = v20;
        v6 = v20[1];
        *(_QWORD *)v6 = v8;
        v20[1] = v22;
        v9[1] = v21;
        v8[1] = v6;
      }
      v15[1] = v8;
LABEL_35:
      v8 = v9;
      if ( v9 == (_QWORD *)v3 )
        return v6;
      v7 = qword_1800175F0;
    }
    v10 = v8[5];
LABEL_22:
    if ( v16 == v17 )
    {
LABEL_34:
      v25 = (_QWORD *)v8[1];
      *v25 = v9;
      v26 = (_QWORD *)v9[1];
      *v26 = v17;
      v6 = v17[1];
      *(_QWORD *)v6 = v8;
      v17[1] = v26;
      v9[1] = v25;
      v8[1] = v6;
      *v15 = v8;
      goto LABEL_35;
    }
    while ( 1 )
    {
      v17 = (_QWORD *)v17[1];
      if ( v17[5] <= 0xFu )
        v23 = v17 + 2;
      else
        v23 = (const void *)v17[2];
      if ( v10 <= 0xF )
        v24 = v8 + 2;
      else
        v24 = (const void *)v8[2];
      if ( v12 == v17[4] )
      {
        if ( !v12 || !memcmp(v24, v23, v12) )
        {
          v27 = (_QWORD *)*v17;
          v28 = (_QWORD *)v8[1];
          *v28 = v9;
          v29 = (_QWORD *)v9[1];
          *v29 = v27;
          v6 = v27[1];
          *(_QWORD *)v6 = v8;
          v27[1] = v29;
          v9[1] = v28;
          v8[1] = v6;
          goto LABEL_35;
        }
        v10 = v8[5];
      }
      if ( v16 == v17 )
        goto LABEL_34;
    }
  }
  return v6;
}
// 180011140: using guessed type void __noreturn std::_Xlength_error(const char *);
// 1800175C8: using guessed type __int64 qword_1800175C8;
// 1800175D8: using guessed type __int64 qword_1800175D8;
// 1800175F0: using guessed type __int64 qword_1800175F0;
// 1800175F8: using guessed type __int64 qword_1800175F8;

//----- (0000000180008830) ----------------------------------------------------
__int64 __fastcall sub_180008830(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // rcx
  __int64 v3; // rbx
  unsigned __int64 v4; // rcx
  __int64 v5; // rdi
  __int64 result; // rax
  __int64 v7; // r9
  _QWORD *v8; // rcx
  _QWORD *v9; // rdx
  __int64 *v10; // r11
  __int64 v11; // r9
  int v12; // r8d
  __int64 v13; // r10
  _QWORD *v14; // r9
  _QWORD *v15; // r8
  _QWORD *v16; // r10
  __int64 *v17; // r9
  _QWORD *v18; // r8
  __int64 v19; // r10
  _QWORD *v20; // r9
  _QWORD *v21; // r8

  _BitScanReverse64(&v2, 0xFFFFFFFFFFFFFFFuLL);
  if ( a2 > 1LL << v2 )
    std::_Xlength_error("invalid hash bucket count");
  v3 = qword_180017588;
  _BitScanReverse64(&v4, (a2 - 1) | 1);
  v5 = 1LL << ((unsigned __int8)v4 + 1);
  result = sub_180008470((__int64)&qword_180017598, 2 * v5, qword_180017588);
  v7 = v5 - 1;
  qword_1800175B0 = v5 - 1;
  qword_1800175B8 = v5;
  v8 = *(_QWORD **)qword_180017588;
  v9 = *(_QWORD **)qword_180017588;
  if ( *(_QWORD *)qword_180017588 != v3 )
  {
    while ( 1 )
    {
      v9 = (_QWORD *)*v9;
      result = *((unsigned __int8 *)v8 + 19);
      v10 = (__int64 *)(qword_180017598
                      + 16
                      * (v7
                       & (0x100000001B3LL
                        * (result
                         ^ (0x100000001B3LL
                          * (*((unsigned __int8 *)v8 + 18)
                           ^ (0x100000001B3LL
                            * (*((unsigned __int8 *)v8 + 17)
                             ^ (0x100000001B3LL * (*((unsigned __int8 *)v8 + 16) ^ 0xCBF29CE484222325uLL))))))))));
      v11 = *v10;
      if ( *v10 == v3 )
      {
        *v10 = (__int64)v8;
        v10[1] = (__int64)v8;
      }
      else
      {
        result = v10[1];
        v12 = *((_DWORD *)v8 + 4);
        if ( v12 == *(_DWORD *)(result + 16) )
        {
          v13 = *(_QWORD *)result;
          if ( *(_QWORD **)result != v8 )
          {
            v14 = (_QWORD *)v8[1];
            *v14 = v9;
            v15 = (_QWORD *)v9[1];
            *v15 = v13;
            result = *(_QWORD *)(v13 + 8);
            *(_QWORD *)result = v8;
            *(_QWORD *)(v13 + 8) = v15;
            v9[1] = v14;
            v8[1] = result;
          }
          v10[1] = (__int64)v8;
        }
        else if ( v11 == result )
        {
LABEL_13:
          v16 = (_QWORD *)v8[1];
          *v16 = v9;
          v17 = (__int64 *)v9[1];
          *v17 = result;
          v18 = *(_QWORD **)(result + 8);
          *v18 = v8;
          *(_QWORD *)(result + 8) = v17;
          v9[1] = v16;
          v8[1] = v18;
          *v10 = (__int64)v8;
        }
        else
        {
          while ( 1 )
          {
            result = *(_QWORD *)(result + 8);
            if ( v12 == *(_DWORD *)(result + 16) )
              break;
            if ( v11 == result )
              goto LABEL_13;
          }
          v19 = *(_QWORD *)result;
          v20 = (_QWORD *)v8[1];
          *v20 = v9;
          v21 = (_QWORD *)v9[1];
          *v21 = v19;
          result = *(_QWORD *)(v19 + 8);
          *(_QWORD *)result = v8;
          *(_QWORD *)(v19 + 8) = v21;
          v9[1] = v20;
          v8[1] = result;
        }
      }
      v8 = v9;
      if ( v9 == (_QWORD *)v3 )
        break;
      v7 = qword_1800175B0;
    }
  }
  return result;
}
// 180011140: using guessed type void __noreturn std::_Xlength_error(const char *);
// 180017588: using guessed type __int64 qword_180017588;
// 180017598: using guessed type __int64 qword_180017598;
// 1800175B0: using guessed type __int64 qword_1800175B0;
// 1800175B8: using guessed type __int64 qword_1800175B8;

//----- (00000001800089E0) ----------------------------------------------------
bool __fastcall sub_1800089E0(const void *a1, char *a2)
{
  __int64 v4; // rdx
  __int64 v5; // r8
  struct _MEMORY_BASIC_INFORMATION Buffer; // [rsp+20h] [rbp-48h] BYREF

  VirtualQuery(a1, &Buffer, 0x30u);
  if ( *(_WORD *)Buffer.AllocationBase != 23117 )
    return 0;
  v4 = *((int *)Buffer.AllocationBase + 15);
  if ( *(_DWORD *)((char *)Buffer.AllocationBase + v4) != 17744 )
    return 0;
  v5 = *(unsigned int *)((char *)Buffer.AllocationBase + v4 + 232);
  return a2 >= (char *)Buffer.AllocationBase + v5
      && a2 < (char *)Buffer.AllocationBase + v5 + *(unsigned int *)((char *)Buffer.AllocationBase + v4 + 236);
}

//----- (0000000180008A80) ----------------------------------------------------
__int64 __fastcall sub_180008A80(char *a1)
{
  char v1; // dl
  __int64 result; // rax
  char v3; // al

  v1 = *a1;
  if ( *a1 == -112 )
    return 1;
  if ( v1 == 102 )
  {
    if ( a1[1] == -112 )
      return 2;
    if ( a1[1] == 15 && a1[2] == 31 && a1[3] == 68 && !a1[4] && !a1[5] )
      return 6;
    v3 = a1[1];
    if ( v3 == 15 )
    {
      if ( a1[2] == 31 && a1[3] == -124 && !a1[4] && !a1[5] && !a1[6] && !a1[7] )
      {
        result = 0;
        if ( !a1[8] )
          return 9;
        return result;
      }
      return 0;
    }
    if ( v3 != 102 )
      return 0;
    if ( a1[2] == 15 )
    {
      if ( a1[3] != 31 || a1[4] != -124 || a1[5] || a1[6] || a1[7] || a1[8] )
        return 0;
      result = 0;
      if ( !a1[9] )
        return 10;
    }
    else
    {
      if ( a1[2] != 102 || a1[3] != 15 || a1[4] != 31 || a1[5] != -124 || a1[6] || a1[7] || a1[8] || a1[9] )
        return 0;
      result = 0;
      if ( !a1[10] )
        return 11;
    }
  }
  else
  {
    if ( v1 != 15 )
      return v1 == -52;
    if ( a1[1] != 31 )
      return 0;
    switch ( a1[2] )
    {
      case 0:
        return 3;
      case 0x40:
        if ( !a1[3] )
          return 4;
        return 0;
      case 0x44:
        if ( !a1[3] && !a1[4] )
          return 5;
        return 0;
      case 0x80:
        if ( a1[3] || a1[4] || a1[5] )
          return 0;
        result = 0;
        if ( !a1[6] )
          return 7;
        break;
      default:
        if ( a1[2] != -124 || a1[3] || a1[4] || a1[5] || a1[6] )
          return 0;
        result = 0;
        if ( !a1[7] )
          return 8;
        break;
    }
  }
  return result;
}

//----- (0000000180008C80) ----------------------------------------------------
LPVOID __fastcall sub_180008C80(char *a1, unsigned __int64 a2)
{
  __int64 v4; // rax
  char *v5; // rbx
  __int64 v7; // rcx
  LPVOID result; // rax
  struct _MEMORY_BASIC_INFORMATION v10; // [rsp+20h] [rbp-48h] BYREF

  v4 = (unsigned __int16)a1;
  v5 = a1;
  v7 = (__int64)&a1[-(unsigned __int16)a1 + 0x10000];
  if ( v4 )
    v5 = (char *)v7;
  while ( (unsigned __int64)v5 < a2 )
  {
    if ( (unsigned __int64)(v5 - 1879048192) > 0x10000000 )
    {
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vmovups [rsp+68h+var_48], ymm0
      }
      *(_OWORD *)&v10.BaseAddress = *(_OWORD *)_RT0.m256i_i8;
      __asm { vmovups [rsp+68h+var_48+10h], ymm0 }
      __asm { vzeroupper }
      if ( !VirtualQuery(v5, &v10, 0x30u) )
        return 0;
      if ( v10.State == 0x10000 && v10.RegionSize >= 0x10000 )
      {
        result = VirtualAlloc(v5, 0x10000u, 0x3000u, 0x40u);
        if ( result )
          return result;
        if ( GetLastError() == 1655 )
          return 0;
        v5 += 0x10000;
      }
      else
      {
        v5 = (char *)v10.BaseAddress + v10.RegionSize;
        if ( LOWORD(v10.RegionSize) + LOWORD(v10.BaseAddress) )
          v5 = (char *)v10.BaseAddress
             + v10.RegionSize
             - (unsigned __int16)(LOWORD(v10.RegionSize) + LOWORD(v10.BaseAddress))
             + 0x10000;
      }
    }
    else
    {
      v5 += 0x8000000;
    }
  }
  return 0;
}

//----- (0000000180008DA0) ----------------------------------------------------
LPVOID __fastcall sub_180008DA0(unsigned __int64 a1, __int64 a2)
{
  char *v4; // rdx
  char *v6; // rbx
  LPVOID result; // rax
  struct _MEMORY_BASIC_INFORMATION v9; // [rsp+20h] [rbp-48h] BYREF

  v4 = (char *)(a2 - 0x10000);
  v6 = &v4[-(unsigned __int16)v4];
  if ( !(_WORD)v4 )
    v6 = v4;
  while ( (unsigned __int64)v6 > a1 )
  {
    if ( (unsigned __int64)(v6 - 1879048192) > 0x10000000 )
    {
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vmovups [rsp+68h+var_48], ymm0
      }
      *(_OWORD *)&v9.BaseAddress = *(_OWORD *)_RT0.m256i_i8;
      __asm { vmovups [rsp+68h+var_48+10h], ymm0 }
      __asm { vzeroupper }
      if ( !VirtualQuery(v6, &v9, 0x30u) )
        return 0;
      if ( v9.State == 0x10000 && v9.RegionSize >= 0x10000 )
      {
        result = VirtualAlloc(v6, 0x10000u, 0x3000u, 0x40u);
        if ( result )
          return result;
        if ( GetLastError() == 1655 )
          return 0;
        v6 -= 0x10000;
      }
      else
      {
        v6 = (char *)v9.AllocationBase - LOWORD(v9.AllocationBase) - 0x10000;
        if ( !LOWORD(v9.AllocationBase) )
          v6 = (char *)v9.AllocationBase - 0x10000;
      }
    }
    else
    {
      v6 -= 0x8000000;
    }
  }
  return 0;
}

//----- (0000000180008EB0) ----------------------------------------------------
LPVOID __fastcall sub_180008EB0(char *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  LPVOID result; // rax
  __int64 v7; // rsi

  if ( (unsigned __int64)a1 > 0x40000000 )
  {
    result = sub_180008DA0(a2, (__int64)(a1 - 0x40000000));
    if ( result )
      return result;
    if ( (unsigned __int64)a1 >= 0xFFFFFFFF40000000uLL )
    {
      v7 = (__int64)(a1 + 0x40000000);
      goto LABEL_7;
    }
  }
  v7 = (__int64)(a1 + 0x40000000);
  result = sub_180008C80(a1 + 0x40000000, a3);
  if ( result )
    return result;
  if ( (unsigned __int64)a1 > 0x40000000 )
  {
LABEL_7:
    result = sub_180008C80(a1 - 0x40000000, (unsigned __int64)a1);
    if ( result )
      return result;
  }
  if ( (unsigned __int64)a1 >= 0xFFFFFFFF40000000uLL || (result = sub_180008DA0((unsigned __int64)a1, v7)) == 0 )
  {
    result = sub_180008DA0(a2, (__int64)a1);
    if ( !result )
      return sub_180008C80(a1, a3);
  }
  return result;
}

//----- (0000000180008F70) ----------------------------------------------------
unsigned __int64 __fastcall sub_180008F70(unsigned __int64 a1)
{
  unsigned __int64 v1; // rbx
  unsigned __int64 v3; // rdi
  __int64 v4; // rcx
  unsigned __int64 v5; // rcx
  _QWORD *v6; // rdx
  LPCVOID v7; // rax
  unsigned __int64 v8; // rcx
  _QWORD *v9; // rcx
  unsigned __int64 v10; // rax
  _QWORD *v11; // rax
  _QWORD *v12; // r9
  __int64 v13; // r8
  __int64 v14; // rcx
  _QWORD *v15; // rcx
  unsigned __int64 result; // rax

  v1 = a1 - 2146959360;
  if ( a1 <= 0x7FF80000 )
    v1 = 0x80000;
  v3 = a1 + 2146959360;
  if ( a1 >= 0xFFFFFFFF80000000uLL )
    v3 = -524288;
  if ( *(_BYTE *)a1 == 0xFF )
  {
    if ( *(_BYTE *)(a1 + 1) != 37 )
      goto LABEL_16;
    v4 = *(int *)(a1 + 2) + 6LL;
  }
  else
  {
    if ( *(_BYTE *)a1 != 0xE9 )
      goto LABEL_16;
    v4 = *(int *)(a1 + 1) + 5LL;
  }
  v5 = a1 + v4;
  if ( v5 >= a1 )
  {
    v1 = v5 - 2146959360;
    if ( v5 <= 0x7FF80000 )
      v1 = 0x80000;
  }
  else if ( v5 >= 0xFFFFFFFF80000000uLL )
  {
    v3 = -524288;
  }
  else
  {
    v3 = v5 + 2146959360;
  }
LABEL_16:
  v6 = (_QWORD *)qword_180017600;
  v7 = lpBaseAddress;
  if ( qword_180017600 )
  {
LABEL_19:
    v8 = v6[2];
    if ( v8 && v8 >= v1 && v8 <= v3 )
      goto LABEL_33;
    goto LABEL_22;
  }
  if ( lpBaseAddress )
  {
    v6 = lpBaseAddress;
    qword_180017600 = (__int64)lpBaseAddress;
    goto LABEL_19;
  }
LABEL_22:
  qword_180017600 = (__int64)lpBaseAddress;
  v6 = lpBaseAddress;
  if ( lpBaseAddress )
  {
    v9 = lpBaseAddress;
    while ( 1 )
    {
      if ( v7 )
      {
        v10 = v9[2];
        if ( v10 )
        {
          if ( v10 >= v1 && v10 <= v3 )
            break;
        }
      }
      v6 = (_QWORD *)v9[1];
      qword_180017600 = (__int64)v6;
      v7 = v6;
      v9 = v6;
      if ( !v6 )
        goto LABEL_29;
    }
  }
  else
  {
LABEL_29:
    v11 = sub_180008EB0((char *)(a1 - (unsigned __int16)a1), v1, v3);
    v6 = v11;
    if ( !v11 )
      goto LABEL_36;
    *(_DWORD *)v11 = 1383232612;
    v12 = 0;
    v11[2] = 0;
    v13 = 680;
    v11[1] = lpBaseAddress;
    lpBaseAddress = v11;
    qword_180017600 = (__int64)v11;
    do
    {
      v14 = 3 * v13--;
      v15 = &v11[4 * v14 + 12];
      v15[9] = v12;
      v12 = v15;
    }
    while ( v13 != 1 );
    v11[2] = v15;
  }
LABEL_33:
  result = v6[2];
  if ( result >= v1 && result <= v3 )
  {
    __asm { vmovdqu ymm0, cs:ymmword_180014120 }
    v6[2] = *(_QWORD *)(result + 72);
    __asm
    {
      vmovups ymmword ptr [rax], ymm0
      vmovups ymmword ptr [rax+20h], ymm0
      vmovups ymmword ptr [rax+40h], ymm0
      vzeroupper
    }
    return result;
  }
LABEL_36:
  __asm { vzeroupper }
  return 0;
}
// 180017600: using guessed type __int64 qword_180017600;

//----- (0000000180009150) ----------------------------------------------------
DWORD sub_180009150()
{
  _QWORD *v0; // rbx
  DWORD result; // eax
  DWORD flOldProtect; // [rsp+20h] [rbp-18h] BYREF

  if ( dword_180017578 || _InterlockedCompareExchange(&dword_180017578, GetCurrentThreadId(), 0) )
    return 4317;
  v0 = lpBaseAddress;
  Block = 0;
  qword_180017618 = 0;
  qword_180017608 = 0;
  if ( lpBaseAddress )
  {
    while ( VirtualProtect(v0, 0x10000u, 0x40u, &flOldProtect) )
    {
      v0 = (_QWORD *)v0[1];
      if ( !v0 )
        goto LABEL_6;
    }
    result = GetLastError();
  }
  else
  {
LABEL_6:
    result = 0;
  }
  dword_1800174AC = result;
  return result;
}
// 1800174AC: using guessed type int dword_1800174AC;
// 180017578: using guessed type int dword_180017578;
// 180017608: using guessed type __int64 qword_180017608;

//----- (0000000180009230) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
__int64 __fastcall sub_180009230(double _XMM0_8)
{
  int v2; // edx
  void *v4; // rdi
  void *v6; // rbx
  HANDLE v7; // rax
  _QWORD *v8; // rbx
  void *v9; // rdi
  HANDLE *v10; // rdi
  HANDLE *v11; // rbx
  void *v12; // rbx
  int i; // r14d
  __int64 v14; // rcx
  __int64 v15; // rax
  __int64 v16; // rcx
  int v17; // eax
  void *v18; // rcx
  __int64 v19; // rax
  size_t v20; // r8
  _QWORD *v21; // rdi
  void *v22; // rcx
  _QWORD *v23; // rbx
  DWORD64 Rip; // rcx
  DWORD64 v25; // r9
  int v26; // eax
  unsigned __int8 v27; // r8
  DWORD64 v28; // rax
  DWORD64 v29; // r9
  __int64 v30; // r10
  int v31; // edx
  unsigned int v32; // r8d
  __int64 v33; // rax
  void *v34; // rcx
  HANDLE CurrentProcess; // rax
  void *v36; // rdi
  void *v37; // rbp
  void *v39; // rbx
  LPCVOID *v40; // r9
  LPCVOID *v41; // rbx
  int v42; // edx
  unsigned __int64 v43; // rax
  HANDLE v44; // rax
  _QWORD *v45; // rbx
  void *v46; // rdi
  HANDLE *v47; // rdi
  HANDLE *v48; // rbx
  DWORD flOldProtect[4]; // [rsp+20h] [rbp-4F8h] BYREF
  struct _CONTEXT Context; // [rsp+30h] [rbp-4E8h] BYREF

  if ( dword_180017578 != GetCurrentThreadId() )
    return 4317;
  if ( !dword_1800174AC )
  {
    v12 = Block;
    for ( i = 0; v12; v12 = *(void **)v12 )
    {
      v14 = *((_QWORD *)v12 + 4);
      if ( *((_DWORD *)v12 + 2) )
      {
        memcpy(*((void **)v12 + 3), (const void *)(v14 + 32), *(unsigned __int8 *)(v14 + 62));
        v15 = *((_QWORD *)v12 + 3);
      }
      else
      {
        *(_WORD *)(v14 + 88) = 9727;
        *(_DWORD *)(v14 + 90) = -14;
        v16 = *((_QWORD *)v12 + 3);
        v17 = *((_QWORD *)v12 + 4) + 88 - v16 - 5;
        *(_BYTE *)v16 = -23;
        *(_DWORD *)(v16 + 1) = v17;
        v18 = (void *)(v16 + 5);
        v19 = *((_QWORD *)v12 + 4);
        v20 = *(_QWORD *)(v19 + 72) - (_QWORD)v18;
        if ( (unsigned __int64)v18 > *(_QWORD *)(v19 + 72) )
          v20 = 0;
        if ( v20 )
        {
          LOBYTE(v2) = -52;
          memset(v18, v2, v20);
        }
        v15 = *((_QWORD *)v12 + 4);
      }
      **((_QWORD **)v12 + 2) = v15;
    }
    v21 = qword_180017618;
    if ( !qword_180017618 )
    {
LABEL_47:
      CurrentProcess = GetCurrentProcess();
      v36 = Block;
      v37 = CurrentProcess;
      if ( Block )
      {
        do
        {
          VirtualProtect(
            *((LPVOID *)v36 + 3),
            *(unsigned __int8 *)(*((_QWORD *)v36 + 4) + 62LL),
            *((_DWORD *)v36 + 10),
            flOldProtect);
          FlushInstructionCache(v37, *((LPCVOID *)v36 + 3), *(unsigned __int8 *)(*((_QWORD *)v36 + 4) + 62LL));
          if ( *((_DWORD *)v36 + 2) )
          {
            _RCX = *((_QWORD *)v36 + 4);
            if ( _RCX )
            {
              __asm
              {
                vpxor   xmm0, xmm0, xmm0
                vmovups ymmword ptr [rcx], ymm0
                vmovups ymmword ptr [rcx+20h], ymm0
                vmovups ymmword ptr [rcx+40h], ymm0
              }
              i = 1;
              *(_QWORD *)(_RCX + 72) = *(_QWORD *)((_RCX & 0xFFFFFFFFFFFF0000uLL) + 0x10);
              *(_QWORD *)((_RCX & 0xFFFFFFFFFFFF0000uLL) + 0x10) = _RCX;
              *((_QWORD *)v36 + 4) = 0;
            }
          }
          v39 = *(void **)v36;
          __asm { vzeroupper }
          j_j_free(v36);
          v36 = v39;
        }
        while ( v39 );
      }
      Block = 0;
      if ( i )
      {
        if ( !dword_1800174A4 )
        {
          v40 = (LPCVOID *)lpBaseAddress;
          v41 = &lpBaseAddress;
          if ( lpBaseAddress )
          {
            do
            {
              if ( *(_DWORD *)v40 == 1383232612 )
              {
                v42 = 0;
                while ( 1 )
                {
                  v43 = (unsigned __int64)v40[12 * v42 + 21];
                  if ( v43 )
                  {
                    if ( v43 < (unsigned __int64)v40 || v43 >= (unsigned __int64)(v40 + 0x2000) )
                      break;
                  }
                  if ( (unsigned int)++v42 >= 0x2A9 )
                  {
                    *v41 = v40[1];
                    VirtualFree(v40, 0, 0x8000u);
                    qword_180017600 = 0;
                    goto LABEL_62;
                  }
                }
              }
              v41 = v40 + 1;
LABEL_62:
              v40 = (LPCVOID *)*v41;
            }
            while ( *v41 );
          }
        }
      }
      v44 = GetCurrentProcess();
      v45 = lpBaseAddress;
      v46 = v44;
      if ( lpBaseAddress )
      {
        do
        {
          VirtualProtect(v45, 0x10000u, 0x20u, flOldProtect);
          FlushInstructionCache(v46, v45, 0x10000u);
          v45 = (_QWORD *)v45[1];
        }
        while ( v45 );
      }
      v47 = (HANDLE *)qword_180017618;
      if ( qword_180017618 )
      {
        do
        {
          ResumeThread(v47[1]);
          v48 = (HANDLE *)*v47;
          j_j_free(v47);
          v47 = v48;
        }
        while ( v48 );
      }
      goto LABEL_67;
    }
    while ( 1 )
    {
      v22 = (void *)v21[1];
      Context.ContextFlags = 1048579;
      if ( GetThreadContext(v22, &Context) )
      {
        v23 = Block;
        if ( Block )
          break;
      }
LABEL_46:
      v21 = (_QWORD *)*v21;
      if ( !v21 )
        goto LABEL_47;
    }
    Rip = Context.Rip;
    while ( 1 )
    {
      if ( *((_DWORD *)v23 + 2) )
      {
        v25 = v23[4];
        if ( Rip < v25 || Rip >= v25 + 96 )
          goto LABEL_45;
        v26 = 0;
        while ( 1 )
        {
          v27 = *(_BYTE *)(v26 + v25 + 64);
          if ( v27 >> 3 == LOBYTE(Context.Rip) - (_BYTE)v25 )
            break;
          if ( (unsigned int)++v26 >= 8 )
          {
            v28 = v23[3];
            goto LABEL_44;
          }
        }
        v28 = v23[3] + (v27 & 7);
      }
      else
      {
        v29 = v23[3];
        if ( Rip < v29 )
          goto LABEL_45;
        v30 = v23[4];
        if ( Rip >= v29 + *(unsigned __int8 *)(v30 + 62) )
          goto LABEL_45;
        v31 = 0;
        while ( 1 )
        {
          v32 = *(unsigned __int8 *)(v31 + v30 + 64);
          if ( (v32 & 7) == LOBYTE(Context.Rip) - (_BYTE)v29 )
            break;
          if ( (unsigned int)++v31 >= 8 )
          {
            v33 = 0;
            goto LABEL_43;
          }
        }
        v33 = v32 >> 3;
LABEL_43:
        v28 = v30 + v33;
      }
LABEL_44:
      v34 = (void *)v21[1];
      Context.Rip = v28;
      SetThreadContext(v34, &Context);
      Rip = Context.Rip;
LABEL_45:
      v23 = (_QWORD *)*v23;
      if ( !v23 )
        goto LABEL_46;
    }
  }
  if ( dword_180017578 == GetCurrentThreadId() )
  {
    v4 = Block;
    if ( Block )
    {
      do
      {
        VirtualProtect(
          *((LPVOID *)v4 + 3),
          *(unsigned __int8 *)(*((_QWORD *)v4 + 4) + 62LL),
          *((_DWORD *)v4 + 10),
          flOldProtect);
        if ( !*((_DWORD *)v4 + 2) )
        {
          _RCX = *((_QWORD *)v4 + 4);
          if ( _RCX )
          {
            __asm
            {
              vpxor   xmm0, xmm0, xmm0
              vmovups ymmword ptr [rcx], ymm0
              vmovups ymmword ptr [rcx+20h], ymm0
              vmovups ymmword ptr [rcx+40h], ymm0
            }
            *(_QWORD *)(_RCX + 72) = *(_QWORD *)((_RCX & 0xFFFFFFFFFFFF0000uLL) + 0x10);
            *(_QWORD *)((_RCX & 0xFFFFFFFFFFFF0000uLL) + 0x10) = _RCX;
            *((_QWORD *)v4 + 4) = 0;
          }
        }
        v6 = *(void **)v4;
        __asm { vzeroupper }
        j_j_free(v4);
        v4 = v6;
      }
      while ( v6 );
    }
    Block = 0;
    v7 = GetCurrentProcess();
    v8 = lpBaseAddress;
    v9 = v7;
    if ( lpBaseAddress )
    {
      do
      {
        VirtualProtect(v8, 0x10000u, 0x20u, flOldProtect);
        FlushInstructionCache(v9, v8, 0x10000u);
        v8 = (_QWORD *)v8[1];
      }
      while ( v8 );
    }
    v10 = (HANDLE *)qword_180017618;
    if ( qword_180017618 )
    {
      do
      {
        ResumeThread(v10[1]);
        v11 = (HANDLE *)*v10;
        j_j_free(v10);
        v10 = v11;
      }
      while ( v11 );
    }
LABEL_67:
    qword_180017618 = 0;
    dword_180017578 = 0;
  }
  return (unsigned int)dword_1800174AC;
}
// 180009230: inconsistent variable size for 'xmm0_8.8'
// 1800174A4: using guessed type int dword_1800174A4;
// 1800174AC: using guessed type int dword_1800174AC;
// 180017578: using guessed type int dword_180017578;
// 180017600: using guessed type __int64 qword_180017600;

//----- (00000001800097F0) ----------------------------------------------------
__int64 __fastcall sub_1800097F0(HANDLE hThread)
{
  __int64 result; // rax
  _QWORD *v3; // rdi
  DWORD LastError; // ebx

  result = (unsigned int)dword_1800174AC;
  if ( !dword_1800174AC )
  {
    if ( hThread == GetCurrentThread() )
    {
      return 0;
    }
    else
    {
      v3 = sub_18000E800(0x10u);
      if ( SuspendThread(hThread) == -1 )
      {
        LastError = GetLastError();
        j_j_free(v3);
        dword_1800174AC = LastError;
        qword_180017608 = 0;
        return LastError;
      }
      else
      {
        *v3 = qword_180017618;
        v3[1] = hThread;
        qword_180017618 = v3;
        return 0;
      }
    }
  }
  return result;
}
// 1800174AC: using guessed type int dword_1800174AC;
// 180017608: using guessed type __int64 qword_180017608;

//----- (0000000180009890) ----------------------------------------------------
__int64 __fastcall sub_180009890(_BYTE **a1, _BYTE *a2)
{
  _BYTE *v4; // rdi
  __int64 result; // rax
  _BYTE *v7; // rbx
  __int64 v8; // rsi
  _BYTE *v9; // rcx
  _BYTE *v10; // rsi
  __int64 v11; // rsi
  _BYTE *v12; // rcx
  _BYTE *v13; // rsi
  DWORD LastError; // ebp
  _QWORD *v16; // r12
  char *v17; // r8
  unsigned __int64 v18; // r15
  __m256 *v19; // rcx
  char *v20; // r13
  char *v21; // r14
  unsigned int v22; // edx
  unsigned int v23; // r9d
  unsigned __int64 v24; // rcx
  __int64 v25; // r10
  unsigned __int64 v26; // rax
  bool v27; // zf
  int v28; // eax
  __int64 v29; // r8
  _BYTE *v30; // r14
  SIZE_T v31; // r15
  int v32; // edx
  unsigned __int64 v33; // rcx
  _BYTE *v34; // rcx
  size_t v35; // r8
  unsigned int v37; // [rsp+30h] [rbp-E8h]
  int v39; // [rsp+40h] [rbp-D8h] BYREF
  DWORD flOldProtect[3]; // [rsp+44h] [rbp-D4h] BYREF
  __m256 v41; // [rsp+50h] [rbp-C8h] BYREF
  __m256 v42; // [rsp+70h] [rbp-A8h] BYREF
  __m256 v43; // [rsp+90h] [rbp-88h] BYREF

  v4 = a2;
  if ( !a2 )
  {
    result = 87;
    goto LABEL_84;
  }
  if ( dword_180017578 != GetCurrentThreadId() )
  {
    result = 4317;
    goto LABEL_84;
  }
  result = (unsigned int)dword_1800174AC;
  if ( dword_1800174AC )
    goto LABEL_84;
  if ( !a1 )
  {
    result = 6;
    goto LABEL_84;
  }
  v7 = *a1;
  if ( !*a1 )
  {
    dword_1800174AC = 6;
    result = 6;
    qword_180017608 = (__int64)a1;
    goto LABEL_84;
  }
  if ( *v7 == 0xFF && v7[1] == 37 )
  {
    v8 = *(int *)(v7 + 2);
    if ( sub_1800089E0(v7, &v7[v8 + 6]) )
      v7 = *(_BYTE **)&v7[v8 + 6];
  }
  if ( *v7 == 0xEB )
  {
    v7 += (char)v7[1] + 2;
    v9 = v7;
    if ( *v7 == 0xFF )
    {
      if ( v7[1] == 37 )
      {
        v10 = &v7[*(int *)(v7 + 2)];
        if ( sub_1800089E0(v7, v10 + 6) )
          v7 = *(_BYTE **)(v10 + 6);
      }
    }
    else if ( *v7 == 0xE9 )
    {
      v7 += *(int *)(v7 + 1) + 5;
      if ( *v7 == 0xFF && v7[1] == 37 && *(_DWORD *)(v7 + 2) == 4090 )
        v7 = v9;
    }
  }
  if ( *v4 == 0xFF && v4[1] == 37 )
  {
    v11 = *(int *)(v4 + 2);
    if ( sub_1800089E0(v4, &v4[v11 + 6]) )
      v4 = *(_BYTE **)&v4[v11 + 6];
  }
  if ( *v4 == 0xEB )
  {
    v4 += (char)v4[1] + 2;
    v12 = v4;
    if ( *v4 == 0xFF )
    {
      if ( v4[1] == 37 )
      {
        v13 = &v4[*(int *)(v4 + 2)];
        if ( sub_1800089E0(v4, v13 + 6) )
          v4 = *(_BYTE **)(v13 + 6);
      }
    }
    else if ( *v4 == 0xE9 )
    {
      v4 += *(int *)(v4 + 1) + 5;
      if ( *v4 == 0xFF && v4[1] == 37 && *(_DWORD *)(v4 + 2) == 4090 )
        v4 = v12;
    }
  }
  if ( v4 == v7 )
  {
    LastError = 0;
    if ( !dword_1800174A0 )
    {
      _RSI = 0;
      v16 = 0;
      goto LABEL_79;
    }
    goto LABEL_83;
  }
  v16 = sub_18000E800(0x30u);
  _RSI = sub_180008F70((unsigned __int64)v7);
  if ( !_RSI )
  {
    LastError = 8;
    goto LABEL_79;
  }
  v17 = v7;
  *(_QWORD *)(_RSI + 64) = 0;
  v37 = 0;
  v18 = _RSI;
  while ( 1 )
  {
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovups [rsp+118h+var_A8], ymm0
    }
    *(_QWORD *)&v42.m256_f32[6] = 0;
    *(_QWORD *)v42.m256_f32 = &v42.m256_f32[6];
    v19 = &v43;
    v39 = 0;
    if ( v18 )
      v19 = (__m256 *)v18;
    *(_QWORD *)&v42.m256_f32[2] = &v39;
    v20 = v17;
    v21 = v17;
    __asm
    {
      vmovups [rsp+118h+var_C8], ymm0
      vmovups [rsp+118h+var_88], ymm0
      vmovups [rsp+118h+var_68], ymm0
    }
    if ( v17 )
    {
      __asm { vzeroupper }
      v17 = (char *)(*((__int64 (__fastcall **)(__m256 *, char *, __m256 *, char *))&unk_18001A190
                     + 2 * (unsigned __int8)*v17
                     + 1))(
                      &v41,
                      (char *)&unk_18001A190 + 16 * (unsigned __int8)*v17,
                      v19,
                      v17);
    }
    else
    {
      __asm { vzeroupper }
      SetLastError(0xDu);
      v17 = 0;
    }
    v22 = (_DWORD)v17 - (_DWORD)v7;
    v18 += (unsigned __int64)&v17[v39 - (_QWORD)v20];
    *(_BYTE *)(v37 + _RSI + 64) = (8 * (v18 - _RSI)) ^ ((8 * (v18 - _RSI)) ^ ((_BYTE)v17 - (_BYTE)v7)) & 7;
    v23 = v37 + 1;
    v37 = v23;
    if ( v23 >= 8 )
      break;
    v24 = (unsigned __int8)*v21;
    if ( (unsigned __int8)(v24 + 62) <= 0x29u )
    {
      v25 = 0x28040000403LL;
      if ( _bittest64(&v25, (unsigned int)(v24 + 62)) )
        break;
    }
    if ( (_BYTE)v24 == 0xF3 )
    {
      if ( v21[1] == -61 )
        break;
    }
    else if ( (_BYTE)v24 == 0xFF )
    {
      v27 = v21[1] == 37;
LABEL_58:
      if ( v27 )
        break;
      goto LABEL_59;
    }
    LOBYTE(v24) = v24 - 38;
    if ( (unsigned __int8)v24 <= 0x3Fu )
    {
      v26 = 0xC000000001010101uLL;
      if ( _bittest64((const __int64 *)&v26, v24) )
      {
        if ( v21[1] == -1 )
        {
          v27 = v21[2] == 37;
          goto LABEL_58;
        }
      }
    }
LABEL_59:
    if ( v22 >= 5 )
      goto LABEL_67;
  }
  if ( v22 >= 5 )
  {
LABEL_66:
    if ( v23 <= 8 )
    {
LABEL_67:
      v30 = (_BYTE *)(_RSI + 30);
      if ( v18 > _RSI + 30 )
        __debugbreak();
      *(_BYTE *)(_RSI + 62) = v22;
      *v30 = v18 - _RSI;
      v31 = v22;
      memcpy((void *)(_RSI + 32), v7, v22);
      if ( v31 > 0x19 )
      {
        LastError = 6;
        goto LABEL_79;
      }
      v33 = _RSI + (unsigned __int8)*v30;
      *(_QWORD *)(_RSI + 72) = &v7[v31];
      *(_QWORD *)(_RSI + 80) = v4;
      *(_WORD *)v33 = 9727;
      *(_DWORD *)(v33 + 2) = _RSI - v33 + 66;
      v34 = (_BYTE *)(v33 + 6);
      v35 = v30 - v34;
      if ( v34 > v30 )
        v35 = 0;
      if ( v35 )
      {
        LOBYTE(v32) = -52;
        memset(v34, v32, v35);
      }
      flOldProtect[0] = 0;
      if ( !VirtualProtect(v7, v31, 0x40u, flOldProtect) )
      {
        LastError = GetLastError();
        goto LABEL_79;
      }
      v16[2] = a1;
      *((_DWORD *)v16 + 2) = 0;
      v16[4] = _RSI;
      v16[3] = v7;
      *((_DWORD *)v16 + 10) = flOldProtect[0];
      *v16 = Block;
      result = 0;
      Block = v16;
      goto LABEL_84;
    }
  }
  else
  {
    while ( 1 )
    {
      v28 = sub_180008A80(v17);
      if ( !v28 )
        break;
      v17 = (char *)(v28 + v29);
      v22 = (_DWORD)v17 - (_DWORD)v7;
      if ( (unsigned int)((_DWORD)v17 - (_DWORD)v7) >= 5 )
        goto LABEL_66;
    }
  }
  LastError = 9;
  if ( dword_1800174A0 )
    goto LABEL_80;
LABEL_79:
  dword_1800174AC = LastError;
  if ( _RSI )
  {
LABEL_80:
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovups ymmword ptr [rsi], ymm0
      vmovups ymmword ptr [rsi+20h], ymm0
      vmovups ymmword ptr [rsi+40h], ymm0
    }
    *(_QWORD *)(_RSI + 72) = *(_QWORD *)((_RSI & 0xFFFFFFFFFFFF0000uLL) + 0x10);
    *(_QWORD *)((_RSI & 0xFFFFFFFFFFFF0000uLL) + 0x10) = _RSI;
  }
  if ( v16 )
  {
    __asm { vzeroupper }
    j_j_free(v16);
  }
LABEL_83:
  qword_180017608 = (__int64)a1;
  result = LastError;
LABEL_84:
  __asm { vzeroupper }
  return result;
}
// 180009C0A: variable 'v29' is possibly undefined
// 180009C1B: variable 'v23' is possibly undefined
// 180009C90: variable 'v32' is possibly undefined
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800174A0: using guessed type int dword_1800174A0;
// 1800174AC: using guessed type int dword_1800174AC;
// 180017578: using guessed type int dword_180017578;
// 180017608: using guessed type __int64 qword_180017608;

//----- (0000000180009DB0) ----------------------------------------------------
__int64 __fastcall sub_180009DB0(const void **a1, _BYTE *a2)
{
  __int64 result; // rax
  _DWORD *v5; // rax
  char *v6; // rbx
  _DWORD *v7; // rsi
  __int64 v8; // r15
  char *v9; // rcx
  char *v10; // r15
  __int64 v11; // r15
  _BYTE *v12; // rcx
  _BYTE *v13; // r15
  unsigned __int64 v14; // rax
  SIZE_T v15; // rdx
  void *v16; // rdi
  DWORD LastError; // ebx
  DWORD flOldProtect; // [rsp+20h] [rbp-28h] BYREF

  if ( dword_180017578 != GetCurrentThreadId() )
    return 4317;
  result = (unsigned int)dword_1800174AC;
  if ( !dword_1800174AC )
  {
    if ( !a2 )
      return 87;
    if ( !a1 )
      return 6;
    if ( !*a1 )
    {
      dword_1800174AC = 6;
      qword_180017608 = (__int64)a1;
      return 6;
    }
    v5 = sub_18000E800(0x30u);
    v6 = (char *)*a1;
    v7 = v5;
    if ( *a1 )
    {
      if ( *v6 == -1 && v6[1] == 37 )
      {
        v8 = *(int *)(v6 + 2);
        if ( sub_1800089E0(*a1, &v6[v8 + 6]) )
          v6 = *(char **)&v6[v8 + 6];
      }
      if ( *v6 == -21 )
      {
        v6 += v6[1] + 2;
        v9 = v6;
        if ( *v6 == -1 )
        {
          if ( v6[1] == 37 )
          {
            v10 = &v6[*(int *)(v6 + 2)];
            if ( sub_1800089E0(v6, v10 + 6) )
              v6 = *(char **)(v10 + 6);
          }
        }
        else if ( *v6 == -23 )
        {
          v6 += *(int *)(v6 + 1) + 5;
          if ( *v6 == -1 && v6[1] == 37 && *(_DWORD *)(v6 + 2) == 4090 )
            v6 = v9;
        }
      }
    }
    if ( *a2 == 0xFF && a2[1] == 37 )
    {
      v11 = *(int *)(a2 + 2);
      if ( sub_1800089E0(a2, &a2[v11 + 6]) )
        a2 = *(_BYTE **)&a2[v11 + 6];
    }
    if ( *a2 == 0xEB )
    {
      a2 += (char)a2[1] + 2;
      v12 = a2;
      if ( *a2 == 0xFF )
      {
        if ( a2[1] == 37 )
        {
          v13 = &a2[*(int *)(a2 + 2)];
          if ( sub_1800089E0(a2, v13 + 6) )
            a2 = *(_BYTE **)(v13 + 6);
        }
      }
      else if ( *a2 == 0xE9 )
      {
        a2 += *(int *)(a2 + 1) + 5;
        if ( *a2 == 0xFF && a2[1] == 37 && *(_DWORD *)(a2 + 2) == 4090 )
          a2 = v12;
      }
    }
    v14 = (unsigned __int8)v6[62];
    if ( v6[62] && (v15 = (unsigned __int8)v6[62], v14 <= 0x1E) && *((_BYTE **)v6 + 10) == a2 )
    {
      v16 = (void *)(*((_QWORD *)v6 + 9) - v14);
      flOldProtect = 0;
      if ( VirtualProtect(v16, v15, 0x40u, &flOldProtect) )
      {
        v7[2] = 1;
        *((_QWORD *)v7 + 2) = a1;
        *((_QWORD *)v7 + 4) = v6;
        *((_QWORD *)v7 + 3) = v16;
        v7[10] = flOldProtect;
        *(_QWORD *)v7 = Block;
        Block = v7;
        return 0;
      }
      LastError = GetLastError();
    }
    else
    {
      LastError = 9;
      if ( dword_1800174A0 )
      {
LABEL_47:
        j_j_free(v7);
        qword_180017608 = (__int64)a1;
        return LastError;
      }
    }
    dword_1800174AC = LastError;
    goto LABEL_47;
  }
  return result;
}
// 1800174A0: using guessed type int dword_1800174A0;
// 1800174AC: using guessed type int dword_1800174AC;
// 180017578: using guessed type int dword_180017578;
// 180017608: using guessed type __int64 qword_180017608;

//----- (000000018000A030) ----------------------------------------------------
char *__fastcall sub_18000A030(__int64 a1, int *a2, char *a3, _BYTE *a4)
{
  int v4; // r14d
  __int64 v7; // rcx
  unsigned int v8; // eax
  bool v11; // zf
  unsigned int v12; // edx
  char v13; // dl
  unsigned int v14; // ebp
  int v15; // ebx
  __int64 v16; // r8
  char v17; // r9
  char v18; // r8
  __int64 v19; // r12
  char *v20; // rdx
  __int64 v21; // rcx
  char *v22; // rax
  int v23; // ebx
  int v24; // ebx
  int v25; // ebx

  v4 = *a2;
  v7 = ((unsigned int)*a2 >> 8) & 0xF;
  v8 = (unsigned int)*a2 >> 4;
  if ( (*a2 & 0x20000) != 0 )
  {
    v11 = *(_DWORD *)(a1 + 4) == 0;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 8) )
    {
      v12 = (*a2 & 0xF) + (((unsigned int)*a2 >> 17) & 4);
      goto LABEL_9;
    }
    v11 = *(_DWORD *)a1 == 0;
  }
  v13 = *a2;
  if ( !v11 )
    v13 = v8;
  v12 = v13 & 0xF;
LABEL_9:
  v14 = (unsigned __int16)v4 >> 12;
  v15 = v12 - v14;
  if ( !(_DWORD)v7 )
    goto LABEL_20;
  v16 = (unsigned __int8)a4[v7];
  v17 = byte_18001A090[v16];
  v12 += v17 & 0xF;
  if ( (v17 & 0x10) != 0 )
  {
    if ( (a4[(unsigned int)(v7 + 1)] & 7) == 5 )
    {
      v18 = v16 & 0xC0;
      switch ( v18 )
      {
        case 0:
          goto LABEL_16;
        case 0x40:
          v15 = ++v12 - v14;
          goto LABEL_20;
        case 0x80:
LABEL_16:
          v12 += 4;
          break;
      }
    }
    v15 = v12 - v14;
  }
  else if ( (v17 & 0x20) != 0 )
  {
    v14 = v7 + 1;
    v15 = 4;
  }
LABEL_20:
  v19 = v12;
  memcpy(a3, a4, v12);
  if ( !v14 )
    goto LABEL_43;
  v20 = &a3[v14];
  switch ( v15 )
  {
    case 1:
      v21 = *v20;
      v22 = &a4[v21 - (_QWORD)a3];
      goto LABEL_39;
    case 2:
      v21 = *(__int16 *)v20;
      v22 = &a4[v21 - (_QWORD)a3];
LABEL_36:
      *(_WORD *)v20 = (_WORD)v22;
      if ( (unsigned __int64)(v22 + 0x8000) > 0xFFFF )
        **(_DWORD **)(a1 + 40) = 2;
      goto LABEL_41;
    case 4:
      v21 = *(int *)v20;
      v22 = &a4[v21 - (_QWORD)a3];
LABEL_33:
      *(_DWORD *)v20 = (_DWORD)v22;
      if ( (unsigned __int64)(v22 + 0x80000000LL) > 0xFFFFFFFF )
        **(_DWORD **)(a1 + 40) = 0;
      goto LABEL_41;
    case 8:
      v21 = *(_QWORD *)v20;
      v22 = &a4[*(_QWORD *)v20 - (_QWORD)a3];
      goto LABEL_31;
  }
  v21 = 0;
  v22 = (char *)(a4 - a3);
  v23 = v15 - 1;
  if ( !v23 )
  {
LABEL_39:
    *v20 = (char)v22;
    if ( (unsigned __int64)(v22 + 128) > 0xFF )
      **(_DWORD **)(a1 + 40) = 3;
    goto LABEL_41;
  }
  v24 = v23 - 1;
  if ( !v24 )
    goto LABEL_36;
  v25 = v24 - 2;
  if ( !v25 )
    goto LABEL_33;
  if ( v25 == 4 )
LABEL_31:
    *(_QWORD *)v20 = v22;
LABEL_41:
  **(_QWORD **)(a1 + 32) = &a4[v19 + v21];
  if ( (*a2 & 0xF000) == 0 )
    **(_QWORD **)(a1 + 32) = 0;
LABEL_43:
  if ( (v4 & 0x40000) != 0 )
    **(_DWORD **)(a1 + 40) = -**(_DWORD **)(a1 + 40);
  if ( (v4 & 0x10000) != 0 )
    **(_QWORD **)(a1 + 32) = -1;
  return &a4[v19];
}
// 18001A090: using guessed type _BYTE byte_18001A090[256];

//----- (000000018000A240) ----------------------------------------------------
__int64 __fastcall sub_18000A240(__int64 a1, __int64 a2, _BYTE *a3, _BYTE *a4)
{
  char *v4; // rdx

  *a3 = *a4;
  v4 = (char *)&unk_18001A190 + 16 * (unsigned __int8)a4[1];
  return (*((__int64 (__fastcall **)(__int64, char *, _BYTE *))v4 + 1))(a1, v4, a3 + 1);
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000A280) ----------------------------------------------------
__int64 __fastcall sub_18000A280(__int64 a1, __int64 a2, _BYTE *a3, _BYTE *a4)
{
  char *v4; // rdx

  *(_BYTE *)(a1 + 28) = *a4;
  *a3 = *a4;
  v4 = (char *)&unk_18001A190 + 16 * (unsigned __int8)a4[1];
  return (*((__int64 (__fastcall **)(__int64, char *, _BYTE *))v4 + 1))(a1, v4, a3 + 1);
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000A2C0) ----------------------------------------------------
__int64 __fastcall sub_18000A2C0(__int64 a1, __int64 a2, _BYTE *a3, _BYTE *a4)
{
  char *v4; // rdx

  if ( (*a4 & 8) != 0 )
    *(_DWORD *)(a1 + 8) = 1;
  *a3 = *a4;
  v4 = (char *)&unk_18001A190 + 16 * (unsigned __int8)a4[1];
  return (*((__int64 (__fastcall **)(__int64, char *, _BYTE *))v4 + 1))(a1, v4, a3 + 1);
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000A300) ----------------------------------------------------
_BYTE *__fastcall sub_18000A300(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4)
{
  __int64 v4; // r10
  int v6; // ecx

  v4 = (char)a4[1];
  **(_QWORD **)(a1 + 32) = &a4[v4 + 2];
  v6 = v4 - a3 + (_DWORD)a4;
  if ( *a4 == 0xEB )
  {
    *(_BYTE *)a3 = -23;
    *(_DWORD *)(a3 + 1) = v6 - 3;
    **(_DWORD **)(a1 + 40) = 3;
    return a4 + 2;
  }
  else
  {
    *(_BYTE *)a3 = 15;
    *(_BYTE *)(a3 + 1) = *a4 & 0xF | 0x80;
    *(_DWORD *)(a3 + 2) = v6 - 4;
    **(_DWORD **)(a1 + 40) = 4;
    return a4 + 2;
  }
}

//----- (000000018000A370) ----------------------------------------------------
__int64 __fastcall sub_18000A370(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return a4 + 1;
}

//----- (000000018000A380) ----------------------------------------------------
__int64 __fastcall sub_18000A380(__int64 a1, __int64 a2, _BYTE *a3, _BYTE *a4)
{
  char *v4; // rdx

  *a3 = *a4;
  v4 = (char *)&unk_18001B190 + 16 * (unsigned __int8)a4[1];
  return (*((__int64 (__fastcall **)(__int64, char *, _BYTE *))v4 + 1))(a1, v4, a3 + 1);
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000A3C0) ----------------------------------------------------
__int64 __fastcall sub_18000A3C0(_DWORD *a1)
{
  __int64 (__fastcall **v1)(_DWORD *, void *); // rax

  if ( a1[5] || (v1 = (__int64 (__fastcall **)(_DWORD *, void *))&unk_18001A080, *a1) )
    v1 = (__int64 (__fastcall **)(_DWORD *, void *))&unk_18001C190;
  return v1[1](a1, v1);
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000A3F0) ----------------------------------------------------
__int64 __fastcall sub_18000A3F0(_DWORD *a1, __int64 a2, _BYTE *a3, _BYTE *a4)
{
  char *v4; // rdx

  *a1 = 1;
  *a3 = *a4;
  v4 = (char *)&unk_18001A190 + 16 * (unsigned __int8)a4[1];
  return (*((__int64 (__fastcall **)(_DWORD *, char *, _BYTE *))v4 + 1))(a1, v4, a3 + 1);
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000A430) ----------------------------------------------------
__int64 __fastcall sub_18000A430(__int64 a1, __int64 a2, _BYTE *a3, _BYTE *a4)
{
  char *v4; // rdx

  *(_DWORD *)(a1 + 4) = 1;
  *a3 = *a4;
  v4 = (char *)&unk_18001A190 + 16 * (unsigned __int8)a4[1];
  return (*((__int64 (__fastcall **)(__int64, char *, _BYTE *))v4 + 1))(a1, v4, a3 + 1);
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000A470) ----------------------------------------------------
__int64 __fastcall sub_18000A470(__int64 a1, __int64 a2, _BYTE *a3, _BYTE *a4)
{
  char *v4; // rdx

  *(_DWORD *)(a1 + 20) = 1;
  *a3 = *a4;
  v4 = (char *)&unk_18001A190 + 16 * (unsigned __int8)a4[1];
  return (*((__int64 (__fastcall **)(__int64, char *, _BYTE *))v4 + 1))(a1, v4, a3 + 1);
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000A4B0) ----------------------------------------------------
__int64 __fastcall sub_18000A4B0(__int64 a1, __int64 a2, _BYTE *a3, _BYTE *a4)
{
  char *v4; // rdx

  *(_DWORD *)(a1 + 24) = 1;
  *a3 = *a4;
  v4 = (char *)&unk_18001A190 + 16 * (unsigned __int8)a4[1];
  return (*((__int64 (__fastcall **)(__int64, char *, _BYTE *))v4 + 1))(a1, v4, a3 + 1);
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000A4F0) ----------------------------------------------------
char *__fastcall sub_18000A4F0(__int64 a1, __int64 a2, char *a3, _BYTE *a4)
{
  int *v4; // rdx

  v4 = (int *)&unk_18001A050;
  if ( (a4[1] & 0x38) != 0 )
    v4 = (int *)&unk_18001C1A0;
  return sub_18000A030(a1, v4, a3, a4);
}

//----- (000000018000A510) ----------------------------------------------------
char *__fastcall sub_18000A510(__int64 a1, __int64 a2, char *a3, _BYTE *a4)
{
  int *v4; // rdx

  v4 = (int *)&unk_18001A060;
  if ( (a4[1] & 0x38) != 0 )
    v4 = (int *)&unk_18001C1D0;
  return sub_18000A030(a1, v4, a3, a4);
}

//----- (000000018000A530) ----------------------------------------------------
char *__fastcall sub_18000A530(__int64 a1, __int64 a2, char *a3, __int64 a4)
{
  char *result; // rax
  char v7; // r8

  result = sub_18000A030(a1, (int *)&unk_18001A030, a3, (_BYTE *)a4);
  v7 = *(_BYTE *)(a4 + 1);
  if ( ((v7 - 21) & 0xEF) != 0 )
  {
    if ( (((v7 & 0x30) - 16) & 0xEF) != 0 )
      return result;
  }
  else if ( (unsigned __int8)(*(_BYTE *)(a1 + 28) - 100) > 1u )
  {
    **(_QWORD **)(a1 + 32) = *(_QWORD *)(*(int *)(a4 + 2) + a4 + 6);
    return result;
  }
  **(_QWORD **)(a1 + 32) = -1;
  return result;
}

//----- (000000018000A5B0) ----------------------------------------------------
char *__fastcall sub_18000A5B0(_DWORD *a1, unsigned __int8 a2, char *a3, _BYTE *a4, char a5, unsigned __int8 a6)
{
  switch ( a5 & 3 )
  {
    case 1:
      *a1 = 1;
      break;
    case 2:
      a1[6] = 1;
      break;
    case 3:
      a1[5] = 1;
      break;
  }
  if ( (a6 | a2) == 1 )
    return (char *)(*((__int64 (__fastcall **)(_DWORD *))&unk_18001B190 + 2 * (unsigned __int8)*a4 + 1))(a1);
  if ( (a6 | a2) != 2 )
  {
    if ( (a6 | a2) == 3 )
      return sub_18000A030((__int64)a1, (int *)&unk_18001A040, a3, a4);
    if ( (a6 | (unsigned int)a2) - 5 >= 2 )
      return a4 + 1;
  }
  return sub_18000A030((__int64)a1, (int *)&unk_18001A070, a3, a4);
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000A660) ----------------------------------------------------
char *__fastcall sub_18000A660(_DWORD *a1, __int64 a2, _BYTE *a3, _BYTE *a4)
{
  char v4; // dl

  *a3 = *a4;
  a3[1] = a4[1];
  a3[2] = a4[2];
  a1[2] |= (unsigned __int8)a4[2] >> 7;
  v4 = a4[1];
  a1[3] = 1;
  return sub_18000A5B0(a1, v4 & 0x1F, a3 + 3, a4 + 3, a4[2] & 3, 0);
}

//----- (000000018000A6C0) ----------------------------------------------------
char *__fastcall sub_18000A6C0(_DWORD *a1, __int64 a2, _BYTE *a3, _BYTE *a4)
{
  *a3 = *a4;
  a3[1] = a4[1];
  a1[3] = 1;
  return sub_18000A5B0(a1, 1u, a3 + 2, a4 + 2, a4[1] & 3, 0);
}

//----- (000000018000A700) ----------------------------------------------------
char *__fastcall sub_18000A700(_DWORD *a1, __int64 a2, __int64 a3, int *a4)
{
  char v4; // dl
  char *result; // rax
  unsigned int v6; // r10d
  int v7; // eax
  _BYTE *v8; // r9
  int v9; // edx
  int v10; // edx
  int v11; // edx

  v4 = *((_BYTE *)a4 + 1);
  result = (char *)a4 + 1;
  if ( (v4 & 8) == 0 )
  {
    v6 = *((unsigned __int8 *)a4 + 2);
    if ( (v6 & 4) != 0 )
    {
      v7 = *a4;
      v8 = a4 + 1;
      *(_DWORD *)a3 = v7;
      a1[2] |= v6 >> 7;
      a1[4] = 1;
      switch ( v6 & 3 )
      {
        case 1u:
          *a1 = 1;
          break;
        case 2u:
          a1[6] = 1;
          break;
        case 3u:
          a1[5] = 1;
          break;
      }
      v9 = (v4 & 7) - 1;
      if ( v9 )
      {
        v10 = v9 - 1;
        if ( v10 )
        {
          v11 = v10 - 1;
          if ( !v11 )
            return sub_18000A030((__int64)a1, (int *)&unk_18001A040, (char *)(a3 + 4), v8);
          if ( (unsigned int)(v11 - 2) >= 2 )
            return v8 + 1;
        }
        return sub_18000A030((__int64)a1, (int *)&unk_18001A070, (char *)(a3 + 4), v8);
      }
      else
      {
        return (char *)(*((__int64 (__fastcall **)(_DWORD *, char *, __int64))&unk_18001B190
                        + 2 * (unsigned __int8)*v8
                        + 1))(
                         a1,
                         (char *)&unk_18001B190 + 16 * (unsigned __int8)*v8,
                         a3 + 4);
      }
    }
  }
  return result;
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000A7F0) ----------------------------------------------------
char *__fastcall sub_18000A7F0(__int64 a1, __int64 a2, char *a3, _BYTE *a4)
{
  switch ( a4[1] & 0x1F )
  {
    case 8:
      return sub_18000A030(a1, (int *)&unk_18001A020, a3, a4);
    case 9:
      return sub_18000A030(a1, (int *)&unk_18001C1C0, a3, a4);
    case 10:
      return sub_18000A030(a1, (int *)&unk_18001A010, a3, a4);
  }
  return sub_18000A030(a1, (int *)&unk_18001C1B0, a3, a4);
}

//----- (000000018000A840) ----------------------------------------------------
int __fastcall sub_18000A840(double a1)
{
  HANDLE CurrentThread; // rax
  const void ***v2; // rbx
  const void ***v3; // rdi

  if ( Mtx_lock((_Mtx_t)&unk_180019020) )
  {
    std::_Throw_Cpp_error(5);
    __debugbreak();
  }
  if ( dword_18001906C == 0x7FFFFFFF )
  {
    dword_18001906C = 2147483646;
    std::_Throw_Cpp_error(6);
    __debugbreak();
  }
  if ( Src != *(&Src + 1) )
  {
    sub_180009150();
    CurrentThread = GetCurrentThread();
    sub_1800097F0(CurrentThread);
    v3 = (const void ***)*(&Src + 1);
    v2 = (const void ***)Src;
    if ( Src != *(&Src + 1) )
    {
      do
      {
        sub_180009DB0(*v2, v2[1]);
        v2 += 2;
      }
      while ( v2 != v3 );
    }
    sub_180009230(a1);
    if ( Src != *(&Src + 1) )
      *(&Src + 1) = Src;
  }
  return Mtx_unlock((_Mtx_t)&unk_180019020);
}
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);
// 18001906C: using guessed type int dword_18001906C;

//----- (000000018000A910) ----------------------------------------------------
char *__fastcall sub_18000A910(__int64 a1, _BYTE *a2, __int64 a3)
{
  _BYTE *v3; // rbp
  signed __int64 v6; // rsi
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rsi
  unsigned __int64 v10; // rdi
  size_t v11; // rdi
  _QWORD *v12; // rbx
  void *v13; // rax
  void *v16; // rcx
  const void *v17; // rdx
  char *v18; // r8
  _BYTE *v19; // rcx

  v3 = Src;
  _R15 = a3;
  v6 = ((_BYTE *)*(&Src + 1) - (_BYTE *)Src) >> 4;
  if ( v6 == 0xFFFFFFFFFFFFFFFLL )
    sub_18000AAD0();
  v7 = (qword_180017548 - (__int64)Src) >> 4;
  v8 = v7 >> 1;
  if ( v7 > 0xFFFFFFFFFFFFFFFLL - (v7 >> 1) )
    goto LABEL_24;
  v9 = v6 + 1;
  v10 = v9;
  if ( v8 + v7 >= v9 )
    v10 = v8 + v7;
  if ( v10 > 0xFFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  v11 = 16 * v10;
  if ( !v11 )
  {
    v12 = 0;
    goto LABEL_13;
  }
  if ( v11 < 0x1000 )
  {
    v12 = sub_18000E800(v11);
    goto LABEL_13;
  }
  if ( v11 + 39 < v11 )
LABEL_24:
    Concurrency::cancel_current_task();
  v13 = sub_18000E800(v11 + 39);
  if ( !v13 )
    goto LABEL_19;
  v12 = (_QWORD *)(((unsigned __int64)v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v12 - 1) = v13;
LABEL_13:
  __asm { vmovups xmm0, xmmword ptr [r15] }
  _RBP = (char *)v12 + ((a2 - v3) & 0xFFFFFFFFFFFFFFF0uLL);
  v16 = v12;
  __asm { vmovups xmmword ptr [rbp+0], xmm0 }
  v17 = Src;
  if ( a2 == *(&Src + 1) )
  {
    v18 = (char *)((_BYTE *)*(&Src + 1) - (_BYTE *)Src);
  }
  else
  {
    memmove(v12, Src, a2 - (_BYTE *)Src);
    v16 = _RBP + 16;
    v18 = (char *)((_BYTE *)*(&Src + 1) - a2);
    v17 = a2;
  }
  memmove(v16, v17, (size_t)v18);
  if ( Src )
  {
    if ( ((qword_180017548 - (_QWORD)Src) & 0xFFFFFFFFFFFFFFF0uLL) < 0x1000 )
    {
      v19 = Src;
    }
    else
    {
      v19 = (_BYTE *)*((_QWORD *)Src - 1);
      if ( (unsigned __int64)((_BYTE *)Src - v19 - 8) > 0x1F )
LABEL_19:
        __fastfail(5u);
    }
    j_j_free(v19);
  }
  Src = v12;
  *(&Src + 1) = &v12[2 * v9];
  qword_180017548 = (__int64)&v12[v11 / 8];
  return _RBP;
}
// 180017548: using guessed type __int64 qword_180017548;

//----- (000000018000AAD0) ----------------------------------------------------
void __noreturn sub_18000AAD0()
{
  std::_Xlength_error("vector too long");
}
// 180011140: using guessed type void __noreturn std::_Xlength_error(const char *);

//----- (000000018000AAF0) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
__int64 __fastcall sub_18000AAF0(unsigned __int64 a1, unsigned int a2, _DWORD *a3)
{
  double v3; // xmm0_8
  bool v6; // bl
  unsigned __int64 v8; // [rsp+28h] [rbp-30h] BYREF

  v8 = a1;
  if ( a2 == -2147195266 && a3 )
  {
    if ( Mtx_lock((_Mtx_t)&unk_1800171A0) )
    {
      std::_Throw_Cpp_error(5);
      __debugbreak();
    }
    if ( dword_1800171EC == 0x7FFFFFFF )
    {
      dword_1800171EC = 2147483646;
      std::_Throw_Cpp_error(6);
    }
    v6 = *a3 != 0;
    sub_18000CCD0(v3, &v8)[17] = v6;
    Mtx_unlock((_Mtx_t)&unk_1800171A0);
    a1 = v8;
  }
  return qword_180017638(a1, a2, a3);
}
// 18000AB74: variable 'v3' is possibly undefined
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800171EC: using guessed type int dword_1800171EC;
// 180017638: using guessed type __int64 (__fastcall *qword_180017638)(_QWORD, _QWORD, _QWORD);

//----- (000000018000ABC0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_18000ABC0(__int64 a1, __int64 a2)
{
  u_long v5; // eax
  unsigned __int64 v6; // rbx
  bool v10; // r15
  __int64 v11; // rdx
  char *v16; // rbx
  __m256 *v17; // rdx
  int v18; // esi
  char *v19; // rcx
  void (__fastcall *v20)(__int64, __m256 *, __int64, _QWORD); // rax
  __int64 v21; // r8
  __m256 *v22; // rdx
  void *v23; // rcx
  __m256 v25; // [rsp+40h] [rbp-C0h] BYREF
  char v26[4]; // [rsp+60h] [rbp-A0h] BYREF
  _BYTE v27[4]; // [rsp+64h] [rbp-9Ch] BYREF
  __int16 v28; // [rsp+68h] [rbp-98h] BYREF
  char v29; // [rsp+6Ah] [rbp-96h]
  void *v30; // [rsp+70h] [rbp-90h] BYREF
  __m256 v31; // [rsp+78h] [rbp-88h] BYREF
  _BYTE v32[3]; // [rsp+98h] [rbp-68h] BYREF
  char v33; // [rsp+9Bh] [rbp-65h]
  __int16 v34; // [rsp+B0h] [rbp-50h] BYREF
  char v35; // [rsp+B2h] [rbp-4Eh]
  char v36; // [rsp+B3h] [rbp-4Dh]
  int v37; // [rsp+B4h] [rbp-4Ch] BYREF
  __int16 v38; // [rsp+B8h] [rbp-48h]
  char v39; // [rsp+2B0h] [rbp+1B0h] BYREF

  v5 = ntohl(*(_DWORD *)(a2 + 4));
  v6 = v5;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups xmmword ptr [rsp+500h+var_4C0], xmm0
  }
  _RSI = 0;
  *(_QWORD *)&v25.m256_f32[4] = 0;
  _RDI = 15;
  *(_QWORD *)&v25.m256_f32[6] = 15;
  LOBYTE(v25.m256_f32[0]) = 0;
  v10 = 0;
  if ( (v5 & 0xF0000000) != 0xF0000000 )
    goto LABEL_17;
  v30 = &unk_180017140;
  if ( Mtx_lock((_Mtx_t)&unk_180017140) )
  {
    std::_Throw_Cpp_error(5);
    __debugbreak();
  }
  if ( dword_18001718C == 0x7FFFFFFF )
  {
    dword_18001718C = 2147483646;
    std::_Throw_Cpp_error(6);
  }
  v11 = *(_QWORD *)(qword_180017598
                  + 16
                  * (qword_1800175B0
                   & (0x100000001B3LL
                    * ((v6 >> 24)
                     ^ (0x100000001B3LL
                      * (BYTE2(v6)
                       ^ (0x100000001B3LL
                        * (BYTE1(v6) ^ (0x100000001B3LL * ((unsigned __int8)v6 ^ 0xCBF29CE484222325uLL)))))))))
                  + 8);
  if ( v11 != qword_180017588 )
  {
    if ( (_DWORD)v6 == *(_DWORD *)(v11 + 16) )
      goto LABEL_12;
    while ( v11 != *(_QWORD *)(qword_180017598
                             + 16
                             * (qword_1800175B0
                              & (0x100000001B3LL
                               * ((v6 >> 24)
                                ^ (0x100000001B3LL
                                 * (BYTE2(v6)
                                  ^ (0x100000001B3LL
                                   * (BYTE1(v6) ^ (0x100000001B3LL * ((unsigned __int8)v6 ^ 0xCBF29CE484222325uLL)))))))))) )
    {
      v11 = *(_QWORD *)(v11 + 8);
      if ( (_DWORD)v6 == *(_DWORD *)(v11 + 16) )
        goto LABEL_12;
    }
  }
  v11 = 0;
LABEL_12:
  if ( !v11 || v11 == qword_180017588 )
  {
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovups xmmword ptr [rsp+500h+var_488], xmm0
    }
    *(_OWORD *)&v31.m256_f32[4] = 0u;
    sub_180002B40(&v31, &unk_180013E88, 0);
  }
  else
  {
    sub_180002860(&v31, (unsigned __int64 *)(v11 + 24));
  }
  Mtx_unlock((_Mtx_t)&unk_180017140);
  __asm
  {
    vmovups ymm1, [rsp+500h+var_488]
    vmovups [rsp+500h+var_4C0], ymm1
  }
  __asm
  {
    vextractf128 xmm0, ymm1, 1
    vmovq   rsi, xmm0
  }
  v10 = _RSI != 0;
  __asm
  {
    vextractf128 xmm0, ymm1, 1
    vpextrq rdi, xmm0, 1
  }
LABEL_17:
  v28 = 261;
  v29 = 0;
  *(_QWORD *)&v31.m256_f32[2] = &v28;
  LODWORD(v31.m256_f32[0]) = 3;
  LODWORD(v30) = 0;
  __asm { vzeroupper }
  if ( !(unsigned int)((__int64 (__fastcall *)(__int64, __m256 *, __int64, void **, _DWORD, _QWORD, _QWORD))qword_180017670)(
                        a1,
                        &v31,
                        1,
                        &v30,
                        0,
                        0,
                        0)
    && (_DWORD)v30 == 3
    && qword_180017668
    && (unsigned int)qword_180017668(a1, v27, 2, 0) == 2
    && v27[0] == 5
    && !v27[1] )
  {
    v34 = 261;
    v35 = 0;
    v16 = *(char **)v25.m256_f32;
    if ( v10 )
    {
      v36 = 3;
      if ( _RSI > 0xFF )
        _RSI = 255;
      LOBYTE(v37) = _RSI;
      v17 = &v25;
      if ( _RDI > 0xF )
        v17 = *(__m256 **)v25.m256_f32;
      memcpy((char *)&v37 + 1, v17, _RSI);
      *(_WORD *)((char *)&v37 + _RSI + 1) = *(_WORD *)(a2 + 2);
      v18 = _RSI + 7;
    }
    else
    {
      v36 = 1;
      v37 = *(_DWORD *)(a2 + 4);
      v38 = *(_WORD *)(a2 + 2);
      v18 = 10;
    }
    *(_QWORD *)&v31.m256_f32[2] = &v34;
    LODWORD(v31.m256_f32[0]) = v18;
    LODWORD(v30) = 0;
    if ( (unsigned int)((__int64 (__fastcall *)(__int64, __m256 *, __int64, void **, _DWORD, _QWORD, _QWORD))qword_180017670)(
                         a1,
                         &v31,
                         1,
                         &v30,
                         0,
                         0,
                         0)
      || (_DWORD)v30 != v18
      || !qword_180017668
      || (unsigned int)qword_180017668(a1, v32, 4, 0) != 4
      || v32[1] )
    {
      if ( _RDI > 0xF )
      {
        if ( _RDI + 1 >= 0x1000 )
        {
          v19 = (char *)*((_QWORD *)v16 - 1);
          if ( (unsigned __int64)(v16 - v19 - 8) <= 0x1F )
            goto LABEL_62;
LABEL_60:
          __fastfail(5u);
        }
        v19 = v16;
LABEL_62:
        j_j_free(v19);
        return 0;
      }
      return 0;
    }
    switch ( v33 )
    {
      case 1:
        v20 = (void (__fastcall *)(__int64, __m256 *, __int64, _QWORD))qword_180017668;
        if ( !qword_180017668 )
          break;
        v21 = 6;
        v22 = (__m256 *)&v30;
        goto LABEL_50;
      case 3:
        if ( qword_180017668 )
        {
          qword_180017668(a1, v26, 1, 0);
          v20 = (void (__fastcall *)(__int64, __m256 *, __int64, _QWORD))qword_180017668;
          if ( qword_180017668 )
          {
            v21 = (unsigned int)(unsigned __int8)v26[0] + 2;
            v22 = (__m256 *)&v39;
LABEL_50:
            v20(a1, v22, v21, 0);
          }
        }
        break;
      case 4:
        v20 = (void (__fastcall *)(__int64, __m256 *, __int64, _QWORD))qword_180017668;
        if ( qword_180017668 )
        {
          v21 = 18;
          v22 = &v31;
          goto LABEL_50;
        }
        break;
    }
    if ( _RDI > 0xF )
    {
      if ( _RDI + 1 >= 0x1000 )
      {
        v23 = (void *)*((_QWORD *)v16 - 1);
        if ( (unsigned __int64)(v16 - (_BYTE *)v23 - 8) <= 0x1F )
        {
          j_j_free(v23);
          return 1;
        }
        goto LABEL_60;
      }
      j_j_free(v16);
    }
    return 1;
  }
  if ( _RDI > 0xF )
  {
    if ( _RDI + 1 < 0x1000 )
    {
      v19 = *(char **)v25.m256_f32;
    }
    else
    {
      v19 = *(char **)(*(_QWORD *)v25.m256_f32 - 8LL);
      if ( (unsigned __int64)(*(_QWORD *)v25.m256_f32 - (_QWORD)v19 - 8LL) > 0x1F )
        goto LABEL_60;
    }
    goto LABEL_62;
  }
  return 0;
}
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 18001718C: using guessed type int dword_18001718C;
// 180017588: using guessed type __int64 qword_180017588;
// 180017598: using guessed type __int64 qword_180017598;
// 1800175B0: using guessed type __int64 qword_1800175B0;
// 180017668: using guessed type __int64 (__fastcall *qword_180017668)(_QWORD, _QWORD, _QWORD, _QWORD);
// 180017670: using guessed type __int64 qword_180017670;

//----- (000000018000B090) ----------------------------------------------------
char __fastcall sub_18000B090(SOCKET fd, __int64 a2)
{
  int v4; // eax
  int v5; // ecx
  char v6; // si
  int v8; // [rsp+30h] [rbp-448h] BYREF
  struct timeval timeout; // [rsp+38h] [rbp-440h] BYREF
  fd_set exceptfds; // [rsp+40h] [rbp-438h] BYREF
  fd_set writefds; // [rsp+250h] [rbp-228h] BYREF

  writefds.fd_array[0] = fd;
  exceptfds.fd_array[0] = fd;
  writefds.fd_count = 1;
  exceptfds.fd_count = 1;
  timeout = (struct timeval)5LL;
  v4 = select(0, 0, &writefds, &exceptfds, &timeout);
  if ( v4 == -1 )
  {
    v5 = 10057;
  }
  else if ( v4 )
  {
    if ( _WSAFDIsSet(fd, &exceptfds) )
    {
      v5 = 10061;
    }
    else
    {
      v8 = 0;
      if ( *(_BYTE *)(a2 + 17) && qword_180017638 )
        qword_180017638(fd, 2147772030LL, &v8);
      v6 = sub_18000ABC0(fd, a2);
      if ( *(_BYTE *)(a2 + 17) )
      {
        v8 = 1;
        if ( qword_180017638 )
          qword_180017638(fd, 2147772030LL, &v8);
      }
      if ( v6 )
      {
        *(_BYTE *)(a2 + 16) = 0;
        return 1;
      }
      v5 = 10053;
    }
  }
  else
  {
    v5 = 10060;
  }
  WSASetLastError(v5);
  return 0;
}
// 180017638: invalid function type '?' has been ignored
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 180017638: using guessed type __int64 (__fastcall *qword_180017638)(_QWORD, _QWORD, _QWORD);

//----- (000000018000B1E0) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
__int64 __fastcall sub_18000B1E0(SOCKET fd, __int64 a2, unsigned int a3, __int64 a4, int a5, __int64 a6, __int64 a7)
{
  _QWORD *v11; // rax
  _BYTE *i; // rcx
  CHAR *v14; // rdi
  int namelen; // [rsp+48h] [rbp-120h] BYREF
  struct sockaddr name; // [rsp+50h] [rbp-118h] BYREF
  CHAR pStringBuf[80]; // [rsp+D0h] [rbp-98h] BYREF

  if ( Mtx_lock((_Mtx_t)&unk_1800171A0) )
  {
    std::_Throw_Cpp_error(5);
    __debugbreak();
  }
  if ( dword_1800171EC == 0x7FFFFFFF )
  {
    dword_1800171EC = 2147483646;
    std::_Throw_Cpp_error(6);
  }
  v11 = (_QWORD *)*((_QWORD *)qword_180017550 + 1);
  for ( i = qword_180017550; !*((_BYTE *)v11 + 25); v11 = (_QWORD *)*v11 )
  {
    if ( v11[4] >= fd )
      i = v11;
    else
      v11 += 2;
  }
  if ( i[25] || fd < *((_QWORD *)i + 4) )
    i = qword_180017550;
  if ( i == qword_180017550 || !i[56] || sub_18000B090(fd, (__int64)(i + 40)) )
  {
    Mtx_unlock((_Mtx_t)&unk_1800171A0);
    namelen = 128;
    if ( !getpeername(fd, &name, &namelen) )
    {
      v14 = &name.sa_data[2];
      if ( name.sa_family != 2 )
        v14 = &name.sa_data[6];
      ntohs(*(u_short *)name.sa_data);
      inet_ntop(name.sa_family, v14, pStringBuf, 0x41u);
    }
    return ((__int64 (__fastcall *)(SOCKET, __int64, _QWORD, __int64, int, __int64, __int64))qword_180017670)(
             fd,
             a2,
             a3,
             a4,
             a5,
             a6,
             a7);
  }
  else
  {
    Mtx_unlock((_Mtx_t)&unk_1800171A0);
    return 0xFFFFFFFFLL;
  }
}
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800171EC: using guessed type int dword_1800171EC;
// 180017670: using guessed type __int64 qword_180017670;

//----- (000000018000B390) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
__int64 __fastcall sub_18000B390(SOCKET fd, __int64 a2, unsigned int a3, unsigned int a4)
{
  _QWORD *v8; // rax
  _BYTE *i; // rcx

  if ( Mtx_lock((_Mtx_t)&unk_1800171A0) )
  {
    std::_Throw_Cpp_error(5);
    __debugbreak();
  }
  if ( dword_1800171EC == 0x7FFFFFFF )
  {
    dword_1800171EC = 2147483646;
    std::_Throw_Cpp_error(6);
  }
  v8 = (_QWORD *)*((_QWORD *)qword_180017550 + 1);
  for ( i = qword_180017550; !*((_BYTE *)v8 + 25); v8 = (_QWORD *)*v8 )
  {
    if ( v8[4] >= fd )
      i = v8;
    else
      v8 += 2;
  }
  if ( i[25] || fd < *((_QWORD *)i + 4) )
    i = qword_180017550;
  if ( i == qword_180017550 || !i[56] || sub_18000B090(fd, (__int64)(i + 40)) )
  {
    Mtx_unlock((_Mtx_t)&unk_1800171A0);
    return qword_180017668(fd, a2, a3, a4);
  }
  else
  {
    Mtx_unlock((_Mtx_t)&unk_1800171A0);
    return 0xFFFFFFFFLL;
  }
}
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800171EC: using guessed type int dword_1800171EC;
// 180017668: using guessed type __int64 (__fastcall *qword_180017668)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018000B490) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
__int64 __fastcall sub_18000B490(
        SOCKET fd,
        __int64 a2,
        unsigned int a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7)
{
  _QWORD *v11; // rax
  _BYTE *i; // rcx

  if ( Mtx_lock((_Mtx_t)&unk_1800171A0) )
  {
    std::_Throw_Cpp_error(5);
    __debugbreak();
  }
  if ( dword_1800171EC == 0x7FFFFFFF )
  {
    dword_1800171EC = 2147483646;
    std::_Throw_Cpp_error(6);
  }
  v11 = (_QWORD *)*((_QWORD *)qword_180017550 + 1);
  for ( i = qword_180017550; !*((_BYTE *)v11 + 25); v11 = (_QWORD *)*v11 )
  {
    if ( v11[4] >= fd )
      i = v11;
    else
      v11 += 2;
  }
  if ( i[25] || fd < *((_QWORD *)i + 4) )
    i = qword_180017550;
  if ( i == qword_180017550 || !i[56] || sub_18000B090(fd, (__int64)(i + 40)) )
  {
    Mtx_unlock((_Mtx_t)&unk_1800171A0);
    return ((__int64 (__fastcall *)(SOCKET, __int64, _QWORD, __int64, __int64, __int64, __int64))qword_180017630)(
             fd,
             a2,
             a3,
             a4,
             a5,
             a6,
             a7);
  }
  else
  {
    Mtx_unlock((_Mtx_t)&unk_1800171A0);
    return 0xFFFFFFFFLL;
  }
}
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800171EC: using guessed type int dword_1800171EC;
// 180017630: using guessed type __int64 qword_180017630;

//----- (000000018000B5C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=4
__int64 __fastcall sub_18000B5C0(wchar_t *String, __int64 a2, __int64 a3, _QWORD *a4)
{
  wchar_t v9; // ax
  size_t v11; // rax
  size_t v12; // rbx
  __int64 v14; // rsi
  unsigned __int64 v15; // rax
  size_t v16; // rax
  void *v17; // rax
  _QWORD *v18; // r14
  unsigned __int64 v22; // rax
  void **v31; // rdx
  __int64 v32; // r9
  unsigned __int64 i; // rcx
  __int64 v34; // rbx
  unsigned int v35; // ebx
  void **v36; // rcx
  void **v37; // rdx
  __int64 v38; // rax
  unsigned __int64 v41; // rdx
  unsigned __int64 v42; // r8
  char *v43; // r9
  __int64 v44; // r10
  char *v45; // rbx
  char *v46; // rsi
  __int16 v47; // r9
  void **v48; // rcx
  void **v49; // rcx
  void *v50; // rcx
  void *v51; // rcx
  void *v52; // rcx
  void *v53; // rcx
  int v54; // [rsp+38h] [rbp-81h] BYREF
  void *v55[2]; // [rsp+40h] [rbp-79h] BYREF
  size_t v56; // [rsp+50h] [rbp-69h]
  unsigned __int64 v57; // [rsp+58h] [rbp-61h]
  __int128 v58; // [rsp+60h] [rbp-59h] BYREF
  __int64 v59; // [rsp+70h] [rbp-49h]
  void *Block[2]; // [rsp+80h] [rbp-39h] BYREF
  unsigned __int64 v61; // [rsp+90h] [rbp-29h]
  unsigned __int64 v62; // [rsp+98h] [rbp-21h]

  _RDI = String;
  if ( !String )
  {
LABEL_96:
    if ( qword_180017660 )
      return ((__int64 (__fastcall *)(const wchar_t *))qword_180017660)(_RDI);
    else
      return 2147500037LL;
  }
  v9 = *String;
  if ( !*String )
    return ((__int64 (__fastcall *)(const wchar_t *))qword_180017660)(_RDI);
  while ( v9 == 46 || (unsigned __int16)(v9 - 48) <= 9u )
  {
    v9 = *++String;
    if ( !*String )
      return ((__int64 (__fastcall *)(const wchar_t *))qword_180017660)(_RDI);
  }
  v11 = wcslen(_RDI);
  v12 = v11;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups xmmword ptr [rbp+57h+var_D0], xmm0
  }
  v56 = 0;
  v57 = 0;
  v14 = 0x7FFFFFFFFFFFFFFFLL;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL )
    sub_180001680();
  if ( v11 <= 0xF )
  {
    v56 = v11;
    v57 = 15;
    memset(v55, 0, v11);
    *((_BYTE *)v55 + v12) = 0;
    goto LABEL_21;
  }
  v15 = v11 | 0xF;
  if ( v15 > 0x7FFFFFFFFFFFFFFFLL )
  {
    v16 = 0x8000000000000027uLL;
LABEL_12:
    v17 = sub_18000E800(v16);
    if ( !v17 )
      goto LABEL_94;
    v18 = (_QWORD *)(((unsigned __int64)v17 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v18 - 1) = v17;
    goto LABEL_20;
  }
  v14 = v15;
  if ( v15 < 0x16 )
    v14 = 22;
  if ( (unsigned __int64)(v14 + 1) >= 0x1000 )
  {
    v16 = v14 + 40;
    if ( v14 + 40 < (unsigned __int64)(v14 + 1) )
      Concurrency::cancel_current_task();
    goto LABEL_12;
  }
  v18 = sub_18000E800(v14 + 1);
LABEL_20:
  v55[0] = v18;
  v56 = v12;
  v57 = v14;
  memset(v18, 0, v12);
  *((_BYTE *)v18 + v12) = 0;
LABEL_21:
  _RDX = v55;
  if ( v57 > 0xF )
    _RDX = (void **)v55[0];
  if ( v12 )
  {
    _RCX = 0;
    if ( v12 < 4 || _RDX <= (void **)&_RDI[v12 - 1] && (char *)_RDX + v12 - 1 >= (char *)_RDI )
      goto LABEL_103;
    __asm { vmovdqu xmm2, cs:xmmword_180014110 }
    if ( v12 < 0x20 )
      goto LABEL_104;
    v22 = v12 & 0x1F;
    do
    {
      __asm
      {
        vmovdqu xmm0, xmmword ptr [rdi+rcx*2]
        vpshufb xmm1, xmm0, xmm2
        vmovq   qword ptr [rdx+rcx], xmm1
        vmovdqu xmm0, xmmword ptr [rdi+rcx*2+10h]
        vpshufb xmm1, xmm0, xmm2
        vmovq   qword ptr [rdx+rcx+8], xmm1
        vmovdqu xmm0, xmmword ptr [rdi+rcx*2+20h]
        vpshufb xmm1, xmm0, xmm2
        vmovq   qword ptr [rdx+rcx+10h], xmm1
        vmovdqu xmm0, xmmword ptr [rdi+rcx*2+30h]
        vpshufb xmm1, xmm0, xmm2
        vmovq   qword ptr [rdx+rcx+18h], xmm1
      }
      _RCX += 32LL;
    }
    while ( _RCX < v12 - v22 );
    if ( v22 >= 4 )
    {
LABEL_104:
      do
      {
        __asm
        {
          vmovq   xmm0, qword ptr [rdi+rcx*2]
          vpshufb xmm1, xmm0, xmm2
          vmovd   dword ptr [rdx+rcx], xmm1
        }
        _RCX += 4LL;
      }
      while ( _RCX < (v12 & 0xFFFFFFFFFFFFFFFCuLL) );
    }
    if ( _RCX < v12 )
    {
LABEL_103:
      do
      {
        *((_BYTE *)_RDX + _RCX) = _RDI[_RCX];
        ++_RCX;
      }
      while ( _RCX < v12 );
    }
  }
  if ( byte_1800174F0 )
  {
    if ( Mtx_lock((_Mtx_t)&unk_180017140) )
    {
      std::_Throw_Cpp_error(5);
      __debugbreak();
    }
    if ( dword_18001718C == 0x7FFFFFFF )
    {
      dword_18001718C = 2147483646;
      std::_Throw_Cpp_error(6);
    }
    v31 = v55;
    if ( v57 > 0xF )
      v31 = (void **)v55[0];
    v32 = 0xCBF29CE484222325uLL;
    for ( i = 0; i < v56; ++i )
      v32 = 0x100000001B3LL * (*((unsigned __int8 *)v31 + i) ^ (unsigned __int64)v32);
    v34 = sub_180008130(i, &v58, (size_t *)v55, v32)[1];
    if ( !v34 || v34 == qword_1800175C8 )
    {
      v54 = dword_180017190++;
      v36 = (void **)(*(_QWORD *)sub_180007E60(*(double *)&_XMM0, (__int64)&v58, (unsigned __int8 *)&v54) + 24LL);
      if ( v36 != v55 )
      {
        v37 = v55;
        if ( v57 > 0xF )
          v37 = (void **)v55[0];
        sub_180007850(v36, v37, v56);
      }
      v38 = sub_180007B80(*(double *)&_XMM0, (__int64)&v58, (size_t *)v55);
      *(_DWORD *)(*(_QWORD *)v38 + 48LL) = v54;
      v35 = v54;
    }
    else
    {
      v35 = *(_DWORD *)(v34 + 48);
    }
    Mtx_unlock((_Mtx_t)&unk_180017140);
    sub_18000CC70(
      (wchar_t *)Block,
      (wchar_t *)L"%d.%d.%d.%d",
      HIBYTE(v35),
      BYTE2(v35),
      BYTE1(v35),
      (unsigned __int8)v35,
      &unk_180017140);
    if ( !(unsigned int)((__int64 (__fastcall *)(void **, __int64, __int64, _QWORD *))qword_180017660)(
                          Block,
                          a2,
                          a3,
                          a4)
      && *a4 )
    {
      goto LABEL_77;
    }
    goto LABEL_90;
  }
  __asm { vpxor   xmm0, xmm0, xmm0 }
  __asm { vmovups [rbp+57h+var_B0], xmm0 }
  v59 = 0;
  sub_1800053A0((unsigned __int64 *)&v58, (const void **)v55, (unsigned __int64 *)&ymmword_1800174F8);
  if ( (_QWORD)v58 == *((_QWORD *)&v58 + 1) )
    goto LABEL_89;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovups xmmword ptr [rbp+57h+Block], xmm0
  }
  v41 = 0;
  v61 = 0;
  v42 = 7;
  v62 = 7;
  LOWORD(Block[0]) = 0;
  v43 = (char *)v58;
  if ( *(_QWORD *)(v58 + 24) <= 0xFu )
  {
    v45 = (char *)v58;
    v44 = v58;
  }
  else
  {
    v43 = *(char **)v58;
    v44 = *(_QWORD *)v58;
    v45 = *(char **)v58;
  }
  v46 = (char *)(v44 + *(_QWORD *)(v58 + 16));
  if ( v43 != v46 )
  {
    while ( 1 )
    {
      v47 = *v45;
      v48 = Block;
      if ( v41 >= v42 )
      {
        sub_18000CE20(Block, v41, v42, v47);
      }
      else
      {
        v61 = v41 + 1;
        if ( v42 > 7 )
          v48 = (void **)Block[0];
        *((_WORD *)v48 + v41) = v47;
        *((_WORD *)v48 + v41 + 1) = 0;
      }
      ++v45;
      v42 = v62;
      if ( v45 == v46 )
        break;
      v41 = v61;
    }
  }
  v49 = Block;
  if ( v42 > 7 )
    v49 = (void **)Block[0];
  if ( (unsigned int)((__int64 (__fastcall *)(void **, __int64, __int64, _QWORD *))qword_180017660)(v49, a2, a3, a4)
    || !*a4 )
  {
    if ( v62 > 7 )
    {
      if ( 2 * v62 + 2 < 0x1000 )
      {
        v52 = Block[0];
      }
      else
      {
        v52 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)((char *)Block[0] - (char *)v52 - 8) > 0x1F )
          goto LABEL_86;
      }
      j_j_free(v52);
    }
LABEL_89:
    sub_180002C40((__int64)&v58);
LABEL_90:
    if ( v57 > 0xF )
    {
      if ( v57 + 1 < 0x1000 )
      {
        j_j_free(v55[0]);
      }
      else
      {
        v53 = (void *)*((_QWORD *)v55[0] - 1);
        if ( (unsigned __int64)((char *)v55[0] - (char *)v53 - 8) > 0x1F )
          goto LABEL_94;
        j_j_free(v53);
      }
    }
    goto LABEL_96;
  }
  if ( v62 > 7 )
  {
    if ( 2 * v62 + 2 < 0x1000 )
    {
      v50 = Block[0];
LABEL_75:
      j_j_free(v50);
      goto LABEL_76;
    }
    v50 = (void *)*((_QWORD *)Block[0] - 1);
    if ( (unsigned __int64)((char *)Block[0] - (char *)v50 - 8) <= 0x1F )
      goto LABEL_75;
LABEL_86:
    __fastfail(5u);
  }
LABEL_76:
  v61 = 0;
  v62 = 7;
  LOWORD(Block[0]) = 0;
  sub_180002C40((__int64)&v58);
LABEL_77:
  if ( v57 > 0xF )
  {
    if ( v57 + 1 >= 0x1000 )
    {
      v51 = (void *)*((_QWORD *)v55[0] - 1);
      if ( (unsigned __int64)((char *)v55[0] - (char *)v51 - 8) <= 0x1F )
      {
        j_j_free(v51);
        return 0;
      }
LABEL_94:
      __fastfail(5u);
    }
    j_j_free(v55[0]);
  }
  return 0;
}
// 18000B6D0: conditional instruction was optimized away because rsi.8>=F
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 18001718C: using guessed type int dword_18001718C;
// 180017190: using guessed type int dword_180017190;
// 1800174F0: using guessed type char byte_1800174F0;
// 1800175C8: using guessed type __int64 qword_1800175C8;
// 180017660: using guessed type __int64 qword_180017660;

//----- (000000018000BC10) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
__int64 __fastcall sub_18000BC10(__int64 a1, __int64 a2, unsigned int a3)
{
  double v3; // xmm0_8
  u_long v6; // eax
  const CHAR *v8; // rdx
  char v9; // di
  __int64 v14; // [rsp+28h] [rbp-40h] BYREF
  _WORD v15[2]; // [rsp+30h] [rbp-38h] BYREF
  _BYTE pAddrBuf[12]; // [rsp+34h] [rbp-34h] BYREF

  _RBX = a2;
  v14 = a1;
  if ( *(_WORD *)a2 != 2 )
    return ((__int64 (__fastcall *)(__int64, __int64, _QWORD))qword_180017648)(a1, _RBX, a3);
  v6 = ntohl(*(_DWORD *)(a2 + 4));
  if ( (v6 & 0xFF000000) == 0x7F000000 && (v6 & 0xF0000000) != 0xF0000000 )
  {
    a1 = v14;
    return ((__int64 (__fastcall *)(__int64, __int64, _QWORD))qword_180017648)(a1, _RBX, a3);
  }
  v15[0] = 2;
  v8 = (const CHAR *)&ymmword_1800174B0;
  if ( (unsigned __int64)*(&ymmword_1800174B0 + 3) > 0xF )
    v8 = ymmword_1800174B0;
  inet_pton(2, v8, pAddrBuf);
  v15[1] = htons(word_1800174D0);
  if ( Mtx_lock((_Mtx_t)&unk_1800171A0) )
    goto LABEL_22;
  if ( dword_1800171EC == 0x7FFFFFFF )
  {
LABEL_19:
    dword_1800171EC = 2147483646;
    std::_Throw_Cpp_error(6);
    goto LABEL_20;
  }
  v9 = sub_18000CCD0(v3, (unsigned __int64 *)&v14)[17];
  Mtx_unlock((_Mtx_t)&unk_1800171A0);
  if ( (unsigned int)((__int64 (__fastcall *)(__int64, _WORD *, __int64))qword_180017648)(v14, v15, 16) == -1 )
  {
    if ( WSAGetLastError() != 10035 )
      return 0xFFFFFFFFLL;
    if ( !Mtx_lock((_Mtx_t)&unk_1800171A0) )
    {
      if ( dword_1800171EC != 0x7FFFFFFF )
      {
        sub_18000CCD0(v3, (unsigned __int64 *)&v14)[16] = 1;
        _RAX = sub_18000CCD0(v3, (unsigned __int64 *)&v14);
        __asm
        {
          vmovups xmm0, xmmword ptr [rbx]
          vmovups xmmword ptr [rax], xmm0
        }
        sub_18000CCD0(*(double *)&_XMM0, (unsigned __int64 *)&v14)[17] = 1;
        Mtx_unlock((_Mtx_t)&unk_1800171A0);
        return 0xFFFFFFFFLL;
      }
      goto LABEL_19;
    }
LABEL_22:
    std::_Throw_Cpp_error(5);
    JUMPOUT(0x18000BE3ALL);
  }
  if ( v9 )
  {
    if ( Mtx_lock((_Mtx_t)&unk_1800171A0) )
      goto LABEL_22;
    if ( dword_1800171EC != 0x7FFFFFFF )
    {
LABEL_20:
      sub_18000CCD0(v3, (unsigned __int64 *)&v14)[16] = 1;
      _RAX = sub_18000CCD0(v3, (unsigned __int64 *)&v14);
      __asm
      {
        vmovups xmm0, xmmword ptr [rbx]
        vmovups xmmword ptr [rax], xmm0
      }
      sub_18000CCD0(*(double *)&_XMM0, (unsigned __int64 *)&v14)[17] = 1;
      Mtx_unlock((_Mtx_t)&unk_1800171A0);
      return 0;
    }
    goto LABEL_19;
  }
  return (unsigned int)(sub_18000ABC0(v14, _RBX) != 0) - 1;
}
// 18000BE34: control flows out of bounds to 18000BE3A
// 18000BCFA: variable 'v3' is possibly undefined
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800171EC: using guessed type int dword_1800171EC;
// 1800174D0: using guessed type __int16 word_1800174D0;
// 180017648: using guessed type __int64 qword_180017648;

//----- (000000018000BE40) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
__int64 __fastcall sub_18000BE40(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7)
{
  double v7; // xmm0_8
  u_long v11; // eax
  const CHAR *v13; // rdx
  char v14; // di
  __int64 v19; // [rsp+48h] [rbp-60h] BYREF
  _WORD v20[2]; // [rsp+50h] [rbp-58h] BYREF
  _BYTE pAddrBuf[12]; // [rsp+54h] [rbp-54h] BYREF

  _RBX = a2;
  v19 = a1;
  if ( *(_WORD *)a2 != 2 )
    return ((__int64 (__fastcall *)(__int64, __int64, _QWORD, __int64, __int64, __int64, __int64))qword_180017650)(
             a1,
             _RBX,
             a3,
             a4,
             a5,
             a6,
             a7);
  v11 = ntohl(*(_DWORD *)(a2 + 4));
  if ( (v11 & 0xFF000000) == 0x7F000000 && (v11 & 0xF0000000) != 0xF0000000 )
  {
    a1 = v19;
    return ((__int64 (__fastcall *)(__int64, __int64, _QWORD, __int64, __int64, __int64, __int64))qword_180017650)(
             a1,
             _RBX,
             a3,
             a4,
             a5,
             a6,
             a7);
  }
  v20[0] = 2;
  v13 = (const CHAR *)&ymmword_1800174B0;
  if ( (unsigned __int64)*(&ymmword_1800174B0 + 3) > 0xF )
    v13 = ymmword_1800174B0;
  inet_pton(2, v13, pAddrBuf);
  v20[1] = htons(word_1800174D0);
  if ( Mtx_lock((_Mtx_t)&unk_1800171A0) )
    goto LABEL_22;
  if ( dword_1800171EC == 0x7FFFFFFF )
  {
LABEL_19:
    dword_1800171EC = 2147483646;
    std::_Throw_Cpp_error(6);
    goto LABEL_20;
  }
  v14 = sub_18000CCD0(v7, (unsigned __int64 *)&v19)[17];
  Mtx_unlock((_Mtx_t)&unk_1800171A0);
  if ( (unsigned int)((__int64 (__fastcall *)(__int64, _WORD *, __int64, _QWORD, _QWORD, _QWORD, _QWORD))qword_180017650)(
                       v19,
                       v20,
                       16,
                       0,
                       0,
                       0,
                       0) == -1 )
  {
    if ( WSAGetLastError() != 10035 )
      return 0xFFFFFFFFLL;
    if ( !Mtx_lock((_Mtx_t)&unk_1800171A0) )
    {
      if ( dword_1800171EC != 0x7FFFFFFF )
      {
        sub_18000CCD0(v7, (unsigned __int64 *)&v19)[16] = 1;
        _RAX = sub_18000CCD0(v7, (unsigned __int64 *)&v19);
        __asm
        {
          vmovups xmm0, xmmword ptr [rbx]
          vmovups xmmword ptr [rax], xmm0
        }
        sub_18000CCD0(*(double *)&_XMM0, (unsigned __int64 *)&v19)[17] = 1;
        Mtx_unlock((_Mtx_t)&unk_1800171A0);
        return 0xFFFFFFFFLL;
      }
      goto LABEL_19;
    }
LABEL_22:
    std::_Throw_Cpp_error(5);
    JUMPOUT(0x18000C0B5LL);
  }
  if ( v14 )
  {
    if ( Mtx_lock((_Mtx_t)&unk_1800171A0) )
      goto LABEL_22;
    if ( dword_1800171EC != 0x7FFFFFFF )
    {
LABEL_20:
      sub_18000CCD0(v7, (unsigned __int64 *)&v19)[16] = 1;
      _RAX = sub_18000CCD0(v7, (unsigned __int64 *)&v19);
      __asm
      {
        vmovups xmm0, xmmword ptr [rbx]
        vmovups xmmword ptr [rax], xmm0
      }
      sub_18000CCD0(*(double *)&_XMM0, (unsigned __int64 *)&v19)[17] = 1;
      Mtx_unlock((_Mtx_t)&unk_1800171A0);
      return 0;
    }
    goto LABEL_19;
  }
  return (unsigned int)(sub_18000ABC0(v19, _RBX) != 0) - 1;
}
// 18000C0AF: control flows out of bounds to 18000C0B5
// 18000BF61: variable 'v7' is possibly undefined
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800171EC: using guessed type int dword_1800171EC;
// 1800174D0: using guessed type __int16 word_1800174D0;
// 180017650: using guessed type __int64 qword_180017650;

//----- (000000018000C0C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
__int64 __fastcall sub_18000C0C0(
        unsigned __int64 a1,
        __int64 a2,
        unsigned int a3,
        __int64 a4,
        int a5,
        __int64 a6,
        __int64 a7)
{
  double v7; // xmm0_8
  u_long v11; // eax
  const CHAR *v15; // rdx
  unsigned __int64 v16; // [rsp+48h] [rbp-50h] BYREF
  _WORD v17[2]; // [rsp+50h] [rbp-48h] BYREF
  _BYTE pAddrBuf[12]; // [rsp+54h] [rbp-44h] BYREF

  _RBX = a2;
  v16 = a1;
  if ( *(_WORD *)a2 != 2 )
    return ((__int64 (__fastcall *)(unsigned __int64, __int64, _QWORD, __int64, int, __int64, __int64))qword_180017640)(
             a1,
             _RBX,
             a3,
             a4,
             a5,
             a6,
             a7);
  v11 = ntohl(*(_DWORD *)(a2 + 4));
  if ( (v11 & 0xFF000000) == 0x7F000000 && (v11 & 0xF0000000) != 0xF0000000 )
  {
    a1 = v16;
    return ((__int64 (__fastcall *)(unsigned __int64, __int64, _QWORD, __int64, int, __int64, __int64))qword_180017640)(
             a1,
             _RBX,
             a3,
             a4,
             a5,
             a6,
             a7);
  }
  if ( Mtx_lock((_Mtx_t)&unk_1800171A0) )
  {
    std::_Throw_Cpp_error(5);
    __debugbreak();
  }
  if ( dword_1800171EC == 0x7FFFFFFF )
  {
    dword_1800171EC = 2147483646;
    std::_Throw_Cpp_error(6);
  }
  _RAX = sub_18000CCD0(v7, &v16);
  __asm
  {
    vmovups xmm0, xmmword ptr [rbx]
    vmovups xmmword ptr [rax], xmm0
  }
  sub_18000CCD0(*(double *)&_XMM0, &v16)[16] = 1;
  sub_18000CCD0(*(double *)&_XMM0, &v16)[17] = 1;
  Mtx_unlock((_Mtx_t)&unk_1800171A0);
  v17[0] = 2;
  v15 = (const CHAR *)&ymmword_1800174B0;
  if ( (unsigned __int64)*(&ymmword_1800174B0 + 3) > 0xF )
    v15 = ymmword_1800174B0;
  inet_pton(2, v15, pAddrBuf);
  v17[1] = htons(word_1800174D0);
  return ((__int64 (__fastcall *)(unsigned __int64, _WORD *, __int64, __int64, int, __int64, __int64))qword_180017640)(
           v16,
           v17,
           16,
           a4,
           a5,
           a6,
           a7);
}
// 18000C1B9: variable 'v7' is possibly undefined
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800171EC: using guessed type int dword_1800171EC;
// 1800174D0: using guessed type __int16 word_1800174D0;
// 180017640: using guessed type __int64 qword_180017640;

//----- (000000018000C260) ----------------------------------------------------
__int64 __fastcall sub_18000C260(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 *a5, unsigned int a6)
{
  int v7; // ebp
  __int64 result; // rax

  v7 = a2;
  result = ((__int64 (__fastcall *)(__int64, __int64, _QWORD *, __int64, __int64 *))qword_180017658)(a1, a2, a3, a4, a5);
  if ( !(_DWORD)result && v7 == -939524090 && a6 >= 8 )
  {
    if ( *a3 == 0x4660DDF325A207B9LL && a3[1] == 0x3E06748CE576E98ELL )
    {
      qword_180017640 = *a5;
      *a5 = (__int64)sub_18000C0C0;
    }
    return 0;
  }
  return result;
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 180017640: using guessed type __int64 qword_180017640;
// 180017658: using guessed type __int64 qword_180017658;

//----- (000000018000C330) ----------------------------------------------------
__int64 __fastcall sub_18000C330(unsigned __int64 a1)
{
  _QWORD *v2; // rax
  _QWORD *v3; // rdx
  __int64 **v4; // rcx
  _QWORD *v5; // rdx
  __int64 i; // rcx
  __int64 *j; // rcx
  _QWORD *v8; // rax

  if ( Mtx_lock((_Mtx_t)&unk_1800171A0) )
  {
    std::_Throw_Cpp_error(5);
    __debugbreak();
  }
  if ( dword_1800171EC == 0x7FFFFFFF )
  {
    dword_1800171EC = 2147483646;
    std::_Throw_Cpp_error(6);
    __debugbreak();
  }
  v2 = qword_180017550;
  v3 = (_QWORD *)*((_QWORD *)qword_180017550 + 1);
  while ( !*((_BYTE *)v3 + 25) )
  {
    if ( v3[4] >= a1 )
    {
      v2 = v3;
      v3 = (_QWORD *)*v3;
    }
    else
    {
      v3 = (_QWORD *)v3[2];
    }
  }
  if ( !*((_BYTE *)v2 + 25) && a1 >= v2[4] && v2 != qword_180017550 )
  {
    v4 = (__int64 **)v2[2];
    v5 = v2;
    if ( *((_BYTE *)v4 + 25) )
    {
      for ( i = v2[1]; !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 8) )
      {
        if ( v2 != *(_QWORD **)(i + 16) )
          break;
        v2 = (_QWORD *)i;
      }
    }
    else
    {
      for ( j = *v4; !*((_BYTE *)j + 25); j = (__int64 *)*j )
        ;
    }
    v8 = sub_18000CFA0(&qword_180017550, v5);
    j_j_free(v8);
  }
  Mtx_unlock((_Mtx_t)&unk_1800171A0);
  return ((__int64 (__fastcall *)(unsigned __int64))qword_180017628)(a1);
}
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800171EC: using guessed type int dword_1800171EC;
// 180017628: using guessed type __int64 qword_180017628;

//----- (000000018000C460) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
int __fastcall sub_18000C460(double a1)
{
  HMODULE ModuleHandleW; // rax
  int (__stdcall *ioctlsocket)(SOCKET, int, u_long *); // rax
  HANDLE CurrentThread; // rax
  void *v4; // rsi
  __int64 *v5; // rdi
  __int64 v6; // rcx
  __int64 v7; // rdx
  HMODULE LibraryW; // rax
  int (__stdcall *recv)(SOCKET, char *, int, int); // rax
  HANDLE v10; // rax
  __int64 v11; // rcx
  __int64 v12; // rdx
  HMODULE v13; // rax
  int (__stdcall *WSARecv)(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE); // rax
  HANDLE v15; // rax
  __int64 v16; // rcx
  __int64 v17; // rdx
  HMODULE v18; // rax
  int (__stdcall *closesocket)(SOCKET); // rax
  HANDLE v20; // rax
  __int64 v21; // rcx
  __int64 v22; // rdx
  HMODULE v23; // rax
  int (__stdcall *WSASend)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE); // rax
  HANDLE v25; // rax
  __int64 v26; // rcx
  __int64 v27; // rdx
  HMODULE v28; // rax
  INT (__stdcall *GetAddrInfoW)(PCWSTR, PCWSTR, const ADDRINFOW *, PADDRINFOW *); // rax
  HANDLE v30; // rax
  __int64 v31; // rcx
  __int64 v32; // rdx
  HMODULE v33; // rax
  int (__stdcall *connect)(SOCKET, const struct sockaddr *, int); // rax
  HANDLE v35; // rax
  __int64 v36; // rcx
  __int64 v37; // rdx
  HMODULE v38; // rax
  int (__stdcall *WSAConnect)(SOCKET, const struct sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS); // rax
  HANDLE v40; // rax
  __int64 v41; // rcx
  __int64 v42; // rdx
  int (__stdcall *WSAIoctl)(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE); // rax
  HANDLE v44; // rax
  __int64 v45; // rcx
  __int64 v46; // rdx
  __int64 *v48; // [rsp+30h] [rbp-18h] BYREF
  void *v49; // [rsp+38h] [rbp-10h]

  ModuleHandleW = GetModuleHandleW(L"ws2_32.dll");
  if ( ModuleHandleW || (ModuleHandleW = LoadLibraryW(L"ws2_32.dll")) != 0 )
  {
    ioctlsocket = (int (__stdcall *)(SOCKET, int, u_long *))GetProcAddress(ModuleHandleW, "ioctlsocket");
    if ( ioctlsocket )
    {
      qword_180017638 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))ioctlsocket;
      sub_180009150();
      CurrentThread = GetCurrentThread();
      sub_1800097F0(CurrentThread);
      v4 = sub_18000AAF0;
      v5 = (__int64 *)&qword_180017638;
      sub_180009890((_BYTE **)&qword_180017638, sub_18000AAF0);
      if ( !(unsigned int)sub_180009230(a1) )
      {
        if ( Mtx_lock((_Mtx_t)&unk_180019020) )
          goto LABEL_86;
        if ( dword_18001906C == 0x7FFFFFFF )
          goto LABEL_88;
        v48 = (__int64 *)&qword_180017638;
        v49 = sub_18000AAF0;
        v7 = (__int64)*(&Src + 1);
        if ( *(&Src + 1) == (void *)qword_180017548 )
        {
          sub_18000A910(v6, *(&Src + 1), (__int64)&v48);
        }
        else
        {
          *(_QWORD *)*(&Src + 1) = &qword_180017638;
          *(_QWORD *)(v7 + 8) = sub_18000AAF0;
          *(&Src + 1) = (char *)*(&Src + 1) + 16;
        }
        Mtx_unlock((_Mtx_t)&unk_180019020);
      }
    }
  }
  LibraryW = GetModuleHandleW(L"ws2_32.dll");
  if ( LibraryW || (LibraryW = LoadLibraryW(L"ws2_32.dll")) != 0 )
  {
    recv = (int (__stdcall *)(SOCKET, char *, int, int))GetProcAddress(LibraryW, "recv");
    if ( recv )
    {
      qword_180017668 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))recv;
      sub_180009150();
      v10 = GetCurrentThread();
      sub_1800097F0(v10);
      v4 = sub_18000B390;
      v5 = (__int64 *)&qword_180017668;
      sub_180009890((_BYTE **)&qword_180017668, sub_18000B390);
      if ( !(unsigned int)sub_180009230(a1) )
      {
        if ( Mtx_lock((_Mtx_t)&unk_180019020) )
          goto LABEL_86;
        if ( dword_18001906C == 0x7FFFFFFF )
          goto LABEL_88;
        v48 = (__int64 *)&qword_180017668;
        v49 = sub_18000B390;
        v12 = (__int64)*(&Src + 1);
        if ( *(&Src + 1) == (void *)qword_180017548 )
        {
          sub_18000A910(v11, *(&Src + 1), (__int64)&v48);
        }
        else
        {
          *(_QWORD *)*(&Src + 1) = &qword_180017668;
          *(_QWORD *)(v12 + 8) = sub_18000B390;
          *(&Src + 1) = (char *)*(&Src + 1) + 16;
        }
        Mtx_unlock((_Mtx_t)&unk_180019020);
      }
    }
  }
  v13 = GetModuleHandleW(L"ws2_32.dll");
  if ( v13 || (v13 = LoadLibraryW(L"ws2_32.dll")) != 0 )
  {
    WSARecv = (int (__stdcall *)(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))GetProcAddress(v13, "WSARecv");
    if ( WSARecv )
    {
      qword_180017630 = (__int64)WSARecv;
      sub_180009150();
      v15 = GetCurrentThread();
      sub_1800097F0(v15);
      v4 = sub_18000B490;
      v5 = &qword_180017630;
      sub_180009890((_BYTE **)&qword_180017630, sub_18000B490);
      if ( !(unsigned int)sub_180009230(a1) )
      {
        if ( Mtx_lock((_Mtx_t)&unk_180019020) )
          goto LABEL_86;
        if ( dword_18001906C == 0x7FFFFFFF )
          goto LABEL_88;
        v48 = &qword_180017630;
        v49 = sub_18000B490;
        v17 = (__int64)*(&Src + 1);
        if ( *(&Src + 1) == (void *)qword_180017548 )
        {
          sub_18000A910(v16, *(&Src + 1), (__int64)&v48);
        }
        else
        {
          *(_QWORD *)*(&Src + 1) = &qword_180017630;
          *(_QWORD *)(v17 + 8) = sub_18000B490;
          *(&Src + 1) = (char *)*(&Src + 1) + 16;
        }
        Mtx_unlock((_Mtx_t)&unk_180019020);
      }
    }
  }
  v18 = GetModuleHandleW(L"ws2_32.dll");
  if ( v18 || (v18 = LoadLibraryW(L"ws2_32.dll")) != 0 )
  {
    closesocket = (int (__stdcall *)(SOCKET))GetProcAddress(v18, "closesocket");
    if ( closesocket )
    {
      qword_180017628 = (__int64)closesocket;
      sub_180009150();
      v20 = GetCurrentThread();
      sub_1800097F0(v20);
      v4 = sub_18000C330;
      v5 = &qword_180017628;
      sub_180009890((_BYTE **)&qword_180017628, sub_18000C330);
      if ( !(unsigned int)sub_180009230(a1) )
      {
        if ( Mtx_lock((_Mtx_t)&unk_180019020) )
          goto LABEL_86;
        if ( dword_18001906C == 0x7FFFFFFF )
          goto LABEL_88;
        v48 = &qword_180017628;
        v49 = sub_18000C330;
        v22 = (__int64)*(&Src + 1);
        if ( *(&Src + 1) == (void *)qword_180017548 )
        {
          sub_18000A910(v21, *(&Src + 1), (__int64)&v48);
        }
        else
        {
          *(_QWORD *)*(&Src + 1) = &qword_180017628;
          *(_QWORD *)(v22 + 8) = sub_18000C330;
          *(&Src + 1) = (char *)*(&Src + 1) + 16;
        }
        Mtx_unlock((_Mtx_t)&unk_180019020);
      }
    }
  }
  v23 = GetModuleHandleW(L"ws2_32.dll");
  if ( v23 || (v23 = LoadLibraryW(L"ws2_32.dll")) != 0 )
  {
    WSASend = (int (__stdcall *)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))GetProcAddress(v23, "WSASend");
    if ( WSASend )
    {
      qword_180017670 = (__int64)WSASend;
      sub_180009150();
      v25 = GetCurrentThread();
      sub_1800097F0(v25);
      v4 = sub_18000B1E0;
      v5 = &qword_180017670;
      sub_180009890((_BYTE **)&qword_180017670, sub_18000B1E0);
      if ( !(unsigned int)sub_180009230(a1) )
      {
        if ( Mtx_lock((_Mtx_t)&unk_180019020) )
          goto LABEL_86;
        if ( dword_18001906C == 0x7FFFFFFF )
          goto LABEL_88;
        v48 = &qword_180017670;
        v49 = sub_18000B1E0;
        v27 = (__int64)*(&Src + 1);
        if ( *(&Src + 1) == (void *)qword_180017548 )
        {
          sub_18000A910(v26, *(&Src + 1), (__int64)&v48);
        }
        else
        {
          *(_QWORD *)*(&Src + 1) = &qword_180017670;
          *(_QWORD *)(v27 + 8) = sub_18000B1E0;
          *(&Src + 1) = (char *)*(&Src + 1) + 16;
        }
        Mtx_unlock((_Mtx_t)&unk_180019020);
      }
    }
  }
  v28 = GetModuleHandleW(L"ws2_32.dll");
  if ( v28 || (v28 = LoadLibraryW(L"ws2_32.dll")) != 0 )
  {
    GetAddrInfoW = (INT (__stdcall *)(PCWSTR, PCWSTR, const ADDRINFOW *, PADDRINFOW *))GetProcAddress(
                                                                                         v28,
                                                                                         "GetAddrInfoW");
    if ( GetAddrInfoW )
    {
      qword_180017660 = (__int64)GetAddrInfoW;
      sub_180009150();
      v30 = GetCurrentThread();
      sub_1800097F0(v30);
      v4 = sub_18000B5C0;
      v5 = &qword_180017660;
      sub_180009890((_BYTE **)&qword_180017660, sub_18000B5C0);
      if ( !(unsigned int)sub_180009230(a1) )
      {
        if ( Mtx_lock((_Mtx_t)&unk_180019020) )
          goto LABEL_86;
        if ( dword_18001906C == 0x7FFFFFFF )
          goto LABEL_88;
        v48 = &qword_180017660;
        v49 = sub_18000B5C0;
        v32 = (__int64)*(&Src + 1);
        if ( *(&Src + 1) == (void *)qword_180017548 )
        {
          sub_18000A910(v31, *(&Src + 1), (__int64)&v48);
        }
        else
        {
          *(_QWORD *)*(&Src + 1) = &qword_180017660;
          *(_QWORD *)(v32 + 8) = sub_18000B5C0;
          *(&Src + 1) = (char *)*(&Src + 1) + 16;
        }
        Mtx_unlock((_Mtx_t)&unk_180019020);
      }
    }
  }
  v33 = GetModuleHandleW(L"ws2_32.dll");
  if ( v33 || (v33 = LoadLibraryW(L"ws2_32.dll")) != 0 )
  {
    connect = (int (__stdcall *)(SOCKET, const struct sockaddr *, int))GetProcAddress(v33, "connect");
    if ( connect )
    {
      qword_180017648 = (__int64)connect;
      sub_180009150();
      v35 = GetCurrentThread();
      sub_1800097F0(v35);
      v4 = sub_18000BC10;
      v5 = &qword_180017648;
      sub_180009890((_BYTE **)&qword_180017648, sub_18000BC10);
      if ( !(unsigned int)sub_180009230(a1) )
      {
        if ( Mtx_lock((_Mtx_t)&unk_180019020) )
          goto LABEL_86;
        if ( dword_18001906C == 0x7FFFFFFF )
          goto LABEL_88;
        v48 = &qword_180017648;
        v49 = sub_18000BC10;
        v37 = (__int64)*(&Src + 1);
        if ( *(&Src + 1) == (void *)qword_180017548 )
        {
          sub_18000A910(v36, *(&Src + 1), (__int64)&v48);
        }
        else
        {
          *(_QWORD *)*(&Src + 1) = &qword_180017648;
          *(_QWORD *)(v37 + 8) = sub_18000BC10;
          *(&Src + 1) = (char *)*(&Src + 1) + 16;
        }
        Mtx_unlock((_Mtx_t)&unk_180019020);
      }
    }
  }
  v38 = GetModuleHandleW(L"ws2_32.dll");
  if ( v38 || (v38 = LoadLibraryW(L"ws2_32.dll")) != 0 )
  {
    WSAConnect = (int (__stdcall *)(SOCKET, const struct sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS))GetProcAddress(v38, "WSAConnect");
    if ( WSAConnect )
    {
      qword_180017650 = (__int64)WSAConnect;
      sub_180009150();
      v40 = GetCurrentThread();
      sub_1800097F0(v40);
      v4 = sub_18000BE40;
      v5 = &qword_180017650;
      sub_180009890((_BYTE **)&qword_180017650, sub_18000BE40);
      if ( !(unsigned int)sub_180009230(a1) )
      {
        if ( Mtx_lock((_Mtx_t)&unk_180019020) )
          goto LABEL_86;
        if ( dword_18001906C != 0x7FFFFFFF )
        {
          v48 = &qword_180017650;
          v49 = sub_18000BE40;
          v42 = (__int64)*(&Src + 1);
          if ( *(&Src + 1) == (void *)qword_180017548 )
          {
            sub_18000A910(v41, *(&Src + 1), (__int64)&v48);
          }
          else
          {
            *(_QWORD *)*(&Src + 1) = &qword_180017650;
            *(_QWORD *)(v42 + 8) = sub_18000BE40;
            *(&Src + 1) = (char *)*(&Src + 1) + 16;
          }
          Mtx_unlock((_Mtx_t)&unk_180019020);
          goto LABEL_81;
        }
LABEL_88:
        dword_18001906C = 2147483646;
        std::_Throw_Cpp_error(6);
LABEL_89:
        v48 = v5;
        v49 = v4;
        v46 = (__int64)*(&Src + 1);
        if ( *(&Src + 1) == (void *)qword_180017548 )
        {
          sub_18000A910(v45, *(&Src + 1), (__int64)&v48);
        }
        else
        {
          *(_QWORD *)*(&Src + 1) = v5;
          *(_QWORD *)(v46 + 8) = v4;
          *(&Src + 1) = (char *)*(&Src + 1) + 16;
        }
        LODWORD(WSAIoctl) = Mtx_unlock((_Mtx_t)&unk_180019020);
        return (int)WSAIoctl;
      }
    }
  }
LABEL_81:
  WSAIoctl = (int (__stdcall *)(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))GetModuleHandleW(L"ws2_32.dll");
  if ( WSAIoctl
    || (WSAIoctl = (int (__stdcall *)(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))LoadLibraryW(L"ws2_32.dll")) != 0 )
  {
    WSAIoctl = (int (__stdcall *)(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))GetProcAddress((HMODULE)WSAIoctl, "WSAIoctl");
    if ( WSAIoctl )
    {
      qword_180017658 = (__int64)WSAIoctl;
      sub_180009150();
      v44 = GetCurrentThread();
      sub_1800097F0(v44);
      v4 = sub_18000C260;
      v5 = &qword_180017658;
      sub_180009890((_BYTE **)&qword_180017658, sub_18000C260);
      LODWORD(WSAIoctl) = sub_180009230(a1);
      if ( !(_DWORD)WSAIoctl )
      {
        if ( Mtx_lock((_Mtx_t)&unk_180019020) )
        {
LABEL_86:
          std::_Throw_Cpp_error(5);
          __debugbreak();
        }
        if ( dword_18001906C != 0x7FFFFFFF )
          goto LABEL_89;
        goto LABEL_88;
      }
    }
  }
  return (int)WSAIoctl;
}
// 18000C542: variable 'v6' is possibly undefined
// 18000C620: variable 'v11' is possibly undefined
// 18000C6FE: variable 'v16' is possibly undefined
// 18000C7DC: variable 'v21' is possibly undefined
// 18000C8BA: variable 'v26' is possibly undefined
// 18000C998: variable 'v31' is possibly undefined
// 18000CA76: variable 'v36' is possibly undefined
// 18000CB54: variable 'v41' is possibly undefined
// 18000CC4C: variable 'v45' is possibly undefined
// 180011148: using guessed type void std::_Throw_Cpp_error(_DWORD);
// 180017548: using guessed type __int64 qword_180017548;
// 180017628: using guessed type __int64 qword_180017628;
// 180017630: using guessed type __int64 qword_180017630;
// 180017638: using guessed type __int64 (__fastcall *qword_180017638)(_QWORD, _QWORD, _QWORD);
// 180017648: using guessed type __int64 qword_180017648;
// 180017650: using guessed type __int64 qword_180017650;
// 180017658: using guessed type __int64 qword_180017658;
// 180017660: using guessed type __int64 qword_180017660;
// 180017668: using guessed type __int64 (__fastcall *qword_180017668)(_QWORD, _QWORD, _QWORD, _QWORD);
// 180017670: using guessed type __int64 qword_180017670;
// 18001906C: using guessed type int dword_18001906C;

//----- (000000018000CC70) ----------------------------------------------------
int sub_18000CC70(wchar_t *Buffer, wchar_t *Format, ...)
{
  unsigned __int64 *v4; // rax
  int result; // eax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_180003F10();
  result = _stdio_common_vswprintf_s(*v4, Buffer, 0x20u, Format, 0, va);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (000000018000CCD0) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
// Hidden C++ exception states: #wind=1
char *__fastcall sub_18000CCD0(double _XMM0_8, unsigned __int64 *a2)
{
  void *v3; // rsi
  void **v4; // rax
  _BYTE *v5; // r9
  unsigned __int64 v6; // r8
  void **v7; // rdi
  void *v8; // rcx
  BOOL v9; // ebx
  void **v13; // [rsp+20h] [rbp-48h] BYREF
  __int64 v14; // [rsp+28h] [rbp-40h]

  v3 = qword_180017550;
  v4 = (void **)*((_QWORD *)qword_180017550 + 1);
  v5 = qword_180017550;
  if ( *((_BYTE *)v4 + 25) )
  {
    v9 = 0;
    v7 = (void **)*((_QWORD *)qword_180017550 + 1);
  }
  else
  {
    v6 = *a2;
    do
    {
      v7 = v4;
      v8 = v4[4];
      if ( (unsigned __int64)v8 >= v6 )
      {
        v5 = v4;
        v4 = (void **)*v4;
      }
      else
      {
        v4 = (void **)v4[2];
      }
      v9 = (unsigned __int64)v8 >= v6;
    }
    while ( !*((_BYTE *)v4 + 25) );
  }
  if ( v5[25] || *a2 < *((_QWORD *)v5 + 4) )
  {
    if ( qword_180017558 == 0x3FFFFFFFFFFFFFFLL )
      sub_180003290();
    v13 = &qword_180017550;
    v14 = 0;
    _R8 = sub_18000E800(0x40u);
    _R8[4] = *a2;
    __asm { vpxor   xmm0, xmm0, xmm0 }
    __asm { vmovups xmmword ptr [r8+28h], xmm0 }
    *((_DWORD *)_R8 + 14) = 0;
    *_R8 = v3;
    _R8[1] = v3;
    _R8[2] = v3;
    *((_WORD *)_R8 + 12) = 0;
    v13 = v7;
    LODWORD(v14) = v9;
    v5 = (_BYTE *)sub_180003C90(&qword_180017550, (__int64)&v13, (__int64)_R8);
  }
  return v5 + 40;
}
// 18000CCD0: inconsistent variable size for 'xmm0_8.8'
// 180017558: using guessed type __int64 qword_180017558;

//----- (000000018000CDD0) ----------------------------------------------------
void __fastcall sub_18000CDD0(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // rbx
  void *v6; // rcx

  v3 = (_QWORD *)a3;
  if ( !*(_BYTE *)(a3 + 25) )
  {
    do
    {
      sub_18000CDD0(a1, a2, v3[2]);
      v6 = v3;
      v3 = (_QWORD *)*v3;
      j_j_free(v6);
    }
    while ( !*((_BYTE *)v3 + 25) );
  }
}

//----- (000000018000CE20) ----------------------------------------------------
void **__fastcall sub_18000CE20(void **Src, __int64 a2, __int64 a3, __int16 a4)
{
  void *v4; // r14
  __int64 v5; // rbx
  void *v8; // rbp
  unsigned __int64 v9; // r15
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // rdx
  size_t v12; // rcx
  _QWORD *v13; // rdi
  void *v14; // rax
  size_t v15; // r14
  void *v16; // rbx
  _BYTE *v17; // rcx

  v4 = Src[2];
  v5 = 0x7FFFFFFFFFFFFFFELL;
  if ( v4 == (void *)0x7FFFFFFFFFFFFFFELL )
    sub_180001680();
  v8 = (char *)v4 + 1;
  v9 = (unsigned __int64)Src[3];
  v10 = ((unsigned __int64)v4 + 1) | 7;
  if ( v10 > 0x7FFFFFFFFFFFFFFELL || (v11 = v9 >> 1, v9 > 0x7FFFFFFFFFFFFFFELL - (v9 >> 1)) )
  {
    v12 = -2;
  }
  else
  {
    v5 = ((unsigned __int64)v4 + 1) | 7;
    if ( v10 < v9 + v11 )
      v5 = v9 + v11;
    if ( (unsigned __int64)(v5 + 1) > 0x7FFFFFFFFFFFFFFFLL )
      goto LABEL_24;
    v12 = 2 * (v5 + 1);
    if ( !v12 )
    {
      v13 = 0;
      goto LABEL_15;
    }
  }
  if ( v12 < 0x1000 )
  {
    v13 = sub_18000E800(v12);
    goto LABEL_15;
  }
  if ( v12 + 39 < v12 )
LABEL_24:
    Concurrency::cancel_current_task();
  v14 = sub_18000E800(v12 + 39);
  if ( !v14 )
    goto LABEL_19;
  v13 = (_QWORD *)(((unsigned __int64)v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v13 - 1) = v14;
LABEL_15:
  v15 = 2LL * (_QWORD)v4;
  Src[2] = v8;
  Src[3] = (void *)v5;
  if ( v9 <= 7 )
  {
    memcpy(v13, Src, v15);
    *(_WORD *)((char *)v13 + v15) = a4;
    *(_WORD *)((char *)v13 + v15 + 2) = 0;
    goto LABEL_22;
  }
  v16 = *Src;
  memcpy(v13, *Src, v15);
  *(_WORD *)((char *)v13 + v15) = a4;
  *(_WORD *)((char *)v13 + v15 + 2) = 0;
  if ( 2 * v9 + 2 < 0x1000 )
  {
    j_j_free(v16);
    goto LABEL_22;
  }
  v17 = (_BYTE *)*((_QWORD *)v16 - 1);
  if ( (unsigned __int64)((_BYTE *)v16 - v17 - 8) > 0x1F )
LABEL_19:
    __fastfail(5u);
  j_j_free(v17);
LABEL_22:
  *Src = v13;
  return Src;
}

//----- (000000018000CFA0) ----------------------------------------------------
_QWORD *__fastcall sub_18000CFA0(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2; // r9
  _QWORD *v3; // r11
  _QWORD *v5; // rbx
  _QWORD *v6; // rbp
  _QWORD *v7; // rdi
  char v8; // r8
  _QWORD *v9; // rax
  _QWORD **i; // r10
  __int64 *v11; // rdx
  _QWORD *v12; // r8
  _QWORD *v13; // rdx
  __int64 *v14; // rcx
  __int64 v15; // rdx
  _BYTE *v16; // r10
  _QWORD *j; // rcx
  _QWORD *v18; // rcx
  _QWORD *v19; // rcx
  char v20; // dl
  __int64 *v21; // rcx
  _QWORD *v22; // rcx
  _QWORD *v23; // rax
  __int64 v24; // rdx
  __int64 v25; // rax
  __int64 *v26; // rcx
  __int64 v27; // rax
  _QWORD *v28; // rax
  __int64 v29; // rdx
  _QWORD *v30; // rax
  _QWORD *v31; // rcx
  _QWORD *v32; // rax
  __int64 *v33; // rdx
  __int64 **v34; // rax
  __int64 v35; // rax
  _QWORD *v36; // rax
  __int64 v37; // rcx
  _QWORD *result; // rax

  v2 = (_QWORD *)a2[2];
  v3 = a2 + 2;
  v5 = a2;
  v6 = a2;
  v7 = a2;
  v8 = *((_BYTE *)v2 + 25);
  if ( v8 )
  {
    v9 = (_QWORD *)a2[1];
    for ( i = (_QWORD **)(a2 + 1); !*((_BYTE *)v9 + 25); v9 = (_QWORD *)v9[1] )
    {
      if ( a2 != (_QWORD *)v9[2] )
        break;
      a2 = v9;
    }
  }
  else
  {
    v11 = (__int64 *)*v2;
    if ( *(_BYTE *)(*v2 + 25LL) )
    {
      v9 = v2;
    }
    else
    {
      do
      {
        v9 = v11;
        v11 = (__int64 *)*v11;
      }
      while ( !*((_BYTE *)v11 + 25) );
    }
    i = (_QWORD **)(v7 + 1);
  }
  if ( !*(_BYTE *)(*v5 + 25LL) )
  {
    if ( v8 )
    {
      v2 = (_QWORD *)*v5;
    }
    else
    {
      v2 = (_QWORD *)v9[2];
      if ( v9 != v6 )
      {
        *(_QWORD *)(*v5 + 8LL) = v9;
        *v9 = *v5;
        if ( v9 == (_QWORD *)*v3 )
        {
          v12 = v9;
        }
        else
        {
          v12 = (_QWORD *)v9[1];
          if ( !*((_BYTE *)v2 + 25) )
            v2[1] = v12;
          *v12 = v2;
          v9[2] = *v3;
          *(_QWORD *)(*v3 + 8LL) = v9;
        }
        if ( *(_QWORD **)(*a1 + 8LL) == v6 )
        {
          *(_QWORD *)(*a1 + 8LL) = v9;
        }
        else
        {
          v18 = *i;
          if ( (_QWORD *)**i == v6 )
            *v18 = v9;
          else
            v18[2] = v9;
        }
        v19 = *i;
        v16 = v6 + 3;
        v20 = *((_BYTE *)v9 + 24);
        v9[1] = v19;
        *((_BYTE *)v9 + 24) = *((_BYTE *)v6 + 24);
        *((_BYTE *)v6 + 24) = v20;
        goto LABEL_48;
      }
    }
  }
  v12 = *i;
  if ( !*((_BYTE *)v2 + 25) )
    v2[1] = v12;
  if ( *(_QWORD **)(*a1 + 8LL) == v6 )
  {
    *(_QWORD *)(*a1 + 8LL) = v2;
  }
  else if ( (_QWORD *)*v12 == v6 )
  {
    *v12 = v2;
  }
  else
  {
    v12[2] = v2;
  }
  if ( *(_QWORD **)*a1 == v6 )
  {
    if ( *((_BYTE *)v2 + 25) )
    {
      v13 = v12;
    }
    else
    {
      v14 = (__int64 *)*v2;
      if ( *(_BYTE *)(*v2 + 25LL) )
      {
        v13 = v2;
      }
      else
      {
        do
        {
          v13 = v14;
          v14 = (__int64 *)*v14;
        }
        while ( !*((_BYTE *)v14 + 25) );
      }
    }
    *(_QWORD *)*a1 = v13;
  }
  v15 = *a1;
  if ( *(_QWORD **)(*a1 + 16LL) == v6 )
  {
    if ( *((_BYTE *)v2 + 25) )
    {
      v16 = v7 + 3;
      *(_QWORD *)(v15 + 16) = v12;
      goto LABEL_48;
    }
    for ( j = v2; !*(_BYTE *)(j[2] + 25LL); j = (_QWORD *)j[2] )
      ;
    *(_QWORD *)(v15 + 16) = j;
  }
  v16 = v7 + 3;
LABEL_48:
  if ( *v16 == 1 )
  {
    for ( ; v2 != *(_QWORD **)(*a1 + 8LL); v12 = (_QWORD *)v12[1] )
    {
      if ( *((_BYTE *)v2 + 24) != 1 )
        break;
      v21 = (__int64 *)*v12;
      if ( v2 == (_QWORD *)*v12 )
      {
        v21 = (__int64 *)v12[2];
        if ( !*((_BYTE *)v21 + 24) )
        {
          *((_BYTE *)v21 + 24) = 1;
          v22 = (_QWORD *)v12[2];
          *((_BYTE *)v12 + 24) = 0;
          v12[2] = *v22;
          if ( !*(_BYTE *)(*v22 + 25LL) )
            *(_QWORD *)(*v22 + 8LL) = v12;
          v22[1] = v12[1];
          if ( v12 == *(_QWORD **)(*a1 + 8LL) )
          {
            *(_QWORD *)(*a1 + 8LL) = v22;
          }
          else
          {
            v23 = (_QWORD *)v12[1];
            if ( v12 == (_QWORD *)*v23 )
              *v23 = v22;
            else
              v23[2] = v22;
          }
          *v22 = v12;
          v12[1] = v22;
          v21 = (__int64 *)v12[2];
        }
        if ( *((_BYTE *)v21 + 25) )
          goto LABEL_82;
        if ( *(_BYTE *)(*v21 + 24) != 1 || *(_BYTE *)(v21[2] + 24) != 1 )
        {
          if ( *(_BYTE *)(v21[2] + 24) == 1 )
          {
            *(_BYTE *)(*v21 + 24) = 1;
            v24 = *v21;
            *((_BYTE *)v21 + 24) = 0;
            *v21 = *(_QWORD *)(v24 + 16);
            v25 = *(_QWORD *)(v24 + 16);
            if ( !*(_BYTE *)(v25 + 25) )
              *(_QWORD *)(v25 + 8) = v21;
            *(_QWORD *)(v24 + 8) = v21[1];
            if ( v21 == *(__int64 **)(*a1 + 8LL) )
            {
              *(_QWORD *)(*a1 + 8LL) = v24;
            }
            else
            {
              v30 = (_QWORD *)v21[1];
              if ( v21 == (__int64 *)v30[2] )
                v30[2] = v24;
              else
                *v30 = v24;
            }
            *(_QWORD *)(v24 + 16) = v21;
            v21[1] = v24;
            v21 = (__int64 *)v12[2];
          }
          *((_BYTE *)v21 + 24) = *((_BYTE *)v12 + 24);
          *((_BYTE *)v12 + 24) = 1;
          *(_BYTE *)(v21[2] + 24) = 1;
          v31 = (_QWORD *)v12[2];
          v12[2] = *v31;
          if ( !*(_BYTE *)(*v31 + 25LL) )
            *(_QWORD *)(*v31 + 8LL) = v12;
          v31[1] = v12[1];
          if ( v12 == *(_QWORD **)(*a1 + 8LL) )
          {
            *(_QWORD *)(*a1 + 8LL) = v31;
            *v31 = v12;
          }
          else
          {
            v32 = (_QWORD *)v12[1];
            if ( v12 == (_QWORD *)*v32 )
              *v32 = v31;
            else
              v32[2] = v31;
            *v31 = v12;
          }
LABEL_113:
          v12[1] = v31;
          break;
        }
      }
      else
      {
        if ( !*((_BYTE *)v21 + 24) )
        {
          *((_BYTE *)v21 + 24) = 1;
          v26 = (__int64 *)*v12;
          *((_BYTE *)v12 + 24) = 0;
          *v12 = v26[2];
          v27 = v26[2];
          if ( !*(_BYTE *)(v27 + 25) )
            *(_QWORD *)(v27 + 8) = v12;
          v26[1] = v12[1];
          if ( v12 == *(_QWORD **)(*a1 + 8LL) )
          {
            *(_QWORD *)(*a1 + 8LL) = v26;
          }
          else
          {
            v28 = (_QWORD *)v12[1];
            if ( v12 == (_QWORD *)v28[2] )
              v28[2] = v26;
            else
              *v28 = v26;
          }
          v26[2] = (__int64)v12;
          v12[1] = v26;
          v21 = (__int64 *)*v12;
        }
        if ( *((_BYTE *)v21 + 25) )
          goto LABEL_82;
        v29 = v21[2];
        if ( *(_BYTE *)(v29 + 24) != 1 || *(_BYTE *)(*v21 + 24) != 1 )
        {
          if ( *(_BYTE *)(*v21 + 24) == 1 )
          {
            *(_BYTE *)(v29 + 24) = 1;
            v33 = (__int64 *)v21[2];
            *((_BYTE *)v21 + 24) = 0;
            v21[2] = *v33;
            if ( !*(_BYTE *)(*v33 + 25) )
              *(_QWORD *)(*v33 + 8) = v21;
            v33[1] = v21[1];
            if ( v21 == *(__int64 **)(*a1 + 8LL) )
            {
              *(_QWORD *)(*a1 + 8LL) = v33;
            }
            else
            {
              v34 = (__int64 **)v21[1];
              if ( v21 == *v34 )
                *v34 = v33;
              else
                v34[2] = v33;
            }
            *v33 = (__int64)v21;
            v21[1] = (__int64)v33;
            v21 = (__int64 *)*v12;
          }
          *((_BYTE *)v21 + 24) = *((_BYTE *)v12 + 24);
          *((_BYTE *)v12 + 24) = 1;
          *(_BYTE *)(*v21 + 24) = 1;
          v31 = (_QWORD *)*v12;
          *v12 = *(_QWORD *)(*v12 + 16LL);
          v35 = v31[2];
          if ( !*(_BYTE *)(v35 + 25) )
            *(_QWORD *)(v35 + 8) = v12;
          v31[1] = v12[1];
          if ( v12 == *(_QWORD **)(*a1 + 8LL) )
          {
            *(_QWORD *)(*a1 + 8LL) = v31;
          }
          else
          {
            v36 = (_QWORD *)v12[1];
            if ( v12 == (_QWORD *)v36[2] )
              v36[2] = v31;
            else
              *v36 = v31;
          }
          v31[2] = v12;
          goto LABEL_113;
        }
      }
      *((_BYTE *)v21 + 24) = 0;
LABEL_82:
      v2 = v12;
    }
    *((_BYTE *)v2 + 24) = 1;
  }
  v37 = a1[1];
  result = v6;
  if ( v37 )
    a1[1] = v37 - 1;
  return result;
}

//----- (000000018000D460) ----------------------------------------------------
int sub_18000D460(wchar_t *Buffer, size_t BufferCount, wchar_t *Format, ...)
{
  unsigned __int64 *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = (unsigned __int64 *)sub_180003F10();
  result = _stdio_common_vswprintf_s(*v6, Buffer, BufferCount, Format, 0, va);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (000000018000D4C0) ----------------------------------------------------
BOOL __stdcall GetFileVersionInfoA(LPCSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
{
  BOOL (__stdcall *ProcAddress)(LPCSTR, DWORD, DWORD, LPVOID); // rax
  BOOL result; // eax

  ProcAddress = (BOOL (__stdcall *)(LPCSTR, DWORD, DWORD, LPVOID))qword_1800176A8;
  result = (qword_1800176A8
         || hLibModule
         && (ProcAddress = (BOOL (__stdcall *)(LPCSTR, DWORD, DWORD, LPVOID))GetProcAddress(
                                                                               hLibModule,
                                                                               "GetFileVersionInfoA"),
             (qword_1800176A8 = (__int64)ProcAddress) != 0))
        && ((BOOL (__fastcall *)(LPCSTR, _QWORD, _QWORD, LPVOID))ProcAddress)(lptstrFilename, dwHandle, dwLen, lpData);
  return result;
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800176A8: using guessed type __int64 qword_1800176A8;

//----- (000000018000D530) ----------------------------------------------------
__int64 __fastcall GetFileVersionInfoByHandle(__int64 a1, __int64 a2, unsigned int a3, unsigned int a4)
{
  FARPROC ProcAddress; // rax

  ProcAddress = (FARPROC)qword_180017700;
  if ( qword_180017700 )
    return ((__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD))ProcAddress)(a1, a2, a3, a4);
  if ( hLibModule
    && (ProcAddress = GetProcAddress(hLibModule, "GetFileVersionInfoByHandle"),
        (qword_180017700 = (__int64)ProcAddress) != 0) )
  {
    return ((__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD))ProcAddress)(a1, a2, a3, a4);
  }
  else
  {
    return 0;
  }
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 180017700: using guessed type __int64 qword_180017700;

//----- (000000018000D5A0) ----------------------------------------------------
BOOL __stdcall GetFileVersionInfoExA(DWORD dwFlags, LPCSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
{
  BOOL (__stdcall *v5)(DWORD, LPCSTR, DWORD, DWORD, LPVOID); // r10
  BOOL result; // eax

  v5 = GetFileVersionInfoExA_0;
  result = (GetFileVersionInfoExA_0
         || hLibModule
         && (GetFileVersionInfoExA_0 = (BOOL (__stdcall *)(DWORD, LPCSTR, DWORD, DWORD, LPVOID))GetProcAddress(
                                                                                                  hLibModule,
                                                                                                  "GetFileVersionInfoExA"),
             (v5 = GetFileVersionInfoExA_0) != 0))
        && ((BOOL (__fastcall *)(_QWORD, LPCSTR, _QWORD, _QWORD, LPVOID))v5)(
             dwFlags,
             lpwstrFilename,
             dwHandle,
             dwLen,
             lpData);
  return result;
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000D620) ----------------------------------------------------
BOOL __stdcall GetFileVersionInfoExW(DWORD dwFlags, LPCWSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
{
  BOOL (__stdcall *v5)(DWORD, LPCWSTR, DWORD, DWORD, LPVOID); // r10
  BOOL result; // eax

  v5 = GetFileVersionInfoExW_0;
  result = (GetFileVersionInfoExW_0
         || hLibModule
         && (GetFileVersionInfoExW_0 = (BOOL (__stdcall *)(DWORD, LPCWSTR, DWORD, DWORD, LPVOID))GetProcAddress(
                                                                                                   hLibModule,
                                                                                                   "GetFileVersionInfoExW"),
             (v5 = GetFileVersionInfoExW_0) != 0))
        && ((BOOL (__fastcall *)(_QWORD, LPCWSTR, _QWORD, _QWORD, LPVOID))v5)(
             dwFlags,
             lpwstrFilename,
             dwHandle,
             dwLen,
             lpData);
  return result;
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000D6A0) ----------------------------------------------------
DWORD __stdcall GetFileVersionInfoSizeA(LPCSTR lptstrFilename, LPDWORD lpdwHandle)
{
  DWORD (__stdcall *ProcAddress)(LPCSTR, LPDWORD); // rax

  ProcAddress = (DWORD (__stdcall *)(LPCSTR, LPDWORD))qword_1800176D8;
  if ( qword_1800176D8 )
    return ((DWORD (__fastcall *)(LPCSTR, LPDWORD))ProcAddress)(lptstrFilename, lpdwHandle);
  if ( hLibModule
    && (ProcAddress = (DWORD (__stdcall *)(LPCSTR, LPDWORD))GetProcAddress(hLibModule, "GetFileVersionInfoSizeA"),
        (qword_1800176D8 = (__int64)ProcAddress) != 0) )
  {
    return ((DWORD (__fastcall *)(LPCSTR, LPDWORD))ProcAddress)(lptstrFilename, lpdwHandle);
  }
  else
  {
    return 0;
  }
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800176D8: using guessed type __int64 qword_1800176D8;

//----- (000000018000D710) ----------------------------------------------------
DWORD __stdcall GetFileVersionInfoSizeExA(DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle)
{
  DWORD (__stdcall *ProcAddress)(DWORD, LPCSTR, LPDWORD); // rax

  ProcAddress = (DWORD (__stdcall *)(DWORD, LPCSTR, LPDWORD))qword_1800176E8;
  if ( qword_1800176E8 )
    return ((DWORD (__fastcall *)(_QWORD, LPCSTR, LPDWORD))ProcAddress)(dwFlags, lpwstrFilename, lpdwHandle);
  if ( hLibModule
    && (ProcAddress = (DWORD (__stdcall *)(DWORD, LPCSTR, LPDWORD))GetProcAddress(
                                                                     hLibModule,
                                                                     "GetFileVersionInfoSizeExA"),
        (qword_1800176E8 = (__int64)ProcAddress) != 0) )
  {
    return ((DWORD (__fastcall *)(_QWORD, LPCSTR, LPDWORD))ProcAddress)(dwFlags, lpwstrFilename, lpdwHandle);
  }
  else
  {
    return 0;
  }
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800176E8: using guessed type __int64 qword_1800176E8;

//----- (000000018000D790) ----------------------------------------------------
DWORD __stdcall GetFileVersionInfoSizeExW(DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle)
{
  DWORD (__stdcall *ProcAddress)(DWORD, LPCWSTR, LPDWORD); // rax

  ProcAddress = (DWORD (__stdcall *)(DWORD, LPCWSTR, LPDWORD))qword_1800176E0;
  if ( qword_1800176E0 )
    return ((DWORD (__fastcall *)(_QWORD, LPCWSTR, LPDWORD))ProcAddress)(dwFlags, lpwstrFilename, lpdwHandle);
  if ( hLibModule
    && (ProcAddress = (DWORD (__stdcall *)(DWORD, LPCWSTR, LPDWORD))GetProcAddress(
                                                                      hLibModule,
                                                                      "GetFileVersionInfoSizeExW"),
        (qword_1800176E0 = (__int64)ProcAddress) != 0) )
  {
    return ((DWORD (__fastcall *)(_QWORD, LPCWSTR, LPDWORD))ProcAddress)(dwFlags, lpwstrFilename, lpdwHandle);
  }
  else
  {
    return 0;
  }
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800176E0: using guessed type __int64 qword_1800176E0;

//----- (000000018000D810) ----------------------------------------------------
DWORD __stdcall GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
{
  DWORD (__stdcall *ProcAddress)(LPCWSTR, LPDWORD); // rax

  ProcAddress = (DWORD (__stdcall *)(LPCWSTR, LPDWORD))qword_180017690;
  if ( qword_180017690 )
    return ((DWORD (__fastcall *)(LPCWSTR, LPDWORD))ProcAddress)(lptstrFilename, lpdwHandle);
  if ( hLibModule
    && (ProcAddress = (DWORD (__stdcall *)(LPCWSTR, LPDWORD))GetProcAddress(hLibModule, "GetFileVersionInfoSizeW"),
        (qword_180017690 = (__int64)ProcAddress) != 0) )
  {
    return ((DWORD (__fastcall *)(LPCWSTR, LPDWORD))ProcAddress)(lptstrFilename, lpdwHandle);
  }
  else
  {
    return 0;
  }
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 180017690: using guessed type __int64 qword_180017690;

//----- (000000018000D880) ----------------------------------------------------
BOOL __stdcall GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
{
  BOOL (__stdcall *ProcAddress)(LPCWSTR, DWORD, DWORD, LPVOID); // rax
  BOOL result; // eax

  ProcAddress = (BOOL (__stdcall *)(LPCWSTR, DWORD, DWORD, LPVOID))qword_1800176C8;
  result = (qword_1800176C8
         || hLibModule
         && (ProcAddress = (BOOL (__stdcall *)(LPCWSTR, DWORD, DWORD, LPVOID))GetProcAddress(
                                                                                hLibModule,
                                                                                "GetFileVersionInfoW"),
             (qword_1800176C8 = (__int64)ProcAddress) != 0))
        && ((BOOL (__fastcall *)(LPCWSTR, _QWORD, _QWORD, LPVOID))ProcAddress)(lptstrFilename, dwHandle, dwLen, lpData);
  return result;
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800176C8: using guessed type __int64 qword_1800176C8;

//----- (000000018000D8F0) ----------------------------------------------------
DWORD __stdcall VerFindFileA(
        DWORD uFlags,
        LPCSTR szFileName,
        LPCSTR szWinDir,
        LPCSTR szAppDir,
        LPSTR szCurDir,
        PUINT puCurDirLen,
        LPSTR szDestDir,
        PUINT puDestDirLen)
{
  DWORD (__stdcall *v8)(DWORD, LPCSTR, LPCSTR, LPCSTR, LPSTR, PUINT, LPSTR, PUINT); // r10

  v8 = VerFindFileA_0;
  if ( VerFindFileA_0 )
    return ((DWORD (__fastcall *)(_QWORD, LPCSTR, LPCSTR, LPCSTR, LPSTR, PUINT, LPSTR, PUINT))v8)(
             uFlags,
             szFileName,
             szWinDir,
             szAppDir,
             szCurDir,
             puCurDirLen,
             szDestDir,
             puDestDirLen);
  if ( hLibModule
    && (VerFindFileA_0 = (DWORD (__stdcall *)(DWORD, LPCSTR, LPCSTR, LPCSTR, LPSTR, PUINT, LPSTR, PUINT))GetProcAddress(hLibModule, "VerFindFileA"),
        (v8 = VerFindFileA_0) != 0) )
  {
    return ((DWORD (__fastcall *)(_QWORD, LPCSTR, LPCSTR, LPCSTR, LPSTR, PUINT, LPSTR, PUINT))v8)(
             uFlags,
             szFileName,
             szWinDir,
             szAppDir,
             szCurDir,
             puCurDirLen,
             szDestDir,
             puDestDirLen);
  }
  else
  {
    return 0;
  }
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000D9A0) ----------------------------------------------------
DWORD __stdcall VerFindFileW(
        DWORD uFlags,
        LPCWSTR szFileName,
        LPCWSTR szWinDir,
        LPCWSTR szAppDir,
        LPWSTR szCurDir,
        PUINT puCurDirLen,
        LPWSTR szDestDir,
        PUINT puDestDirLen)
{
  DWORD (__stdcall *v8)(DWORD, LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR, PUINT, LPWSTR, PUINT); // r10

  v8 = VerFindFileW_0;
  if ( VerFindFileW_0 )
    return ((DWORD (__fastcall *)(_QWORD, LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR, PUINT, LPWSTR, PUINT))v8)(
             uFlags,
             szFileName,
             szWinDir,
             szAppDir,
             szCurDir,
             puCurDirLen,
             szDestDir,
             puDestDirLen);
  if ( hLibModule
    && (VerFindFileW_0 = (DWORD (__stdcall *)(DWORD, LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR, PUINT, LPWSTR, PUINT))GetProcAddress(hLibModule, "VerFindFileW"),
        (v8 = VerFindFileW_0) != 0) )
  {
    return ((DWORD (__fastcall *)(_QWORD, LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR, PUINT, LPWSTR, PUINT))v8)(
             uFlags,
             szFileName,
             szWinDir,
             szAppDir,
             szCurDir,
             puCurDirLen,
             szDestDir,
             puDestDirLen);
  }
  else
  {
    return 0;
  }
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000DA50) ----------------------------------------------------
DWORD __stdcall VerInstallFileA(
        DWORD uFlags,
        LPCSTR szSrcFileName,
        LPCSTR szDestFileName,
        LPCSTR szSrcDir,
        LPCSTR szDestDir,
        LPCSTR szCurDir,
        LPSTR szTmpFile,
        PUINT puTmpFileLen)
{
  DWORD (__stdcall *v8)(DWORD, LPCSTR, LPCSTR, LPCSTR, LPCSTR, LPCSTR, LPSTR, PUINT); // r10

  v8 = VerInstallFileA_0;
  if ( VerInstallFileA_0 )
    return ((DWORD (__fastcall *)(_QWORD, LPCSTR, LPCSTR, LPCSTR, LPCSTR, LPCSTR, LPSTR, PUINT))v8)(
             uFlags,
             szSrcFileName,
             szDestFileName,
             szSrcDir,
             szDestDir,
             szCurDir,
             szTmpFile,
             puTmpFileLen);
  if ( hLibModule
    && (VerInstallFileA_0 = (DWORD (__stdcall *)(DWORD, LPCSTR, LPCSTR, LPCSTR, LPCSTR, LPCSTR, LPSTR, PUINT))GetProcAddress(hLibModule, "VerInstallFileA"),
        (v8 = VerInstallFileA_0) != 0) )
  {
    return ((DWORD (__fastcall *)(_QWORD, LPCSTR, LPCSTR, LPCSTR, LPCSTR, LPCSTR, LPSTR, PUINT))v8)(
             uFlags,
             szSrcFileName,
             szDestFileName,
             szSrcDir,
             szDestDir,
             szCurDir,
             szTmpFile,
             puTmpFileLen);
  }
  else
  {
    return 0;
  }
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000DB00) ----------------------------------------------------
DWORD __stdcall VerInstallFileW(
        DWORD uFlags,
        LPCWSTR szSrcFileName,
        LPCWSTR szDestFileName,
        LPCWSTR szSrcDir,
        LPCWSTR szDestDir,
        LPCWSTR szCurDir,
        LPWSTR szTmpFile,
        PUINT puTmpFileLen)
{
  DWORD (__stdcall *v8)(DWORD, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR, PUINT); // r10

  v8 = VerInstallFileW_0;
  if ( VerInstallFileW_0 )
    return ((DWORD (__fastcall *)(_QWORD, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR, PUINT))v8)(
             uFlags,
             szSrcFileName,
             szDestFileName,
             szSrcDir,
             szDestDir,
             szCurDir,
             szTmpFile,
             puTmpFileLen);
  if ( hLibModule
    && (VerInstallFileW_0 = (DWORD (__stdcall *)(DWORD, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR, PUINT))GetProcAddress(hLibModule, "VerInstallFileW"),
        (v8 = VerInstallFileW_0) != 0) )
  {
    return ((DWORD (__fastcall *)(_QWORD, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR, PUINT))v8)(
             uFlags,
             szSrcFileName,
             szDestFileName,
             szSrcDir,
             szDestDir,
             szCurDir,
             szTmpFile,
             puTmpFileLen);
  }
  else
  {
    return 0;
  }
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000DBB0) ----------------------------------------------------
DWORD __stdcall VerLanguageNameA(DWORD wLang, LPSTR szLang, DWORD cchLang)
{
  DWORD (__stdcall *ProcAddress)(DWORD, LPSTR, DWORD); // rax

  ProcAddress = (DWORD (__stdcall *)(DWORD, LPSTR, DWORD))qword_1800176B8;
  if ( qword_1800176B8 )
    return ((DWORD (__fastcall *)(_QWORD, LPSTR, _QWORD))ProcAddress)(wLang, szLang, cchLang);
  if ( hLibModule
    && (ProcAddress = (DWORD (__stdcall *)(DWORD, LPSTR, DWORD))GetProcAddress(hLibModule, "VerLanguageNameA"),
        (qword_1800176B8 = (__int64)ProcAddress) != 0) )
  {
    return ((DWORD (__fastcall *)(_QWORD, LPSTR, _QWORD))ProcAddress)(wLang, szLang, cchLang);
  }
  else
  {
    return 0;
  }
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800176B8: using guessed type __int64 qword_1800176B8;

//----- (000000018000DC30) ----------------------------------------------------
DWORD __stdcall VerLanguageNameW(DWORD wLang, LPWSTR szLang, DWORD cchLang)
{
  DWORD (__stdcall *ProcAddress)(DWORD, LPWSTR, DWORD); // rax

  ProcAddress = (DWORD (__stdcall *)(DWORD, LPWSTR, DWORD))qword_1800176D0;
  if ( qword_1800176D0 )
    return ((DWORD (__fastcall *)(_QWORD, LPWSTR, _QWORD))ProcAddress)(wLang, szLang, cchLang);
  if ( hLibModule
    && (ProcAddress = (DWORD (__stdcall *)(DWORD, LPWSTR, DWORD))GetProcAddress(hLibModule, "VerLanguageNameW"),
        (qword_1800176D0 = (__int64)ProcAddress) != 0) )
  {
    return ((DWORD (__fastcall *)(_QWORD, LPWSTR, _QWORD))ProcAddress)(wLang, szLang, cchLang);
  }
  else
  {
    return 0;
  }
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800176D0: using guessed type __int64 qword_1800176D0;

//----- (000000018000DCB0) ----------------------------------------------------
BOOL __stdcall VerQueryValueA(LPCVOID pBlock, LPCSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
{
  BOOL (__stdcall *ProcAddress)(LPCVOID, LPCSTR, LPVOID *, PUINT); // rax
  BOOL result; // eax

  ProcAddress = (BOOL (__stdcall *)(LPCVOID, LPCSTR, LPVOID *, PUINT))qword_1800176F0;
  result = (qword_1800176F0
         || hLibModule
         && (ProcAddress = (BOOL (__stdcall *)(LPCVOID, LPCSTR, LPVOID *, PUINT))GetProcAddress(
                                                                                   hLibModule,
                                                                                   "VerQueryValueA"),
             (qword_1800176F0 = (__int64)ProcAddress) != 0))
        && ((BOOL (__fastcall *)(LPCVOID, LPCSTR, LPVOID *, PUINT))ProcAddress)(pBlock, lpSubBlock, lplpBuffer, puLen);
  return result;
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800176F0: using guessed type __int64 qword_1800176F0;

//----- (000000018000DD20) ----------------------------------------------------
BOOL __stdcall VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
{
  BOOL (__stdcall *ProcAddress)(LPCVOID, LPCWSTR, LPVOID *, PUINT); // rax
  BOOL result; // eax

  ProcAddress = (BOOL (__stdcall *)(LPCVOID, LPCWSTR, LPVOID *, PUINT))qword_180017688;
  result = (qword_180017688
         || hLibModule
         && (ProcAddress = (BOOL (__stdcall *)(LPCVOID, LPCWSTR, LPVOID *, PUINT))GetProcAddress(
                                                                                    hLibModule,
                                                                                    "VerQueryValueW"),
             (qword_180017688 = (__int64)ProcAddress) != 0))
        && ((BOOL (__fastcall *)(LPCVOID, LPCWSTR, LPVOID *, PUINT))ProcAddress)(pBlock, lpSubBlock, lplpBuffer, puLen);
  return result;
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 180017688: using guessed type __int64 qword_180017688;

//----- (000000018000DD90) ----------------------------------------------------
char __fastcall sub_18000DD90(const __m128i *a1, __int64 a2)
{
  __m128i si128; // xmm1
  char v3; // al
  const __m128i *v4; // rdx
  const __m128i *v5; // rdx

  si128 = _mm_load_si128((const __m128i *)&xmmword_180013B50);
  v3 = 2 * a2;
  v4 = (const __m128i *)((char *)a1 + ((2 * a2) & 0xFFFFFFFFFFFFFFF0uLL));
  if ( a1 == v4 )
  {
LABEL_4:
    v5 = (const __m128i *)((char *)v4 + (v3 & 0xF));
    if ( a1 == v5 )
      return 1;
    while ( (a1->m128i_i16[0] & 0xFF00) == 0 )
    {
      a1 = (const __m128i *)((char *)a1 + 2);
      if ( a1 == v5 )
        return 1;
    }
  }
  else
  {
    while ( _mm_testz_si128(si128, _mm_loadu_si128(a1)) )
    {
      if ( ++a1 == v4 )
        goto LABEL_4;
    }
  }
  return 0;
}
// 180013B50: using guessed type __int128 xmmword_180013B50;

//----- (000000018000DDF0) ----------------------------------------------------
unsigned __int64 __fastcall sub_18000DDF0(__m128i *Src, unsigned __int64 a2, __m128i *a3, unsigned __int64 a4)
{
  unsigned __int64 v4; // rbp
  __m128i *v6; // rdi
  unsigned __int64 v7; // rbx
  int v9; // ecx
  bool v10; // cf
  bool v11; // zf
  unsigned __int16 *i; // rcx
  __int64 v14; // rax
  __int64 v15; // rax
  unsigned __int16 *v16; // rdx
  unsigned __int16 *v17; // rcx
  __int64 v18; // rax
  __int64 v19; // rax
  __int16 v20; // cx
  __m128i *v21; // rax
  _BYTE v22[256]; // [rsp+40h] [rbp+0h] BYREF

  v4 = (unsigned __int64)v22 & 0xFFFFFFFFFFFFFFE0uLL;
  v6 = a3;
  v7 = a2;
  if ( (dword_18001700C & 4) != 0 )
  {
    if ( (dword_18001700C & 0x20) != 0 && a2 > 0x30 )
    {
      if ( a4 > 8 )
        v9 = 2;
      else
        v9 = 2 * (a2 > 0x80);
    }
    else
    {
      v9 = 0;
      if ( a4 > 8 )
      {
        if ( a4 > 0x50 )
        {
          v10 = a2 < 8;
          v11 = a2 == 8;
        }
        else
        {
          v10 = a2 < 0x10;
          v11 = a2 == 16;
        }
        LOBYTE(v9) = !v10 && !v11;
      }
    }
    if ( v9 == 2 )
    {
      if ( sub_18000DD90(a3, a4) )
        return sub_18000E320(Src, v7, (unsigned __int16 *)a3, a4);
      return sub_18000E0E0(Src, v7, a3, a4);
    }
    if ( v9 != 1 || !sub_18000DD90(a3, a4) )
      return sub_18000E0E0(Src, v7, a3, a4);
    memset((void *)((unsigned __int64)v22 & 0xFFFFFFFFFFFFFFE0uLL), 0, 0x100u);
    for ( i = (unsigned __int16 *)v6 + a4; v6 != (__m128i *)i; *(_BYTE *)(v4 + v14) = 1 )
    {
      v14 = v6->m128i_u16[0];
      v6 = (__m128i *)((char *)v6 + 2);
    }
    if ( v7 )
    {
      while ( 1 )
      {
        v15 = Src->m128i_u16[--v7];
        if ( (unsigned __int16)v15 < 0x100u )
        {
          if ( *(_BYTE *)(v4 + v15) )
            break;
        }
        if ( !v7 )
          return -1;
      }
      return v7;
    }
  }
  else
  {
    memset((void *)((unsigned __int64)v22 & 0xFFFFFFFFFFFFFFE0uLL), 0, 0x100u);
    v16 = (unsigned __int16 *)v6 + a4;
    v17 = (unsigned __int16 *)v6;
    if ( v6 == (__m128i *)v16 )
    {
LABEL_28:
      if ( v7 )
      {
        while ( 1 )
        {
          v19 = Src->m128i_u16[--v7];
          if ( (unsigned __int16)v19 < 0x100u )
          {
            if ( *(_BYTE *)(v4 + v19) )
              break;
          }
          if ( !v7 )
            return -1;
        }
        return v7;
      }
    }
    else
    {
      while ( 1 )
      {
        v18 = *v17;
        if ( (unsigned __int16)v18 >= 0x100u )
          break;
        ++v17;
        *(_BYTE *)(v4 + v18) = 1;
        if ( v17 == v16 )
          goto LABEL_28;
      }
      if ( v7 )
      {
LABEL_35:
        v20 = Src->m128i_i16[--v7];
        v21 = v6;
        while ( v20 != v21->m128i_i16[0] )
        {
          v21 = (__m128i *)((char *)v21 + 2);
          if ( v21 == (__m128i *)v16 )
          {
            if ( v7 )
              goto LABEL_35;
            return -1;
          }
        }
        return v7;
      }
    }
  }
  return -1;
}
// 18000DE96: variable 'a3' is possibly undefined
// 18000DE96: variable 'a4' is possibly undefined
// 18001700C: using guessed type int dword_18001700C;

//----- (000000018000DFE0) ----------------------------------------------------
const __m128i *__fastcall sub_18000DFE0(const __m128i *a1, const __m128i *a2, unsigned __int8 a3)
{
  signed __int64 v5; // r9
  const __m128i *v7; // r10
  unsigned int v14; // r9d
  unsigned __int64 v22; // r9
  const __m128i *v23; // r10
  __m128i v24; // xmm1
  __int64 v25; // rax

  v5 = (char *)a2 - (char *)a1;
  if ( (((char *)a2 - (char *)a1) & 0xFFFFFFFFFFFFFFE0uLL) != 0 && (dword_18001700C & 0x20) != 0 )
  {
    _EAX = (char)a3;
    v7 = (const __m128i *)((char *)a1 + (((char *)a2 - (char *)a1) & 0xFFFFFFFFFFFFFFE0uLL));
    __asm
    {
      vmovd   xmm3, eax
      vpxor   xmm0, xmm0, xmm0
      vpshufb xmm3, xmm3, xmm0
      vinsertf128 ymm3, ymm3, xmm3, 1
    }
    do
    {
      __asm
      {
        vpcmpeqb ymm1, ymm3, ymmword ptr [rcx]
        vpmovmskb eax, ymm1
      }
      if ( _EAX )
        goto LABEL_14;
      a1 += 2;
    }
    while ( a1 != v7 );
    v14 = v5 & 0x1C;
    if ( !v14 )
    {
LABEL_9:
      __asm { vzeroupper }
      goto LABEL_10;
    }
    _RAX = (char *)&unk_180013B30 - v14;
    __asm
    {
      vmovdqu ymm2, ymmword ptr [rax]
      vpmaskmovd ymm0, ymm2, ymmword ptr [rcx]
      vpcmpeqb ymm1, ymm0, ymm3
      vpand   ymm2, ymm1, ymm2
      vpmovmskb eax, ymm2
    }
    if ( !_EAX )
    {
      a1 = (const __m128i *)((char *)a1 + v14);
      goto LABEL_9;
    }
LABEL_14:
    __asm
    {
      vzeroupper
      tzcnt   eax, eax
    }
    return (const __m128i *)((char *)a1 + _EAX);
  }
  else
  {
    v22 = v5 & 0xFFFFFFFFFFFFFFF0uLL;
    if ( v22 && (dword_18001700C & 4) != 0 )
    {
      v23 = (const __m128i *)((char *)a1 + v22);
      v24 = _mm_shuffle_epi8(_mm_cvtsi32_si128(a3), (__m128i)0LL);
      while ( 1 )
      {
        LODWORD(v25) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), v24));
        if ( (_DWORD)v25 )
          break;
        if ( ++a1 == v23 )
          goto LABEL_10;
      }
      _BitScanForward((unsigned int *)&v25, v25);
      return (const __m128i *)((char *)a1 + v25);
    }
    else
    {
LABEL_10:
      while ( a1 != a2 )
      {
        if ( a1->m128i_i8[0] == a3 )
          break;
        a1 = (const __m128i *)((char *)a1 + 1);
      }
      return a1;
    }
  }
}
// 18000E0CE: variable 'v25' is possibly undefined
// 18001700C: using guessed type int dword_18001700C;

//----- (000000018000E0E0) ----------------------------------------------------
unsigned __int64 __fastcall sub_18000E0E0(const __m128i *Src, __int64 a2, const __m128i *a3, __int64 a4)
{
  size_t v4; // rbp
  unsigned int v5; // r14d
  unsigned __int64 v6; // r15
  __int64 v7; // rax
  const __m128i *v8; // rbx
  const __m128i *v9; // rsi
  int v11; // edi
  __int8 *v12; // r12
  __m128i si128; // xmm6
  __m128i v14; // xmm0
  int v15; // ecx
  unsigned __int64 v16; // r15
  __m128i v17; // xmm0
  int v19; // ecx
  size_t v20; // r14
  const __m128i *v21; // rbp
  __m128i v22; // xmm6
  size_t v23; // r14
  __m128i v24; // xmm1
  int v25; // r9d
  const __m128i *v26; // r8
  __m128i v27; // xmm0
  int v28; // ecx
  int v29; // ecx
  unsigned __int64 v30; // r15
  __m128i v31; // xmm1
  __m128i v32; // xmm0
  int v33; // ecx
  int v34; // ecx
  size_t Size[2]; // [rsp+20h] [rbp-88h] BYREF
  __m128i v36; // [rsp+30h] [rbp-78h] BYREF

  v4 = 2 * a2;
  v5 = a4;
  Size[0] = 2 * a2;
  v6 = (2 * (_BYTE)a2) & 0xF;
  v7 = 2 * a4;
  v8 = (const __m128i *)((char *)Src + 2 * a2);
  v9 = a3;
  v11 = -1;
  v12 = &Src->m128i_i8[v6];
  if ( (unsigned __int64)(2 * a4) <= 0x10 )
  {
    memcpy(Size, a3, 2 * a4);
    si128 = _mm_load_si128((const __m128i *)Size);
    while ( v8 != (const __m128i *)v12 )
    {
      v14 = _mm_loadu_si128(--v8);
      v15 = _mm_cmpestri(si128, v14, v5, 8u);
      if ( _mm_cmpestrc(si128, v14, v5, 8u) )
        return ((unsigned __int64)((char *)v8 - (char *)Src) >> 1) + v15;
    }
    if ( v6 )
    {
      v16 = v6 >> 1;
      if ( v4 < 0x10 )
      {
        memcpy(Size, Src, v4);
        v17 = _mm_load_si128((const __m128i *)Size);
      }
      else
      {
        v17 = _mm_loadu_si128(Src);
      }
      v19 = _mm_cmpestri(si128, v17, v5, v16);
      if ( _mm_cmpestrc(si128, v17, v5, v16) )
        return v19;
    }
    return -1;
  }
  v20 = v7 & 0xF;
  v21 = (const __m128i *)((char *)a3 + (v7 & 0xFFFFFFFFFFFFFFF0uLL));
  memcpy(&v36, v21, v20);
  v22 = _mm_load_si128(&v36);
  v23 = v20 >> 1;
  if ( v8 == (const __m128i *)v12 )
  {
LABEL_24:
    if ( v6 )
    {
      v30 = v6 >> 1;
      if ( Size[0] < 0x10 )
      {
        memcpy(&v36, Src, Size[0]);
        v31 = _mm_load_si128(&v36);
      }
      else
      {
        v31 = _mm_loadu_si128(Src);
      }
      do
      {
        v32 = _mm_loadu_si128(v9);
        v33 = _mm_cmpestri(v32, v31, 8u, v30);
        if ( _mm_cmpestrc(v32, v31, 8u, v30) && v33 > v11 )
          v11 = v33;
        ++v9;
      }
      while ( v9 != v21 );
      if ( (_DWORD)v23 )
      {
        v34 = _mm_cmpestri(v22, v31, v23, v30);
        if ( _mm_cmpestrc(v22, v31, v23, v30) )
        {
          if ( v34 > v11 )
            return v34;
        }
      }
      return v11;
    }
    return -1;
  }
  while ( 1 )
  {
    v24 = _mm_loadu_si128(--v8);
    v25 = -1;
    v26 = v9;
    do
    {
      v27 = _mm_loadu_si128(v26);
      v28 = _mm_cmpestri(v27, v24, 8u, 8u);
      if ( _mm_cmpestrc(v27, v24, 8u, 8u) && v28 > v25 )
        v25 = v28;
      ++v26;
    }
    while ( v26 != v21 );
    if ( (_DWORD)v23 )
    {
      v29 = _mm_cmpestri(v22, v24, v23, 8u);
      if ( _mm_cmpestrc(v22, v24, v23, 8u) )
      {
        if ( v29 > v25 )
          v25 = v29;
      }
    }
    if ( v25 != -1 )
      return ((unsigned __int64)((char *)v8 - (char *)Src) >> 1) + v25;
    if ( v8 == (const __m128i *)v12 )
      goto LABEL_24;
  }
}

//----- (000000018000E320) ----------------------------------------------------
unsigned __int64 __fastcall sub_18000E320(void *Src, unsigned __int64 a2, unsigned __int16 *a3, unsigned __int64 a4)
{
  unsigned int v34; // edx
  unsigned __int64 result; // rax
  _OWORD v36[2]; // [rsp+40h] [rbp+0h] BYREF

  _RBP = (unsigned __int64)v36 & 0xFFFFFFFFFFFFFFE0uLL;
  _RBX = a2;
  _RDI = Src;
  sub_18000E450(a3, a4);
  __asm
  {
    vmovdqu ymm2, ymm0
    vmovdqu [rbp+60h+var_40], ymm0
  }
  if ( _RBX < 8 )
  {
LABEL_5:
    if ( !(_DWORD)_RBX )
      goto LABEL_9;
    __asm { vzeroupper }
    memcpy((void *)((unsigned __int64)v36 & 0xFFFFFFFFFFFFFFE0uLL), _RDI, 2LL * (unsigned int)_RBX);
    __asm
    {
      vpmovzxwd ymm5, [rbp+60h+var_60]
      vmovdqu ymm0, cs:ymmword_180013BA0
      vpand   ymm1, ymm0, ymm5
      vpandn  ymm0, ymm5, cs:ymmword_180013B80
      vpxor   xmm2, xmm2, xmm2
      vpcmpeqd ymm4, ymm1, ymm2
      vpsrld  ymm2, ymm5, 5
      vpermd  ymm3, ymm2, [rbp+60h+var_40]
      vpsllvd ymm1, ymm3, ymm0
    }
    __asm
    {
      vpand   ymm2, ymm1, ymm4
      vmovmskps edx, ymm2
    }
    v34 = ((1 << _RBX) - 1) & _EDX;
    if ( v34 )
      result = 31 - __lzcnt(v34);
    else
LABEL_9:
      result = -1;
    __asm { vzeroupper }
  }
  else
  {
    __asm
    {
      vmovdqu ymm5, cs:ymmword_180013BA0
      vmovdqu ymm6, cs:ymmword_180013B80
    }
    while ( 1 )
    {
      __asm
      {
        vpmovzxwd ymm4, xmmword ptr [rdi+rbx*2-10h]
        vpxor   xmm1, xmm1, xmm1
      }
      _RBX -= 8LL;
      __asm
      {
        vpand   ymm0, ymm4, ymm5
        vpcmpeqd ymm3, ymm0, ymm1
        vpsrld  ymm1, ymm4, 5
        vpermd  ymm2, ymm1, ymm2
        vpandn  ymm0, ymm4, ymm6
        vpsllvd ymm2, ymm2, ymm0
        vpand   ymm1, ymm2, ymm3
        vmovmskps eax, ymm1
      }
      if ( _EAX )
        break;
      __asm { vmovdqu ymm2, [rbp+60h+var_40] }
      if ( _RBX < 8 )
        goto LABEL_5;
    }
    __asm { vzeroupper }
    return _RBX - __lzcnt(_EAX) + 31;
  }
  return result;
}
// 18000E3B1: masking with 0x7 was optimized away because ebx.4 <= 0x7

//----- (000000018000E450) ----------------------------------------------------
int __fastcall sub_18000E450(unsigned __int16 *a1, unsigned __int64 a2)
{
  unsigned __int16 *v5; // rdi
  unsigned __int16 *v6; // rbx
  unsigned __int16 v8; // dx
  unsigned int v9; // ecx
  int result; // eax
  __int64 v17; // rax
  __m256 v42; // [rsp+40h] [rbp+0h] BYREF

  _RBP = (unsigned __int64)&v42 & 0xFFFFFFFFFFFFFFE0uLL;
  v5 = &a1[a2];
  v6 = a1;
  if ( a2 > 0x14 )
  {
    memset((void *)((unsigned __int64)&v42 & 0xFFFFFFFFFFFFFFE0uLL), 0, 0x100u);
    for ( ; v6 != v5; *(_BYTE *)(_RBP + v17) = -1 )
      v17 = *v6++;
    __asm
    {
      vmovdqu ymm1, [rbp+110h+var_50]
      vmovdqu ymm0, [rbp+110h+var_30]
      vpmovmskb ebx, ymm0
      vmovdqu ymm0, [rbp+110h+var_70]
      vpmovmskb r10d, ymm0
      vmovdqu ymm0, [rbp+110h+var_B0]
      vpmovmskb r8d, ymm0
      vmovdqu ymm0, [rbp+110h+var_F0]
      vpmovmskb ecx, ymm0
      vpmovmskb r11d, ymm1
      vmovdqu ymm1, [rbp+110h+var_90]
      vpmovmskb r9d, ymm1
      vmovdqu ymm1, [rbp+110h+var_D0]
      vpmovmskb edx, ymm1
      vmovdqu ymm1, [rbp+110h+var_110]
      vmovd   xmm0, r9d
      vpinsrd xmm0, xmm0, r10d, 1
      vpinsrd xmm0, xmm0, r11d, 2
      vpmovmskb eax, ymm1
      vmovd   xmm2, eax
      vpinsrd xmm2, xmm2, ecx, 1
      vpinsrd xmm2, xmm2, edx, 2
      vpinsrd xmm2, xmm2, r8d, 3
      vpinsrd xmm0, xmm0, ebx, 3
      vinsertf128 ymm0, ymm2, xmm0, 1
    }
  }
  else
  {
    __asm { vpxor   xmm0, xmm0, xmm0 }
    if ( a1 != v5 )
    {
      do
      {
        v8 = *v6;
        v9 = *v6++;
        _EDX = v8 & 0x3F;
        result = 1 << ((v9 >> 3) & 0x18);
        __asm
        {
          vmovd   xmm1, eax
          vpmovzxbq ymm2, xmm1
          vmovd   xmm1, edx
          vpsllq  ymm2, ymm2, xmm1
          vpor    ymm0, ymm2, ymm0
        }
      }
      while ( v6 != v5 );
    }
  }
  return result;
}

//----- (000000018000E5B0) ----------------------------------------------------
const __m128i *__fastcall sub_18000E5B0(const __m128i *a1, const __m128i *a2, const __m128i *a3, size_t a4)
{
  const __m128i *v7; // rbx
  unsigned __int64 v9; // rcx
  __m128i v10; // xmm6
  __m128i v11; // xmm0
  int v12; // ecx
  unsigned int v13; // esi
  __m128i v14; // xmm0
  int v15; // ecx
  __m128 v16; // xmm6
  const __m128i *v17; // rbp
  const __m128i *v18; // rsi
  __m128i v19; // xmm0
  int v20; // ecx
  __m128i v21; // xmm1
  const __m128i *v22; // rdx
  __int8 v23; // r8
  __int64 v24; // rcx
  __m128i v25; // [rsp+20h] [rbp-58h] BYREF

  v7 = a1;
  if ( !a4 )
    return a1;
  if ( a4 == 1 )
    return sub_18000DFE0(a1, a2, a3->m128i_i8[0]);
  v9 = (char *)a2 - (char *)a1;
  if ( (char *)a2 - (char *)v7 >= a4 )
  {
    if ( (dword_18001700C & 4) != 0 && v9 >= 0x10 )
    {
      if ( a4 > 0x10 )
      {
        v16 = (__m128)_mm_loadu_si128(a3);
        v17 = a3 + 1;
        v18 = (const __m128i *)((char *)a2 - a4);
        while ( 1 )
        {
          v19 = _mm_loadu_si128(v7);
          v20 = _mm_cmpestri((__m128i)v16, v19, 0x10u, 0x10u);
          if ( _mm_cmpestrc((__m128i)v16, v19, 0x10u, 0x10u) )
          {
            if ( !v20 )
              goto LABEL_23;
            v7 = (const __m128i *)((char *)v7 + v20);
            if ( v7 > v18 )
              return a2;
            v21 = (__m128i)_mm_xor_ps(v16, (__m128)_mm_loadu_si128(v7));
            if ( _mm_testz_si128(v21, v21) )
            {
LABEL_23:
              if ( !memcmp(&v7[1], v17, a4 - 16) )
                return v7;
            }
            v7 = (const __m128i *)((char *)v7 + 1);
          }
          else
          {
            ++v7;
          }
          if ( v7 > v18 )
            return a2;
        }
      }
      memcpy(&v25, a3, a4);
      v10 = _mm_load_si128(&v25);
      do
      {
        v11 = _mm_loadu_si128(v7);
        v12 = _mm_cmpestri(v10, v11, a4, 0x10u);
        if ( _mm_cmpestrc(v10, v11, a4, 0x10u) )
        {
          v7 = (const __m128i *)((char *)v7 + v12);
          if ( v12 <= 16 - (int)a4 )
            return v7;
        }
        else
        {
          ++v7;
        }
      }
      while ( v7 <= &a2[-1] );
      v13 = (_DWORD)a2 - (_DWORD)v7;
      if ( a2 != v7 )
      {
        memcpy(&v25, v7, (char *)a2 - (char *)v7);
        v14 = _mm_load_si128(&v25);
        v15 = _mm_cmpestri(v10, v14, a4, v13);
        if ( _mm_cmpestrc(v10, v14, a4, v13) )
          return (const __m128i *)((char *)v7 + v15);
      }
    }
    else
    {
      v22 = (const __m128i *)((char *)a2 + 1 - a4);
      if ( v7 != v22 )
      {
        v23 = a3->m128i_i8[0];
        do
        {
          if ( v7->m128i_i8[0] == v23 )
          {
            v24 = 1;
            while ( v7->m128i_i8[v24] == a3->m128i_i8[v24] )
            {
              if ( ++v24 == a4 )
                return v7;
            }
          }
          v7 = (const __m128i *)((char *)v7 + 1);
        }
        while ( v7 != v22 );
      }
    }
  }
  return a2;
}
// 18001700C: using guessed type int dword_18001700C;

//----- (000000018000E7C0) ----------------------------------------------------
void __noreturn sub_18000E7C0()
{
  abort();
}

//----- (000000018000E800) ----------------------------------------------------
void *__fastcall sub_18000E800(size_t Size)
{
  size_t i; // rbx
  void *result; // rax

  for ( i = Size; ; Size = i )
  {
    result = malloc(Size);
    if ( result )
      break;
    if ( !callnewh(i) )
    {
      if ( i != -1 )
        Concurrency::cancel_current_task();
      Concurrency::cancel_current_task();
    }
  }
  return result;
}

//----- (000000018000E83C) ----------------------------------------------------
__int64 __fastcall sub_18000E83C(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  __int64 v5; // rdi
  __int64 result; // rax

  v3 = a3;
  v5 = a1 + a3 * a2;
  while ( 1 )
  {
    result = v3--;
    if ( !result )
      break;
    v5 -= a2;
    _guard_dispatch_icall_fptr();
  }
  return result;
}
// 18000F760: using guessed type __int64 __fastcall guard_dispatch_icall_nop();
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000E8A8) ----------------------------------------------------
__int64 __fastcall sub_18000E8A8(__int64 a1, __int64 a2, __int64 a3, __int64 (__fastcall *a4)(__int64))
{
  __int64 i; // rbx
  __int64 result; // rax

  for ( i = 0; i != a3; ++i )
  {
    a1 -= a2;
    result = a4(a1);
  }
  return result;
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000E904) ----------------------------------------------------
char sub_18000E904()
{
  int v0; // eax
  PVOID StackBase; // rcx
  signed __int64 v2; // rax

  LOBYTE(v0) = __uncaught_exception();
  if ( v0 )
  {
    StackBase = NtCurrentTeb()->NtTib.StackBase;
    while ( 1 )
    {
      v2 = _InterlockedCompareExchange64(&qword_180017408, (signed __int64)StackBase, 0);
      if ( !v2 )
        break;
      if ( StackBase == (PVOID)v2 )
        return 1;
    }
  }
  return 0;
}
// 18000E90F: variable 'v0' is possibly undefined
// 180017408: using guessed type __int64 qword_180017408;

//----- (000000018000E940) ----------------------------------------------------
char sub_18000E940()
{
  int v0; // eax
  _crt_argv_mode v1; // eax

  LOBYTE(v0) = __uncaught_exception();
  if ( v0 )
  {
    sub_18000F0A4();
  }
  else
  {
    v1 = (unsigned int)sub_18000F394();
    if ( configure_narrow_argv(v1) )
      return 0;
    initialize_narrow_environment();
  }
  return 1;
}
// 18000E94B: variable 'v0' is possibly undefined

//----- (000000018000E974) ----------------------------------------------------
bool sub_18000E974()
{
  return sub_18000EAAC(0) != 0;
}

//----- (000000018000E98C) ----------------------------------------------------
char sub_18000E98C()
{
  if ( !sub_18000F5D0() )
    return 0;
  if ( !sub_18000F5D0() )
  {
    sub_18000F5D0();
    return 0;
  }
  return 1;
}

//----- (000000018000E9B4) ----------------------------------------------------
char sub_18000E9B4()
{
  sub_18000F5D0();
  sub_18000F5D0();
  return 1;
}

//----- (000000018000E9CC) ----------------------------------------------------
int __fastcall sub_18000E9CC(
        __int64 a1,
        int a2,
        __int64 a3,
        void (__fastcall *a4)(__int64, _QWORD, __int64),
        unsigned int ExceptionNum,
        struct _EXCEPTION_POINTERS *ExceptionPtr)
{
  int v10; // eax

  LOBYTE(v10) = __uncaught_exception();
  if ( !v10 && a2 == 1 )
    a4(a1, 0, a3);
  return seh_filter_dll(ExceptionNum, ExceptionPtr);
}
// 18000E9F2: variable 'v10' is possibly undefined
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018000EA2C) ----------------------------------------------------
void sub_18000EA2C()
{
  int v0; // eax

  LOBYTE(v0) = __uncaught_exception();
  if ( v0 )
  {
    execute_onexit_table(&Table);
  }
  else if ( !(unsigned int)sub_180003F20() )
  {
    cexit();
  }
}
// 18000EA37: variable 'v0' is possibly undefined

//----- (000000018000EA5C) ----------------------------------------------------
char sub_18000EA5C()
{
  sub_18000F5D0();
  return sub_18000F5D0();
}

//----- (000000018000EA70) ----------------------------------------------------
char __fastcall sub_18000EA70(int a1)
{
  if ( !a1 )
    byte_180017410 = 1;
  sub_18000F0A4();
  if ( !sub_18000F5D0() )
    return 0;
  if ( !sub_18000F5D0() )
  {
    sub_18000F5D0();
    return 0;
  }
  return 1;
}
// 180017410: using guessed type char byte_180017410;

//----- (000000018000EAAC) ----------------------------------------------------
char __fastcall sub_18000EAAC(unsigned int a1)
{
  int v2; // eax

  if ( !byte_180017411 )
  {
    if ( a1 > 1 )
      RtlFailFast(5);
    LOBYTE(v2) = __uncaught_exception();
    if ( !v2 || a1 )
    {
      *(__m128i *)&Table._first = _mm_load_si128((const __m128i *)&xmmword_180013B60);
      Table._end = (_PVFV *)-1LL;
      *(_OWORD *)&stru_180017430._first = *(_OWORD *)&Table._first;
      stru_180017430._end = (_PVFV *)-1LL;
    }
    else if ( initialize_onexit_table(&Table) || initialize_onexit_table(&stru_180017430) )
    {
      return 0;
    }
    byte_180017411 = 1;
  }
  return 1;
}
// 18000EAC9: variable 'v2' is possibly undefined
// 18000F3A8: using guessed type void __fastcall __noreturn RtlFailFast(_QWORD);
// 180013B60: using guessed type __int128 xmmword_180013B60;
// 180017411: using guessed type char byte_180017411;

//----- (000000018000EB38) ----------------------------------------------------
bool __fastcall sub_18000EB38(__int64 a1)
{
  _DWORD *v2; // rcx
  unsigned __int64 v3; // r8
  _DWORD *v4; // rdx
  _DWORD *v5; // r9
  unsigned __int64 v6; // rcx

  if ( MEMORY[0x180000000] != 23117 )
    return 0;
  v2 = (_DWORD *)(0x180000000LL + MEMORY[0x18000003C]);
  if ( *v2 != 17744 || *(_WORD *)(0x180000018LL + MEMORY[0x18000003C]) != 523 )
    return 0;
  v3 = a1 - 0x180000000LL;
  v4 = (_DWORD *)((char *)v2 + *(unsigned __int16 *)(0x180000014LL + MEMORY[0x18000003C]) + 24);
  v5 = &v4[10 * *(unsigned __int16 *)(0x180000006LL + MEMORY[0x18000003C])];
  while ( v4 != v5 )
  {
    v6 = (unsigned int)v4[3];
    if ( v3 >= v6 && v3 < (unsigned int)(v6 + v4[2]) )
      return v4 && v4[9] >= 0;
    v4 += 10;
  }
  v4 = 0;
  return v4 && v4[9] >= 0;
}

//----- (000000018000EBD0) ----------------------------------------------------
char __fastcall sub_18000EBD0(char a1)
{
  int v2; // eax

  LOBYTE(v2) = __uncaught_exception();
  if ( v2 && !a1 )
    _InterlockedExchange64(&qword_180017408, 0);
  return v2;
}
// 18000EBE1: variable 'v2' is possibly undefined
// 180017408: using guessed type __int64 qword_180017408;

//----- (000000018000EBF4) ----------------------------------------------------
char __fastcall sub_18000EBF4(__int64 a1, char a2)
{
  if ( !byte_180017410 || !a2 )
  {
    sub_18000F5D0();
    sub_18000F5D0();
  }
  return 1;
}
// 180017410: using guessed type char byte_180017410;

//----- (000000018000EC20) ----------------------------------------------------
void (__cdecl *__fastcall sub_18000EC20(void (__cdecl *Function)()))()
{
  int v2; // eax
  __int64 v3; // rdx

  if ( Table._first == (_PVFV *)-1LL )
    v2 = crt_atexit(Function);
  else
    v2 = register_onexit_function(&Table, (_onexit_t)Function);
  v3 = 0;
  if ( !v2 )
    return Function;
  return (void (__cdecl *)())v3;
}

//----- (000000018000EC80) ----------------------------------------------------
_QWORD *__fastcall sub_18000EC80(_QWORD *a1, char a2)
{
  *a1 = &type_info::`vftable';
  if ( (a2 & 1) != 0 )
    j_j_free(a1);
  return a1;
}
// 180013BC8: using guessed type void *type_info::`vftable';

//----- (000000018000ECC0) ----------------------------------------------------
__int64 __fastcall sub_18000ECC0(__int64 a1, int a2, __int64 a3)
{
  int v3; // edx
  int v4; // edx
  __int64 result; // rax

  if ( !a2 )
    return sub_18000EE28(a3 != 0);
  v3 = a2 - 1;
  if ( !v3 )
    return sub_18000ED10();
  v4 = v3 - 1;
  if ( v4 )
  {
    if ( v4 != 1 )
      return 1;
    LOBYTE(result) = sub_18000E9B4();
  }
  else
  {
    LOBYTE(result) = sub_18000E98C();
  }
  return (unsigned __int8)result;
}

//----- (000000018000ED10) ----------------------------------------------------
__int64 sub_18000ED10()
{
  char v0; // bl
  char v1; // di
  _QWORD *v2; // rax

  if ( !sub_18000EA70(0) )
    return 0;
  v0 = sub_18000E904();
  v1 = 1;
  if ( dword_180017400 )
    RtlFailFast(7);
  dword_180017400 = 1;
  if ( sub_18000E974() )
  {
    sub_18000F4B0();
    sub_18000F468();
    sub_18000F48C();
    if ( !initterm_e((_PIFV *)&First, (_PIFV *)&Last) )
    {
      if ( sub_18000E940() )
      {
        initterm((_PVFV *)&qword_1800113F8, (_PVFV *)&qword_180011438);
        dword_180017400 = 2;
        v1 = 0;
      }
    }
  }
  sub_18000EBD0(v0);
  if ( v1 )
    return 0;
  v2 = sub_18000F4A8();
  if ( *v2 )
  {
    if ( sub_18000EB38((__int64)v2) )
      _guard_dispatch_icall_fptr();
  }
  ++dword_180017448;
  return 1;
}
// 18000F3A8: using guessed type void __fastcall __noreturn RtlFailFast(_QWORD);
// 18000F760: using guessed type __int64 __fastcall guard_dispatch_icall_nop();
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 180017400: using guessed type int dword_180017400;
// 180017448: using guessed type int dword_180017448;

//----- (000000018000EE28) ----------------------------------------------------
__int64 __fastcall sub_18000EE28(char a1)
{
  char v3; // bl
  __int64 v4; // rcx
  unsigned int v5; // ebx

  if ( dword_180017448 <= 0 )
    return 0;
  --dword_180017448;
  v3 = sub_18000E904();
  if ( dword_180017400 != 2 )
    RtlFailFast(7);
  sub_18000EA2C();
  sub_18000F478();
  sub_18000F4EC();
  dword_180017400 = 0;
  sub_18000EBD0(v3);
  LOBYTE(v4) = a1;
  v5 = (unsigned __int8)sub_18000EBF4(v4, 0);
  sub_18000EA5C();
  return v5;
}
// 18000EE8D: variable 'v4' is possibly undefined
// 18000F3A8: using guessed type void __fastcall __noreturn RtlFailFast(_QWORD);
// 180017400: using guessed type int dword_180017400;
// 180017448: using guessed type int dword_180017448;

//----- (000000018000EEAC) ----------------------------------------------------
__int64 __fastcall sub_18000EEAC(HMODULE hModule, int a2, __int64 a3)
{
  double v3; // xmm2_8
  unsigned int v8; // ebx
  unsigned int v9; // eax

  if ( !a2 && dword_180017448 <= 0 )
    return 0;
  if ( (unsigned int)(a2 - 1) > 1 || (v8 = sub_18000ECC0((__int64)hModule, a2, a3)) != 0 )
  {
    v9 = sub_180003990(hModule, a2, v3);
    v8 = v9;
    if ( a2 == 1 && !v9 )
    {
      sub_180003990(hModule, 0, v3);
      sub_18000EE28(a3 != 0);
    }
    if ( !a2 || a2 == 3 )
      return (unsigned int)sub_18000ECC0((__int64)hModule, a2, a3) != 0;
  }
  return v8;
}
// 18000EF08: conditional instruction was optimized away because ebx.4==1
// 18000EF31: variable 'v3' is possibly undefined
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 180017448: using guessed type int dword_180017448;

//----- (000000018000F040) ----------------------------------------------------
__int64 __fastcall sub_18000F040(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  __int64 v4; // rax

  v3 = *(unsigned int *)(*(_QWORD *)(a2 + 16) + 8LL);
  v4 = *(_QWORD *)(a2 + 8);
  if ( (*(_BYTE *)(v3 + v4 + 3) & 0xF) != 0 )
    return a1 + (*(_BYTE *)(v3 + v4 + 3) & 0xF0);
  else
    return a1;
}

//----- (000000018000F0A4) ----------------------------------------------------
__int64 sub_18000F0A4()
{
  int v5; // ebp
  bool v7; // zf
  int v12; // edi
  int v13; // eax
  unsigned __int64 v14; // rax
  __int64 v15; // rcx
  int v16; // r8d
  int v17; // r9d
  unsigned int v18; // r11d
  int v24; // esi
  int v25; // r10d
  unsigned __int64 v36; // rax
  int v37; // eax
  unsigned __int64 v38; // rax
  __int64 v39; // rdx
  int v41; // [rsp+20h] [rbp+8h]

  _RAX = 0;
  __asm { cpuid }
  v5 = _RAX;
  _RAX = 1;
  v7 = ((unsigned int)_RBX ^ 0x756E6547 | (unsigned int)_RCX ^ 0x6C65746E | (unsigned int)_RDX ^ 0x49656E69) == 0;
  __asm { cpuid }
  v12 = _RCX;
  if ( v7
    && ((v13 = _RAX & 0xFFF3FF0, qword_180017010 = 0x8000, qword_180017018 = -1, v13 == 67264)
     || v13 == 132704
     || v13 == 132720
     || (v14 = (unsigned int)(v13 - 198224), (unsigned int)v14 <= 0x20) && (v15 = 0x100010001LL, _bittest64(&v15, v14))) )
  {
    v16 = dword_18001744C | 1;
    dword_18001744C |= 1u;
  }
  else
  {
    v16 = dword_18001744C;
  }
  v17 = 0;
  v18 = 0;
  if ( v5 < 7 )
  {
    v25 = 0;
    v24 = 0;
  }
  else
  {
    _RAX = 7;
    __asm { cpuid }
    v24 = _RDX;
    v25 = _RBX;
    if ( (_RBX & 0x200) != 0 )
      dword_18001744C = v16 | 2;
    if ( (int)_RAX >= 1 )
    {
      _RAX = 7;
      __asm { cpuid }
      v17 = _RDX;
    }
    _RAX = 36;
    if ( v5 >= 36 )
    {
      __asm { cpuid }
      v18 = _RBX;
    }
  }
  v36 = qword_180017020 & 0xFFFFFFFFFFFFFFFEuLL;
  dword_180017008 = 1;
  dword_18001700C = 2;
  qword_180017020 &= ~1uLL;
  if ( (v12 & 0x100000) != 0 )
  {
    v36 &= ~0x10uLL;
    dword_180017008 = 2;
    qword_180017020 = v36;
    dword_18001700C = 6;
  }
  if ( (v12 & 0x8000000) != 0 )
  {
    __asm { xgetbv }
    v41 = v36;
    if ( (v12 & 0x10000000) == 0 || (v36 & 6) != 6 )
    {
LABEL_33:
      if ( (v17 & 0x200000) != 0 && (*(_QWORD *)&v41 & 0x80000LL) != 0 )
        qword_180017020 &= ~0x80uLL;
      return 0;
    }
    v37 = dword_18001700C | 8;
    dword_180017008 = 3;
    dword_18001700C |= 8u;
    if ( (v25 & 0x20) != 0 )
    {
      dword_180017008 = 5;
      dword_18001700C = v37 | 0x20;
      v38 = qword_180017020 & 0xFFFFFFFFFFFFFFFDuLL;
      qword_180017020 &= ~2uLL;
      if ( (v25 & 0xD0030000) != 0xD0030000 )
      {
LABEL_27:
        if ( (v24 & 0x800000) != 0 )
          qword_180017020 = v38 & 0xFFFFFFFFFEFFFFFFuLL;
        if ( (v17 & 0x80000) != 0 && (v41 & 0xE0) == 0xE0 )
        {
          dword_180017450 = v18 & 0x400FF;
          v39 = ~(HIWORD(v18) & 6 | 0x1000029LL) & qword_180017020;
          qword_180017020 = v39;
          if ( (unsigned __int8)v18 > 1u )
            qword_180017020 = v39 & 0xFFFFFFFFFFFFFFBFuLL;
        }
        goto LABEL_33;
      }
      if ( (v41 & 0xE0) == 0xE0 )
      {
        dword_18001700C |= 0x40u;
        v38 = qword_180017020 & 0xFFFFFFFFFFFFFFDBuLL;
        dword_180017008 = 6;
        qword_180017020 &= 0xFFFFFFFFFFFFFFDBuLL;
        goto LABEL_27;
      }
    }
    v38 = qword_180017020;
    goto LABEL_27;
  }
  return 0;
}
// 180017008: using guessed type int dword_180017008;
// 18001700C: using guessed type int dword_18001700C;
// 180017010: using guessed type __int64 qword_180017010;
// 180017018: using guessed type __int64 qword_180017018;
// 180017020: using guessed type __int64 qword_180017020;
// 18001744C: using guessed type int dword_18001744C;
// 180017450: using guessed type int dword_180017450;

//----- (000000018000F340) ----------------------------------------------------
_QWORD *__fastcall sub_18000F340(_QWORD *a1)
{
  a1[2] = 0;
  a1[1] = "bad allocation";
  *a1 = &std::bad_alloc::`vftable';
  return a1;
}
// 180013BF8: using guessed type void *std::bad_alloc::`vftable';

//----- (000000018000F394) ----------------------------------------------------
__int64 sub_18000F394()
{
  return 1;
}

//----- (000000018000F3B8) ----------------------------------------------------
__int64 sub_18000F3B8()
{
  uintptr_t v0; // rax
  __int64 result; // rax
  struct _FILETIME v2; // [rsp+20h] [rbp-10h] BYREF
  struct _FILETIME SystemTimeAsFileTime; // [rsp+40h] [rbp+10h] BYREF
  LARGE_INTEGER PerformanceCount; // [rsp+48h] [rbp+18h] BYREF

  v0 = _security_cookie;
  if ( _security_cookie == 0x2B992DDFA232LL )
  {
    SystemTimeAsFileTime = 0;
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v2 = SystemTimeAsFileTime;
    v2 = (struct _FILETIME)(GetCurrentThreadId() ^ *(unsigned __int64 *)&v2);
    v2 = (struct _FILETIME)(GetCurrentProcessId() ^ *(unsigned __int64 *)&v2);
    QueryPerformanceCounter(&PerformanceCount);
    v0 = ((unsigned __int64)&v2
        ^ *(_QWORD *)&v2
        ^ PerformanceCount.QuadPart
        ^ ((unsigned __int64)PerformanceCount.LowPart << 32))
       & 0xFFFFFFFFFFFFLL;
    if ( v0 == 0x2B992DDFA232LL )
      v0 = 0x2B992DDFA233LL;
    _security_cookie = v0;
  }
  result = ~v0;
  qword_180017080 = result;
  return result;
}
// 180017080: using guessed type __int64 qword_180017080;

//----- (000000018000F468) ----------------------------------------------------
void sub_18000F468()
{
  InitializeSListHead(&stru_180017460);
}
// 180017460: using guessed type union _SLIST_HEADER stru_180017460;

//----- (000000018000F478) ----------------------------------------------------
__int64 sub_18000F478()
{
  return _std_type_info_destroy_list(&stru_180017460);
}
// 18000F574: using guessed type __int64 __fastcall _std_type_info_destroy_list(_QWORD);
// 180017460: using guessed type union _SLIST_HEADER stru_180017460;

//----- (000000018000F484) ----------------------------------------------------
void *sub_18000F484()
{
  return &unk_180017470;
}

//----- (000000018000F48C) ----------------------------------------------------
_QWORD *sub_18000F48C()
{
  _QWORD *v0; // rax
  _QWORD *result; // rax

  v0 = sub_180003F10();
  *v0 |= 0x24uLL;
  result = sub_18000F484();
  *result |= 2uLL;
  return result;
}

//----- (000000018000F4A8) ----------------------------------------------------
void *sub_18000F4A8()
{
  return &unk_180017708;
}

//----- (000000018000F4B0) ----------------------------------------------------
void sub_18000F4B0()
{
  void (**i)(void); // rbx

  for ( i = qword_180014970; i < qword_180014970; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 180014970: using guessed type void (*qword_180014970[2])(void);

//----- (000000018000F4EC) ----------------------------------------------------
void sub_18000F4EC()
{
  void (**i)(void); // rbx

  for ( i = &qword_180014980; i < &qword_180014980; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 1800113D0: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 180014980: using guessed type void (*qword_180014980)(void);

//----- (000000018000F5D0) ----------------------------------------------------
char sub_18000F5D0()
{
  return 1;
}

//----- (000000018000F7C6) ----------------------------------------------------
__int64 __fastcall sub_18000F7C6(__int64 a1, __int64 a2)
{
  return sub_180002F50(a2 + 112);
}
// 180002F50: using guessed type __int64 __fastcall sub_180002F50(_QWORD);

//----- (000000018000F7D2) ----------------------------------------------------
__int64 __fastcall sub_18000F7D2(__int64 a1, __int64 a2)
{
  return sub_180003110(a2 + 32);
}
// 180003110: using guessed type __int64 __fastcall sub_180003110(_QWORD);

//----- (000000018000F7FC) ----------------------------------------------------
__int64 __fastcall sub_18000F7FC(__int64 a1, __int64 a2)
{
  return sub_1800027F0(a2 + 64);
}
// 1800027F0: using guessed type __int64 __fastcall sub_1800027F0(_QWORD);

//----- (000000018000F808) ----------------------------------------------------
__int64 __fastcall sub_18000F808(__int64 a1, __int64 a2)
{
  return sub_1800027F0(a2 + 96);
}
// 1800027F0: using guessed type __int64 __fastcall sub_1800027F0(_QWORD);

//----- (000000018000F820) ----------------------------------------------------
__int64 __fastcall sub_18000F820(__int64 a1, __int64 a2)
{
  return sub_180002780(a2 + 96);
}
// 180002780: using guessed type __int64 __fastcall sub_180002780(_QWORD);

//----- (000000018000F82C) ----------------------------------------------------
__int64 __fastcall sub_18000F82C(__int64 a1, __int64 a2)
{
  return sub_1800027F0(a2 + 32);
}
// 1800027F0: using guessed type __int64 __fastcall sub_1800027F0(_QWORD);

//----- (000000018000F838) ----------------------------------------------------
__int64 __fastcall sub_18000F838(__int64 a1, __int64 a2)
{
  return sub_1800027F0(a2 + 64);
}
// 1800027F0: using guessed type __int64 __fastcall sub_1800027F0(_QWORD);

//----- (000000018000F850) ----------------------------------------------------
__int64 __fastcall sub_18000F850(__int64 a1, __int64 a2)
{
  return sub_1800027F0(a2 + 32);
}
// 1800027F0: using guessed type __int64 __fastcall sub_1800027F0(_QWORD);

//----- (000000018000F85C) ----------------------------------------------------
__int64 __fastcall sub_18000F85C(__int64 a1, __int64 a2)
{
  return sub_1800027F0(a2 + 64);
}
// 1800027F0: using guessed type __int64 __fastcall sub_1800027F0(_QWORD);

//----- (000000018000F870) ----------------------------------------------------
__int64 __fastcall sub_18000F870(__int64 a1, __int64 a2)
{
  return sub_180003120(a2 + 40);
}
// 180003120: using guessed type __int64 __fastcall sub_180003120(_QWORD);

//----- (000000018000F8C0) ----------------------------------------------------
__int64 __fastcall sub_18000F8C0(__int64 a1, __int64 a2)
{
  return sub_180003260(a2 + 80);
}
// 180003260: using guessed type __int64 __fastcall sub_180003260(_QWORD);

//----- (000000018000F8CC) ----------------------------------------------------
__int64 __fastcall sub_18000F8CC(__int64 a1, __int64 a2)
{
  return sub_180003260(a2 + 80);
}
// 180003260: using guessed type __int64 __fastcall sub_180003260(_QWORD);

//----- (000000018000F906) ----------------------------------------------------
__int64 __fastcall sub_18000F906(__int64 a1, __int64 a2)
{
  return sub_1800027F0(a2 + 48);
}
// 1800027F0: using guessed type __int64 __fastcall sub_1800027F0(_QWORD);

//----- (000000018000F946) ----------------------------------------------------
__int64 __fastcall sub_18000F946(__int64 a1, __int64 a2)
{
  return sub_1800027F0(a2 + 56);
}
// 1800027F0: using guessed type __int64 __fastcall sub_1800027F0(_QWORD);

//----- (000000018000F990) ----------------------------------------------------
__int64 __fastcall sub_18000F990(__int64 a1, __int64 a2)
{
  return sub_180006340(a2 + 80);
}
// 180006340: using guessed type __int64 __fastcall sub_180006340(_QWORD);

//----- (000000018000F99C) ----------------------------------------------------
__int64 __fastcall sub_18000F99C(__int64 a1, __int64 a2)
{
  return sub_180006340(a2 + 56);
}
// 180006340: using guessed type __int64 __fastcall sub_180006340(_QWORD);

//----- (000000018000F9A8) ----------------------------------------------------
__int64 __fastcall sub_18000F9A8(__int64 a1, __int64 a2)
{
  return sub_180006340(a2 + 104);
}
// 180006340: using guessed type __int64 __fastcall sub_180006340(_QWORD);

//----- (000000018000F9F0) ----------------------------------------------------
__int64 __fastcall sub_18000F9F0(__int64 a1, __int64 a2)
{
  return sub_180003C30(a2 + 144);
}
// 180003C30: using guessed type __int64 __fastcall sub_180003C30(_QWORD);

//----- (000000018000F9FC) ----------------------------------------------------
__int64 __fastcall sub_18000F9FC(__int64 a1, __int64 a2)
{
  return sub_1800062E0(a2 + 272);
}
// 1800062E0: using guessed type __int64 __fastcall sub_1800062E0(_QWORD);

//----- (000000018000FA08) ----------------------------------------------------
__int64 __fastcall sub_18000FA08(__int64 a1, __int64 a2)
{
  return sub_1800062E0(a2 + 64);
}
// 1800062E0: using guessed type __int64 __fastcall sub_1800062E0(_QWORD);

//----- (000000018000FA24) ----------------------------------------------------
__int64 __fastcall sub_18000FA24(__int64 a1, __int64 a2)
{
  return sub_1800060C0(a2 + 64);
}
// 1800060C0: using guessed type __int64 __fastcall sub_1800060C0(_QWORD);

//----- (000000018000FA50) ----------------------------------------------------
__int64 __fastcall sub_18000FA50(__int64 a1, __int64 a2)
{
  return sub_1800062E0(*(_QWORD *)(a2 + 184));
}
// 1800062E0: using guessed type __int64 __fastcall sub_1800062E0(_QWORD);

//----- (000000018000FA6C) ----------------------------------------------------
__int64 __fastcall sub_18000FA6C(__int64 a1, __int64 a2)
{
  return sub_1800072F0(a2 + 144);
}
// 1800072F0: using guessed type __int64 __fastcall sub_1800072F0(_QWORD);

//----- (000000018000FA78) ----------------------------------------------------
__int64 __fastcall sub_18000FA78(__int64 a1, __int64 a2)
{
  return sub_180003F30(a2 + 224);
}
// 180003F30: using guessed type __int64 __fastcall sub_180003F30(_QWORD);

//----- (000000018000FA84) ----------------------------------------------------
__int64 __fastcall sub_18000FA84(__int64 a1, __int64 a2)
{
  return sub_1800062E0(a2 + 64);
}
// 1800062E0: using guessed type __int64 __fastcall sub_1800062E0(_QWORD);

//----- (000000018000FAA0) ----------------------------------------------------
__int64 __fastcall sub_18000FAA0(__int64 a1, __int64 a2)
{
  return sub_1800060C0(a2 + 64);
}
// 1800060C0: using guessed type __int64 __fastcall sub_1800060C0(_QWORD);

//----- (000000018000FACC) ----------------------------------------------------
__int64 __fastcall sub_18000FACC(__int64 a1, __int64 a2)
{
  return sub_1800062E0(*(_QWORD *)(a2 + 184));
}
// 1800062E0: using guessed type __int64 __fastcall sub_1800062E0(_QWORD);

//----- (000000018000FAE8) ----------------------------------------------------
__int64 __fastcall sub_18000FAE8(__int64 a1, __int64 a2)
{
  return sub_1800072F0(a2 + 144);
}
// 1800072F0: using guessed type __int64 __fastcall sub_1800072F0(_QWORD);

//----- (000000018000FAF4) ----------------------------------------------------
__int64 __fastcall sub_18000FAF4(__int64 a1, __int64 a2)
{
  return sub_180003F30(a2 + 208);
}
// 180003F30: using guessed type __int64 __fastcall sub_180003F30(_QWORD);

//----- (000000018000FB24) ----------------------------------------------------
__int64 __fastcall sub_18000FB24(__int64 a1, __int64 a2)
{
  return sub_180002770(a2 + 240);
}
// 180002770: using guessed type __int64 __fastcall sub_180002770(_QWORD);

//----- (000000018000FB30) ----------------------------------------------------
__int64 __fastcall sub_18000FB30(__int64 a1, __int64 a2)
{
  return sub_180002770(a2 + 32);
}
// 180002770: using guessed type __int64 __fastcall sub_180002770(_QWORD);

//----- (000000018000FB70) ----------------------------------------------------
__int64 __fastcall sub_18000FB70(__int64 a1, __int64 a2)
{
  return sub_180004690(a2 + 144);
}
// 180004690: using guessed type __int64 __fastcall sub_180004690(_QWORD);

//----- (000000018000FB7C) ----------------------------------------------------
__int64 __fastcall sub_18000FB7C(__int64 a1, __int64 a2)
{
  return sub_180006340(a2 + 64);
}
// 180006340: using guessed type __int64 __fastcall sub_180006340(_QWORD);

//----- (000000018000FB88) ----------------------------------------------------
__int64 __fastcall sub_18000FB88(__int64 a1, __int64 a2)
{
  return sub_180006340(a2 + 40);
}
// 180006340: using guessed type __int64 __fastcall sub_180006340(_QWORD);

//----- (000000018000FB94) ----------------------------------------------------
__int64 __fastcall sub_18000FB94(__int64 a1, __int64 a2)
{
  return sub_180006340(a2 + 88);
}
// 180006340: using guessed type __int64 __fastcall sub_180006340(_QWORD);

//----- (000000018000FBA0) ----------------------------------------------------
__int64 __fastcall sub_18000FBA0(__int64 a1, __int64 a2)
{
  return sub_180006340(a2 + 112);
}
// 180006340: using guessed type __int64 __fastcall sub_180006340(_QWORD);

//----- (000000018000FBFC) ----------------------------------------------------
__int64 __fastcall sub_18000FBFC(__int64 a1, __int64 a2)
{
  return sub_180003110(a2 + 32);
}
// 180003110: using guessed type __int64 __fastcall sub_180003110(_QWORD);

//----- (000000018000FC30) ----------------------------------------------------
__int64 __fastcall sub_18000FC30(__int64 a1, __int64 a2)
{
  return sub_180003110(a2 + 32);
}
// 180003110: using guessed type __int64 __fastcall sub_180003110(_QWORD);

//----- (000000018000FC3C) ----------------------------------------------------
__int64 __fastcall sub_18000FC3C(__int64 a1, __int64 a2)
{
  return sub_180003110(a2 + 32);
}
// 180003110: using guessed type __int64 __fastcall sub_180003110(_QWORD);

//----- (000000018000FC9C) ----------------------------------------------------
__int64 __fastcall sub_18000FC9C(__int64 a1, __int64 a2)
{
  return sub_1800083E0(a2 + 32);
}
// 1800083E0: using guessed type __int64 __fastcall sub_1800083E0(_QWORD);

//----- (000000018000FCBC) ----------------------------------------------------
__int64 __fastcall sub_18000FCBC(__int64 a1, __int64 a2)
{
  return sub_180008350(a2 + 32);
}
// 180008350: using guessed type __int64 __fastcall sub_180008350(_QWORD);

//----- (000000018000FCF0) ----------------------------------------------------
__int64 __fastcall sub_18000FCF0(__int64 a1, __int64 a2)
{
  return sub_180003C30(a2 + 32);
}
// 180003C30: using guessed type __int64 __fastcall sub_180003C30(_QWORD);

//----- (000000018000FD00) ----------------------------------------------------
__int64 __fastcall sub_18000FD00(__int64 a1, __int64 a2)
{
  return sub_1800027F0(a2 + 64);
}
// 1800027F0: using guessed type __int64 __fastcall sub_1800027F0(_QWORD);

//----- (000000018000FD40) ----------------------------------------------------
__int64 __fastcall sub_18000FD40(__int64 a1, __int64 a2)
{
  return sub_1800027F0(a2 + 64);
}
// 1800027F0: using guessed type __int64 __fastcall sub_1800027F0(_QWORD);

//----- (000000018000FD58) ----------------------------------------------------
__int64 __fastcall sub_18000FD58(__int64 a1, __int64 a2)
{
  return sub_180002770(a2 + 96);
}
// 180002770: using guessed type __int64 __fastcall sub_180002770(_QWORD);

//----- (000000018000FF70) ----------------------------------------------------
void __fastcall sub_18000FF70()
{
  _BYTE *v0; // rcx
  CHAR *v1; // rcx

  if ( (unsigned __int64)qword_180017510 > 0xF )
  {
    if ( (unsigned __int64)(qword_180017510 + 1) < 0x1000 )
    {
      v0 = xmmword_1800174F8;
    }
    else
    {
      v0 = (_BYTE *)*((_QWORD *)xmmword_1800174F8 - 1);
      if ( (unsigned __int64)((_BYTE *)xmmword_1800174F8 - v0 - 8) > 0x1F )
        goto LABEL_10;
    }
    j_j_free(v0);
  }
  qword_180017508 = 0;
  qword_180017510 = 15;
  LOBYTE(xmmword_1800174F8) = 0;
  sub_180002C40((__int64)&qword_1800174D8);
  if ( (unsigned __int64)qword_1800174C8 > 0xF )
  {
    if ( (unsigned __int64)(qword_1800174C8 + 1) < 0x1000 )
    {
      v1 = (CHAR *)pszAddrString;
    }
    else
    {
      v1 = (CHAR *)*((_QWORD *)pszAddrString - 1);
      if ( (unsigned __int64)(pszAddrString - v1 - 8) > 0x1F )
LABEL_10:
        __fastfail(5u);
    }
    j_j_free(v1);
  }
  qword_1800174C0 = 0;
  qword_1800174C8 = 15;
  LOBYTE(pszAddrString) = 0;
}
// 1800174C0: using guessed type __int64 qword_1800174C0;
// 1800174C8: using guessed type __int64 qword_1800174C8;
// 1800174D8: using guessed type __int64 qword_1800174D8;
// 180017508: using guessed type __int64 qword_180017508;
// 180017510: using guessed type __int64 qword_180017510;

//----- (0000000180010050) ----------------------------------------------------
void __fastcall sub_180010050()
{
  void *v0; // rcx
  _QWORD *v1; // rbx
  void *v2; // rcx

  v0 = qword_180017518;
  v1 = (_QWORD *)*((_QWORD *)qword_180017518 + 1);
  if ( !*((_BYTE *)v1 + 25) )
  {
    do
    {
      sub_180003C40((__int64)&qword_180017518, (__int64)&qword_180017518, v1[2]);
      v2 = v1;
      v1 = (_QWORD *)*v1;
      j_j_free(v2);
    }
    while ( !*((_BYTE *)v1 + 25) );
    v0 = qword_180017518;
  }
  j_j_free(v0);
}

//----- (00000001800100C0) ----------------------------------------------------
void __fastcall sub_1800100C0()
{
  sub_1800064D0((void **)&qword_180017528);
}
// 180017528: using guessed type __int64 qword_180017528;

//----- (00000001800100D0) ----------------------------------------------------
void __fastcall sub_1800100D0()
{
  sub_1800079B0((__int64)&dword_180017580);
}
// 180017580: using guessed type int dword_180017580;

//----- (00000001800100E0) ----------------------------------------------------
void __fastcall sub_1800100E0()
{
  sub_180007A30((__int64)&dword_1800175C0);
}
// 1800175C0: using guessed type int dword_1800175C0;

//----- (00000001800100F0) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __fastcall sub_1800100F0(double _XMM0_8)
{
  _BYTE *v1; // rcx

  if ( Src )
  {
    if ( ((qword_180017548 - (_QWORD)Src) & 0xFFFFFFFFFFFFFFF0uLL) < 0x1000 )
    {
      v1 = Src;
    }
    else
    {
      v1 = (_BYTE *)*((_QWORD *)Src - 1);
      if ( (unsigned __int64)((_BYTE *)Src - v1 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v1);
    __asm
    {
      vpxor   xmm0, xmm0, xmm0
      vmovdqu cs:Src, xmm0
    }
    qword_180017548 = 0;
  }
}
// 1800100F0: inconsistent variable size for 'xmm0_8.8'
// 180017548: using guessed type __int64 qword_180017548;

//----- (0000000180010160) ----------------------------------------------------
void __fastcall sub_180010160()
{
  void *v0; // rcx
  _QWORD *v1; // rbx
  void *v2; // rcx

  v0 = qword_180017550;
  v1 = (_QWORD *)*((_QWORD *)qword_180017550 + 1);
  if ( !*((_BYTE *)v1 + 25) )
  {
    do
    {
      sub_18000CDD0((__int64)&qword_180017550, (__int64)&qword_180017550, v1[2]);
      v2 = v1;
      v1 = (_QWORD *)*v1;
      j_j_free(v2);
    }
    while ( !*((_BYTE *)v1 + 25) );
    v0 = qword_180017550;
  }
  j_j_free(v0);
}

// #eh34_calls=0 #try=3 #catch=3 #wind=0 #gotos=283
// nfuncs=337 queued=247 decompiled=247 lumina nreq=0 worse=0 better=0
// ALL OK, 247 function(s) have been successfully decompiled
